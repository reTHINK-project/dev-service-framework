[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/bus/Bus.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author micaelpedrosa@gmail.com\n* Minimal interface and implementation to send and receive messages. It can be reused in many type of components.\n* Components that need a message system should receive this class as a dependency or extend it.\n* Extensions should implement the following private methods: _onPostMessage and _registerExternalListener\n*/\nclass Bus {\n  /* private\n  _msgId: number;\n  _subscriptions: <url: MsgListener[]>\n\n  _responseTimeOut: number\n  _responseCallbacks: <url+id: (msg) => void>\n\n  */\n\n  constructor() {\n    let _this = this;\n    _this._msgId = 0;\n    _this._subscriptions = {};\n\n    _this._responseTimeOut = 5000; //default to 3s\n    _this._responseCallbacks = {};\n\n    _this._registerExternalListener();\n  }\n\n  /**\n  * Register listener to receive message when \"msg.to === url\".\n  * Special url \"*\" for default listener is accepted to intercept all messages.\n  * @param {URL} url Address to intercept, tha is in the message \"to\"\n  * @param {Listener} listener listener\n  * @return {MsgListener} instance of MsgListener\n  */\n  addListener(url, listener) {\n    let _this = this;\n\n    let item = new MsgListener(_this._subscriptions, url, listener);\n    let itemList = _this._subscriptions[url];\n    if (!itemList) {\n      itemList = [];\n      _this._subscriptions[url] = itemList;\n    }\n\n    itemList.push(item);\n    return item;\n  }\n\n  /**\n   * Manually add a response listener. Only one listener per message ID should exist.\n   * ATENTION, there is no timeout for this listener.\n   * The listener should be removed with a removeResponseListener, failing to do this will result in a unreleased memory problem.\n   * @param {URL} url Origin address of the message sent, \"msg.from\".\n   * @param {number} msgId Message ID that is returned from the postMessage.\n   * @param {Function} responseListener Callback function for the response\n   */\n  addResponseListener(url, msgId, responseListener) {\n    this._responseCallbacks[url + msgId] = responseListener;\n  }\n\n  /**\n   * Remove the response listener.\n   * @param {URL} url Origin address of the message sent, \"msg.from\".\n   * @param {number} msgId  Message ID that is returned from the postMessage\n   */\n  removeResponseListener(url, msgId) {\n    delete this._responseCallbacks[url + msgId];\n  }\n\n  /**\n   * Remove all existent listeners for the URL\n   * @param  {URL} url Address registered\n   */\n  removeAllListenersOf(url) {\n    delete this._subscriptions[url];\n  }\n\n  /**\n   * Helper method to bind listeners (in both directions) into other MiniBus target.\n   * @param  {URL} outUrl Outbound URL, register listener for url in direction \"this -> target\"\n   * @param  {URL} inUrl Inbound URL, register listener for url in direction \"target -> this\"\n   * @param  {MiniBus} target The other target MiniBus\n   * @return {Bound} an object that contains the properties [thisListener, targetListener] and the unbind method.\n   */\n  bind(outUrl, inUrl, target) {\n    let _this = this;\n\n    let thisListn = _this.addListener(outUrl, (msg) => {\n      target.postMessage(msg);\n    });\n\n    let targetListn = target.addListener(inUrl, (msg) => {\n      _this.postMessage(msg);\n    });\n\n    return {\n      thisListener: thisListn,\n      targetListener: targetListn,\n      unbind: () => {\n        this.thisListener.remove();\n        this.targetListener.remove();\n      }\n    };\n  }\n\n  //publish on default listeners\n  _publishOnDefault(msg) {\n    //is there any \"*\" (default) listeners?\n    let itemList = this._subscriptions['*'];\n    if (itemList) {\n      this._publishOn(itemList, msg);\n    }\n  }\n\n  //publish on a subscription list.\n  _publishOn(itemList, msg) {\n    itemList.forEach((sub) => {\n      sub._callback(msg);\n    });\n  }\n\n  _responseCallback(inMsg, responseCallback) {\n    let _this = this;\n\n    //automatic management of response handlers\n    if (responseCallback) {\n      let responseId = inMsg.from + inMsg.id;\n      _this._responseCallbacks[responseId] = responseCallback;\n\n      setTimeout(() => {\n        let responseFun = _this._responseCallbacks[responseId];\n        delete _this._responseCallbacks[responseId];\n\n        if (responseFun) {\n          let errorMsg = {\n            id: inMsg.id, type: 'response',\n            body: { code: 408, desc: 'Response timeout!', value: inMsg }\n          };\n\n          responseFun(errorMsg);\n        }\n      }, _this._responseTimeOut);\n    }\n  }\n\n  _onResponse(msg) {\n    let _this = this;\n\n    if (msg.type === 'response') {\n      let responseId = msg.to + msg.id;\n      let responseFun = _this._responseCallbacks[responseId];\n\n      //if it's a provisional response, don't delete response listener\n      if (msg.body.code >= 200) {\n        delete _this._responseCallbacks[responseId];\n      }\n\n      if (responseFun) {\n        responseFun(msg);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  //receive messages from external interface\n  _onMessage(msg) {\n    let _this = this;\n\n    if (!_this._onResponse(msg)) {\n      let itemList = _this._subscriptions[msg.to];\n      if (itemList) {\n        _this._publishOn(itemList, msg);\n      } else {\n        _this._publishOnDefault(msg);\n      }\n    }\n  }\n\n  _genId(inMsg) {\n    //TODO: how do we manage message ID's? Should it be a global runtime counter, or per URL address?\n    //Global counter will not work, because there will be multiple MiniBus instances!\n    //Per URL, can be a lot of data to maintain!\n    //Maybe a counter per MiniBus instance. This is the assumed solution for now.\n    if (!inMsg.id || inMsg.id === 0) {\n      this._msgId++;\n      inMsg.id = this._msgId;\n    }\n  }\n\n  /**\n  * Send messages to local listeners, or if not exists to external listeners.\n  * It's has an optional mechanism for automatic management of response handlers.\n  * The response handler will be unregistered after receiving the response, or after response timeout (default to 3s).\n  * @param  {Message} msg Message to send. Message ID is automatically added to the message.\n  * @param  {Function} responseCallback Optional parameter, if the developer what's automatic response management.\n  * @return {number} Returns the message ID, in case it should be needed for manual management of the response handler.\n  */\n  postMessage(inMsg, responseCallback) { }\n\n  /**\n   * Not public available, used by the class extension implementation, to process messages from the public \"postMessage\" without a registered listener.\n   * Used to send the message to an external interface, like a WebWorker, IFrame, etc.\n   * @param  {Message.Message} msg Message\n   */\n  _onPostMessage(msg) { /*implementation will send message to external system*/ }\n\n  /**\n   * Not public available, used by the class extension implementation, to process all messages that enter the MiniBus from an external interface, like a WebWorker, IFrame, etc.\n   * This method is called one time in the constructor to register external listeners.\n   * The implementation will probably call the \"_onMessage\" method to publish in the local listeners.\n   * DO NOT call \"postMessage\", there is a danger that the message enters in a cycle!\n   */\n  _registerExternalListener() { /*implementation will register external listener and call \"this._onMessage(msg)\" */ }\n\n}\n\nclass MsgListener {\n  /* private\n  _subscriptions: <string: MsgListener[]>;\n  _url: string;\n  _callback: (msg) => void;\n  */\n\n  constructor(subscriptions, url, callback) {\n    let _this = this;\n\n    _this._subscriptions = subscriptions;\n    _this._url = url;\n    _this._callback = callback;\n  }\n\n  get url() { return this._url; }\n\n  /**\n   * Remove this listener from the Bus\n   */\n  remove() {\n    let _this = this;\n\n    let subs = _this._subscriptions[_this._url];\n    if (subs) {\n      let index = subs.indexOf(_this);\n      subs.splice(index, 1);\n\n      //if there are no listeners, remove the subscription entirely.\n      if (subs.length === 0) {\n        delete _this._subscriptions[_this._url];\n      }\n    }\n  }\n}\n\nexport default Bus;\n",
    "static": true,
    "longname": "src/bus/Bus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "MsgListener",
    "memberof": "src/bus/Bus.js",
    "static": true,
    "longname": "src/bus/Bus.js~MsgListener",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/bus/Bus.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Bus.js~MsgListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~MsgListener#constructor",
    "access": null,
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "subscriptions",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "get",
    "name": "url",
    "memberof": "src/bus/Bus.js~MsgListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~MsgListener#url",
    "access": null,
    "description": null,
    "lineNumber": 257,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "method",
    "name": "remove",
    "memberof": "src/bus/Bus.js~MsgListener",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~MsgListener#remove",
    "access": null,
    "description": "Remove this listener from the Bus",
    "lineNumber": 262,
    "params": []
  },
  {
    "__docId__": 5,
    "kind": "class",
    "name": "Bus",
    "memberof": "src/bus/Bus.js",
    "static": true,
    "longname": "src/bus/Bus.js~Bus",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/bus/Bus.js",
    "importStyle": "Bus",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nMinimal interface and implementation to send and receive messages. It can be reused in many type of components.\nComponents that need a message system should receive this class as a dependency or extend it.\nExtensions should implement the following private methods: _onPostMessage and _registerExternalListener"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 6,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#constructor",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 7,
    "kind": "method",
    "name": "addListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#addListener",
    "access": null,
    "description": "Register listener to receive message when \"msg.to === url\".\nSpecial url \"*\" for default listener is accepted to intercept all messages.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Address to intercept, tha is in the message \"to\""
      },
      {
        "nullable": null,
        "types": [
          "Listener"
        ],
        "spread": false,
        "optional": false,
        "name": "listener",
        "description": "listener"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "MsgListener"
      ],
      "spread": false,
      "description": "instance of MsgListener"
    }
  },
  {
    "__docId__": 8,
    "kind": "method",
    "name": "addResponseListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#addResponseListener",
    "access": null,
    "description": "Manually add a response listener. Only one listener per message ID should exist.\nATENTION, there is no timeout for this listener.\nThe listener should be removed with a removeResponseListener, failing to do this will result in a unreleased memory problem.",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Origin address of the message sent, \"msg.from\"."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "msgId",
        "description": "Message ID that is returned from the postMessage."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "responseListener",
        "description": "Callback function for the response"
      }
    ]
  },
  {
    "__docId__": 9,
    "kind": "method",
    "name": "removeResponseListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#removeResponseListener",
    "access": null,
    "description": "Remove the response listener.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Origin address of the message sent, \"msg.from\"."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "msgId",
        "description": "Message ID that is returned from the postMessage"
      }
    ]
  },
  {
    "__docId__": 10,
    "kind": "method",
    "name": "removeAllListenersOf",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#removeAllListenersOf",
    "access": null,
    "description": "Remove all existent listeners for the URL",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Address registered"
      }
    ]
  },
  {
    "__docId__": 11,
    "kind": "method",
    "name": "bind",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#bind",
    "access": null,
    "description": "Helper method to bind listeners (in both directions) into other MiniBus target.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "outUrl",
        "description": "Outbound URL, register listener for url in direction \"this -> target\""
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "inUrl",
        "description": "Inbound URL, register listener for url in direction \"target -> this\""
      },
      {
        "nullable": null,
        "types": [
          "MiniBus"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "The other target MiniBus"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Bound"
      ],
      "spread": false,
      "description": "an object that contains the properties [thisListener, targetListener] and the unbind method."
    }
  },
  {
    "__docId__": 12,
    "kind": "method",
    "name": "_publishOnDefault",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_publishOnDefault",
    "access": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 13,
    "kind": "method",
    "name": "_publishOn",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_publishOn",
    "access": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "itemList",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 14,
    "kind": "method",
    "name": "_responseCallback",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_responseCallback",
    "access": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "inMsg",
        "types": [
          "*"
        ]
      },
      {
        "name": "responseCallback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 15,
    "kind": "method",
    "name": "_onResponse",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_onResponse",
    "access": null,
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "method",
    "name": "_onMessage",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_onMessage",
    "access": null,
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 17,
    "kind": "method",
    "name": "_genId",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_genId",
    "access": null,
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "inMsg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 18,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#postMessage",
    "access": null,
    "description": "Send messages to local listeners, or if not exists to external listeners.\nIt's has an optional mechanism for automatic management of response handlers.\nThe response handler will be unregistered after receiving the response, or after response timeout (default to 3s).",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message to send. Message ID is automatically added to the message."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "responseCallback",
        "description": "Optional parameter, if the developer what's automatic response management."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Returns the message ID, in case it should be needed for manual management of the response handler."
    }
  },
  {
    "__docId__": 19,
    "kind": "method",
    "name": "_onPostMessage",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_onPostMessage",
    "access": null,
    "description": "Not public available, used by the class extension implementation, to process messages from the public \"postMessage\" without a registered listener.\nUsed to send the message to an external interface, like a WebWorker, IFrame, etc.",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message.Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message"
      }
    ]
  },
  {
    "__docId__": 20,
    "kind": "method",
    "name": "_registerExternalListener",
    "memberof": "src/bus/Bus.js~Bus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Bus.js~Bus#_registerExternalListener",
    "access": null,
    "description": "Not public available, used by the class extension implementation, to process all messages that enter the MiniBus from an external interface, like a WebWorker, IFrame, etc.\nThis method is called one time in the constructor to register external listeners.\nThe implementation will probably call the \"_onMessage\" method to publish in the local listeners.\nDO NOT call \"postMessage\", there is a danger that the message enters in a cycle!",
    "lineNumber": 238,
    "params": []
  },
  {
    "__docId__": 21,
    "kind": "file",
    "name": "src/bus/MessageBus.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nimport Bus from './Bus';\nimport Pipeline from './Pipeline';\n\n/**\n* @author micaelpedrosa@gmail.com\n* Message BUS Interface is an extension of the Bus\n* It doesn't support the default '*' listener, instead it uses the registry.resolve(..)\n*/\nclass MessageBus extends Bus {\n  /* private\n  _registry: Registry\n  _forwards: { <from-url>: { fl: MsgListener, sandboxToUrls: Map(Sandbox, [to-url]), urlToSandbox: { to-url: Sandbox } } }\n\n  _pipeline: Pipeline\n  */\n\n  //TODO: future optimization\n  //1. message batch processing with setInterval\n  //2. resolve default gateway/protostub with register.resolve\n\n  constructor(registry) {\n    super();\n    this._registry = registry;\n    this._forwards = {};\n\n    this._pipeline = new Pipeline((error) => {\n      console.log('PIPELINE-ERROR: ', JSON.stringify(error));\n    });\n  }\n\n  get pipeline() { return this._pipeline; }\n\n  /**\n   * Post a message for routing. It will first search for a listener, if there is no one, it sends to a external routing using the _onPostMessage.\n   * External routing use the registry.resolve(..) method to decide the destination sandbox.\n   * @param  {Message} inMsg            JSON with mandatory Message structure {id, type, from, to}\n   * @param  {Callback} responseCallback Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\".\n   * @return {number}                  the Message id\n   */\n  postMessage(inMsg, responseCallback) {\n    console.log('onPOSTMessage: ', inMsg);\n    let _this = this;\n\n    _this._genId(inMsg);\n\n    _this._pipeline.process(inMsg, (msg) => {\n\n      _this._responseCallback(inMsg, responseCallback);\n\n      if (!_this._onResponse(msg)) {\n        let itemList = _this._subscriptions[msg.to];\n        if (itemList) {\n          //do not publish on default address, because of loopback cycle\n          _this._publishOn(itemList, msg);\n        } else {\n          //if there is no listener, send to external interface\n          _this._onPostMessage(msg);\n        }\n      }\n    });\n\n    return inMsg.id;\n  }\n\n  /**\n   * Adds an external publish address listener. Every message for the address will be forwarded to the external routing by _onPostMessage.\n   * This means, even if there is a listener for the address, it will also send the message to the external routing.\n   * @param {URL} from Publish address.\n   */\n  addPublish(from) {\n    let _this = this;\n\n    //verify if forward exist\n    let refCount = _this._forwards[from];\n    if (!refCount) {\n      let forwardListener = _this.addListener(from, (msg) => {\n        console.log('MB-PUBLISH: ( ' + from + ' )');\n        _this._onPostMessage(msg);\n      });\n\n      refCount = {\n        counter: 0,\n        fl: forwardListener,\n        remove: () => {\n          this.counter--;\n          if (this.counter === 0) {\n            this.fl.remove();\n            delete _this._forwards[from];\n          }\n        }\n      };\n\n     _this._forwards[from] = refCount;\n   }\n\n   refCount.counter++;\n   return refCount;\n  }\n\n  /**\n   * Adds a forward listener for a message destination. Every message reaching an address will be also sent to the forward address.\n   * @param {URL} from Message destination, it's actually the field \"to\" of the message.\n   * @param {URL} to   Forward address.\n   */\n   addForward(from, to) {\n     let _this = this;\n\n     return _this.addListener(from, (msg) => {\n       console.log('MB-FORWARD: ( ' + from + ' to ' + to + ' )');\n       _this.forward(to, msg);\n     });\n   }\n\n   /**\n    * Just forward's a message to the forward address. Listeners should be available for the forward address.\n    * @param  {URL} url Forward address.\n    * @param  {Message} msg Message to forward\n    */\n   forward(url, msg) {\n     let _this = this;\n\n     let itemList = _this._subscriptions[url];\n     if (itemList) {\n       _this._publishOn(itemList, msg);\n     }\n   }\n\n   //default route, if there are no listeners available for a message destination.\n   _onPostMessage(msg) {\n     let _this = this;\n\n     //resolve external protostub...\n     _this._registry.resolve(msg.to).then((route) => {\n       _this.forward(route, msg);\n     }).catch(function(e) {\n       console.log('RESOLVE-ERROR: ', e);\n     });\n   }\n}\n\nexport default MessageBus;\n",
    "static": true,
    "longname": "src/bus/MessageBus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 22,
    "kind": "class",
    "name": "MessageBus",
    "memberof": "src/bus/MessageBus.js",
    "static": true,
    "longname": "src/bus/MessageBus.js~MessageBus",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/bus/MessageBus.js",
    "importStyle": "MessageBus",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nMessage BUS Interface is an extension of the Bus\nIt doesn't support the default '*' listener, instead it uses the registry.resolve(..)"
      }
    ],
    "interface": false,
    "extends": [
      "src/bus/Bus.js~Bus"
    ]
  },
  {
    "__docId__": 23,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#constructor",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "registry",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "_registry",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_registry",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "_forwards",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_forwards",
    "access": null,
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "name": "_pipeline",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_pipeline",
    "access": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 27,
    "kind": "get",
    "name": "pipeline",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#pipeline",
    "access": null,
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#postMessage",
    "access": null,
    "description": "Post a message for routing. It will first search for a listener, if there is no one, it sends to a external routing using the _onPostMessage.\nExternal routing use the registry.resolve(..) method to decide the destination sandbox.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "inMsg",
        "description": "JSON with mandatory Message structure {id, type, from, to}"
      },
      {
        "nullable": null,
        "types": [
          "Callback"
        ],
        "spread": false,
        "optional": false,
        "name": "responseCallback",
        "description": "Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\"."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the Message id"
    }
  },
  {
    "__docId__": 29,
    "kind": "method",
    "name": "addPublish",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#addPublish",
    "access": null,
    "description": "Adds an external publish address listener. Every message for the address will be forwarded to the external routing by _onPostMessage.\nThis means, even if there is a listener for the address, it will also send the message to the external routing.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "Publish address."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 30,
    "kind": "method",
    "name": "addForward",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#addForward",
    "access": null,
    "description": "Adds a forward listener for a message destination. Every message reaching an address will be also sent to the forward address.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "from",
        "description": "Message destination, it's actually the field \"to\" of the message."
      },
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "to",
        "description": "Forward address."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 31,
    "kind": "method",
    "name": "forward",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#forward",
    "access": null,
    "description": "Just forward's a message to the forward address. Listeners should be available for the forward address.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Forward address."
      },
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message to forward"
      }
    ]
  },
  {
    "__docId__": 32,
    "kind": "method",
    "name": "_onPostMessage",
    "memberof": "src/bus/MessageBus.js~MessageBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MessageBus.js~MessageBus#_onPostMessage",
    "access": null,
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 33,
    "kind": "file",
    "name": "src/bus/MiniBus.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nimport Bus from './Bus';\n\n/**\n* @author micaelpedrosa@gmail.com\n* Message BUS Interface is an extension of the Bus\n* It is used mainly in the internal sandbox routing.\n*/\nclass MiniBus extends Bus {\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Post a message for routing. Message is routed directly to the external routing _onPostMessage.\n   * @param  {Message} inMsg            JSON with mandatory Message structure {id, type, from, to}\n   * @param  {Callback} responseCallback Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\".\n   * @return {number}                  the Message id\n   */\n  postMessage(inMsg, responseCallback) {\n    let _this = this;\n\n    _this._genId(inMsg);\n    _this._responseCallback(inMsg, responseCallback);\n\n    //always send to external (to core MessageBus)\n    _this._onPostMessage(inMsg);\n\n    return inMsg.id;\n  }\n\n  //internal method used when a message is received by an external routing system\n  _onMessage(msg) {\n    let _this = this;\n\n    if (!_this._onResponse(msg)) {\n      let itemList = _this._subscriptions[msg.to];\n      if (itemList) {\n        _this._publishOn(itemList, msg);\n        if (!msg.to.startsWith('hyperty')) {\n          _this._publishOnDefault(msg);\n        }\n      } else {\n        _this._publishOnDefault(msg);\n      }\n    }\n  }\n\n}\n\nexport default MiniBus;\n",
    "static": true,
    "longname": "src/bus/MiniBus.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 34,
    "kind": "class",
    "name": "MiniBus",
    "memberof": "src/bus/MiniBus.js",
    "static": true,
    "longname": "src/bus/MiniBus.js~MiniBus",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/bus/MiniBus.js",
    "importStyle": "MiniBus",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nMessage BUS Interface is an extension of the Bus\nIt is used mainly in the internal sandbox routing."
      }
    ],
    "interface": false,
    "extends": [
      "src/bus/Bus.js~Bus"
    ]
  },
  {
    "__docId__": 35,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/MiniBus.js~MiniBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MiniBus.js~MiniBus#constructor",
    "access": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 36,
    "kind": "method",
    "name": "postMessage",
    "memberof": "src/bus/MiniBus.js~MiniBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MiniBus.js~MiniBus#postMessage",
    "access": null,
    "description": "Post a message for routing. Message is routed directly to the external routing _onPostMessage.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "inMsg",
        "description": "JSON with mandatory Message structure {id, type, from, to}"
      },
      {
        "nullable": null,
        "types": [
          "Callback"
        ],
        "spread": false,
        "optional": false,
        "name": "responseCallback",
        "description": "Optional callback if a response is expected from the request. A response will be always sent, even if it is a \"Timeout\"."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the Message id"
    }
  },
  {
    "__docId__": 37,
    "kind": "method",
    "name": "_onMessage",
    "memberof": "src/bus/MiniBus.js~MiniBus",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/MiniBus.js~MiniBus#_onMessage",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 38,
    "kind": "file",
    "name": "src/bus/Pipeline.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n* @author micaelpedrosa@gmail.com\n* Sequencial processor of methods. Similar to how Sequential Promise's work, but better fit for message processing.\n* Normal use for this, is to intercept all messages with configured handlers, and act accordingly.\n*/\nclass Pipeline {\n  /* public\n    handlers: ((PipeContext) => void)[]\n    onFail: (error) => void\n  */\n\n  constructor(_onFail) {\n    let _this = this;\n\n    _this.handlers = [];\n    _this.onFail = _onFail;\n  }\n\n  /**\n   * Insert a message in the pipeline queue. All messages are wrapped with a PipeContext.\n   * @param  {Message} msg       Message for the queue\n   * @param  {Callback} onDeliver When message is finished processing from all handlers, it will be delivered in this callback.\n   */\n  process(msg, onDeliver) {\n    let _this = this;\n\n    if (_this.handlers.length > 0) {\n      let iter = new Iterator(_this.handlers);\n      iter.next(new PipeContext(_this, iter, msg, onDeliver));\n    } else {\n      onDeliver(msg);\n    }\n  }\n}\n\n/**\n* @author micaelpedrosa@gmail.com\n* Wrapper around a message that adds actions that can be fired by any interceptor handler.\n* The Pipeline is asynchronous, so an handler should always call an action, the default one is \"next()\"\n*/\nclass PipeContext {\n  /* private\n    _inStop: boolean\n\n    _pipeline: Pipeline\n    _iter: Iterator\n    _msg: Message\n  */\n\n  constructor(pipeline, iter, msg, onDeliver) {\n    let _this = this;\n\n    _this._inStop = false;\n\n    _this._pipeline = pipeline;\n    _this._iter = iter;\n    _this._msg = msg;\n    _this._onDeliver = onDeliver;\n  }\n\n  get pipeline() { return this._pipeline; }\n\n  get msg() { return this._msg; }\n  set msg(inMsg) { this._msg = inMsg; }\n\n  /**\n   * Proceed to the next interceptor handler, unless there was an error. If it's the last one, proceed to onDeliver handler.\n   */\n  next() {\n    let _this = this;\n\n    if (!_this._inStop) {\n      if (_this._iter.hasNext) {\n        _this._iter.next(_this);\n      } else {\n        _this._onDeliver(_this._msg);\n      }\n    }\n  }\n\n  /**\n   * Proceed directly to the onDeliver handler, unless there was an error.\n   */\n  deliver() {\n    let _this = this;\n    if (!_this._inStop) {\n      _this._inStop = true;\n      _this._onDeliver(_this._msg);\n    }\n  }\n\n  /**\n   * Mark the context with an error and proceed to the onFail handler.\n   * @param  {[type]} error [description]\n   */\n  fail(error) {\n    let _this = this;\n\n    if (!_this._inStop) {\n      _this._inStop = true;\n      if (_this._pipeline.onFail) {\n        _this._pipeline.onFail(error);\n      }\n    }\n  }\n}\n\nclass Iterator {\n  /* private\n    _index: number\n    _array: []\n  */\n\n  constructor(array) {\n    this._index = -1;\n    this._array = array;\n  }\n\n  get hasNext() {\n    return this._index < this._array.length - 1;\n  }\n\n  get next() {\n    this._index++;\n    return this._array[this._index];\n  }\n}\n\nexport default Pipeline;\n",
    "static": true,
    "longname": "src/bus/Pipeline.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 39,
    "kind": "class",
    "name": "PipeContext",
    "memberof": "src/bus/Pipeline.js",
    "static": true,
    "longname": "src/bus/Pipeline.js~PipeContext",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/bus/Pipeline.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nWrapper around a message that adds actions that can be fired by any interceptor handler.\nThe Pipeline is asynchronous, so an handler should always call an action, the default one is \"next()\""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 40,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#constructor",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pipeline",
        "types": [
          "*"
        ]
      },
      {
        "name": "iter",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      },
      {
        "name": "onDeliver",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 41,
    "kind": "get",
    "name": "pipeline",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#pipeline",
    "access": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "get",
    "name": "msg",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#msg",
    "access": null,
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 43,
    "kind": "set",
    "name": "msg",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#msg",
    "access": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 44,
    "kind": "member",
    "name": "_msg",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#_msg",
    "access": null,
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 45,
    "kind": "method",
    "name": "next",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#next",
    "access": null,
    "description": "Proceed to the next interceptor handler, unless there was an error. If it's the last one, proceed to onDeliver handler.",
    "lineNumber": 92,
    "params": []
  },
  {
    "__docId__": 46,
    "kind": "method",
    "name": "deliver",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#deliver",
    "access": null,
    "description": "Proceed directly to the onDeliver handler, unless there was an error.",
    "lineNumber": 107,
    "params": []
  },
  {
    "__docId__": 47,
    "kind": "method",
    "name": "fail",
    "memberof": "src/bus/Pipeline.js~PipeContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~PipeContext#fail",
    "access": null,
    "description": "Mark the context with an error and proceed to the onFail handler.",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "[type]"
        ],
        "spread": false,
        "optional": false,
        "name": "error",
        "description": "[description]"
      }
    ]
  },
  {
    "__docId__": 48,
    "kind": "class",
    "name": "Iterator",
    "memberof": "src/bus/Pipeline.js",
    "static": true,
    "longname": "src/bus/Pipeline.js~Iterator",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/bus/Pipeline.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 49,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#constructor",
    "access": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "_index",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#_index",
    "access": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_array",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#_array",
    "access": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "get",
    "name": "hasNext",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#hasNext",
    "access": null,
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "get",
    "name": "next",
    "memberof": "src/bus/Pipeline.js~Iterator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Iterator#next",
    "access": null,
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "class",
    "name": "Pipeline",
    "memberof": "src/bus/Pipeline.js",
    "static": true,
    "longname": "src/bus/Pipeline.js~Pipeline",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/bus/Pipeline.js",
    "importStyle": "Pipeline",
    "description": "",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "micaelpedrosa@gmail.com\nSequencial processor of methods. Similar to how Sequential Promise's work, but better fit for message processing.\nNormal use for this, is to intercept all messages with configured handlers, and act accordingly."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 55,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/bus/Pipeline.js~Pipeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Pipeline#constructor",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "_onFail",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "process",
    "memberof": "src/bus/Pipeline.js~Pipeline",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/bus/Pipeline.js~Pipeline#process",
    "access": null,
    "description": "Insert a message in the pipeline queue. All messages are wrapped with a PipeContext.",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": "Message for the queue"
      },
      {
        "nullable": null,
        "types": [
          "Callback"
        ],
        "spread": false,
        "optional": false,
        "name": "onDeliver",
        "description": "When message is finished processing from all handlers, it will be delivered in this callback."
      }
    ]
  },
  {
    "__docId__": 57,
    "kind": "file",
    "name": "src/discovery/Discovery.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport {divideURL, convertToUserURL} from '../utils/utils';\n\n/**\n* Core Discovery interface\n* Class to allow applications to search for hyperties and DataObjects using the message bus\n*/\nclass Discovery {\n\n  /**\n  * To initialise the HypertyDiscover, which will provide the support for hyperties to\n  * query users registered in outside the internal core.\n  * @param  {MessageBus}          msgbus                msgbus\n  * @param  {RuntimeURL}          runtimeURL            runtimeURL\n  */\n  constructor(hypertyURL, runtimeURL, msgBus) {\n    let _this = this;\n    _this.messageBus = msgBus;\n    _this.runtimeURL = runtimeURL;\n\n    _this.domain = divideURL(hypertyURL).domain;\n    _this.discoveryURL = hypertyURL;\n  }\n\n  /**\n  * Advanced Search for Hyperties registered in domain registry associated with some user identifier (eg email, name ...)\n  * @param  {String}           userIdentifier\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  */\n  _isLegacyUser(userIdentifier) {\n    if (userIdentifier.includes(':') && !userIdentifier.includes('user://')) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n\n  /**\n  * Advanced Search for Hyperties registered in domain registry associated with some user identifier (eg email, name ...)\n  * @param  {String}           userIdentifier\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  */\n  discoverHypertiesPerUserProfileData(userIdentifier, schema, resources) {\n    let _this = this;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/hyperty/userprofile/' + userIdentifier,\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema\n      };\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      if (!_this._isLegacyUser(userIdentifier)) {// todo: to reomve when discovery of legcay users are supported\n        _this.messageBus.postMessage(msg, (reply) => {\n\n          if(reply.body.code === 200){\n            console.log(\"Reply log: \",reply.body.value);\n            resolve(reply.body.value);\n          }\n          else {\n            console.log(\"Error Log: \", reply.body.description);\n            reject(reply.body.description);\n          }\n        });\n      } else {\n        resolve({hypertyID: userIdentifier});\n      }\n\n    });\n  }\n\n  /**\n  * Advanced Search for DataObjects registered in domain registry associated with some user identifier (eg email, name ...)\n  * @param  {String}           userIdentifier\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  */\n  discoverDataObjectsPerUserProfileData(userIdentifier, schema, resources) {\n    let _this = this;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/dataObject/userprofile/' + userIdentifier,\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema\n      };\n    }\n\n    return new Promise(function(resolve, reject) {\n\n    if (!_this._isLegacyUser(userIdentifier)) {// todo: to reomve when discovery of legcay users are supported\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    } else {\n      resolve({hypertyID: userIdentifier});\n    }\n\n    });\n  }\n\n  /**\n  * Advanced Search for Hyperties registered in domain registry associated with some GUID\n  * @param  {String}           guidURL                guid URL e.g user-guid://<unique-user-identifier>\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  */\n  discoverHypertiesPerGUID(guidURL, schema, resources) {\n    let _this = this;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/hyperty/guid/' + guidURL,\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema\n      };\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /**\n  * Advanced Search for DataObjects registered in domain registry associated with some GUID\n  * @param  {String}           guidURL                guid URL e.g user-guid://<unique-user-identifier>\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  * @param  {String}           domain (Optional)     domain of the registry to search\n  */\n  discoverDataObjectsPerGUID(guidURL, schema, resources) {\n    let _this = this;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/dataObject/guid/' + guidURL,\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema\n      };\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /** Advanced Search for Hyperties registered in domain registry\n  * @param  {String}           user                  user identifier, either in url or email format\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  * @param  {String}           domain (Optional)     domain of the registry to search\n  */\n  discoverHyperties(user, schema, resources, domain) {\n    let _this = this;\n    let activeDomain;\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/hyperty/user/' + user,\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema,\n        domain: activeDomain\n      };\n    }else {\n      msg.body['criteria'] = {\n        domain: activeDomain\n      }\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      if (!_this._isLegacyUser(user)) {// todo: to reomve when discovery of legcay users are supported\n\n        _this.messageBus.postMessage(msg, (reply) => {\n\n          if(reply.body.code === 200){\n            console.log(\"Reply log: \",reply.body.value);\n            resolve(reply.body.value);\n          }\n          else {\n            console.log(\"Error Log: \", reply.body.description);\n            reject(reply.body.description);\n          }\n        });\n      } else {\n        resolve({hypertyID: user});\n      }\n\n    });\n  }\n\n  /** Advanced Search for DataObjects registered in domain registry\n  * @param  {String}           user                  user identifier, either in url or email format\n  * @param  {Array<string>}    schema (Optional)     types of dataObjects schemas\n  * @param  {Array<string>}    resources (Optional)  types of dataObjects resources\n  * @param  {String}           domain (Optional)     domain of the registry to search\n  */\n  discoverDataObjects(user, schema, resources, domain) {\n    let _this = this;\n    let activeDomain;\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/dataObject/user/' + user,\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema,\n        domain: activeDomain\n      };\n    }else {\n      msg.body['criteria'] = {\n        domain: activeDomain\n      }\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply Value Log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /**\n  * function to request about hyperties registered in domain registry, and\n  * return the hyperty information, if found.\n  * @param  {String}              url  hyperty URL\n  * @param  {String}            domain (Optional)\n  */\n  discoverHypertyPerURL(url, domain) {\n    let _this = this;\n    let activeDomain;\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/hyperty/url/' + url,\n        criteria: {\n          domain: activeDomain\n        }\n      }\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply Value Log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /**\n  * function to request about dataObject registered in domain registry, and\n  * return the dataObject information, if found.\n  * @param  {String}              url  dataObject URL\n  * @param  {String}            domain (Optional)\n  */\n  discoverDataObjectPerURL(url, domain) {\n    let _this = this;\n    let activeDomain;\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/dataObject/url/' + url,\n        criteria: {\n          domain: activeDomain\n        }\n      }\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply Value Log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /**\n  * function to request about an dataObjects registered in domain registry with a given name, and\n  * return the dataObjects information, if found.\n  * @param  {String}              name  dataObject URL\n  * @param  {Array<string>}    schema (Optional)     types of dataObjects schemas\n  * @param  {Array<string>}    resources (Optional)  types of dataObjects resources\n  * @param  {String}            domain (Optional)\n  */\n  discoverDataObjectsPerName(name, schema, resources, domain) {\n    let _this = this;\n    let activeDomain;\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/dataObject/name/' + name\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema,\n        domain: activeDomain\n      };\n    }else {\n      msg.body['criteria'] = {\n        domain: activeDomain\n      }\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply Value Log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /**\n  * function to request about specific reporter dataObject registered in domain registry, and\n  * return the dataObjects from that reporter.\n  * @param  {String}           reporter     dataObject reporter\n  * @param  {Array<string>}    schema (Optional)     types of dataObjects schemas\n  * @param  {Array<string>}    resources (Optional)  types of dataObjects resources\n  * @param  {String}           domain       (Optional)\n  */\n  discoverDataObjectsPerReporter(reporter, schema, resources, domain) {\n    let _this = this;\n    let activeDomain;\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n\n    let msg = {\n      type: 'read',\n      from: _this.discoveryURL,\n      to: _this.runtimeURL + '/discovery/',\n      body: {\n        resource: '/dataObject/reporter/' + reporter\n      }\n    };\n\n    if(schema || resources) {\n      msg.body['criteria'] = {\n        resources: resources,\n        dataSchemes: schema,\n        domain: activeDomain\n      };\n    }else {\n      msg.body['criteria'] = {\n        domain: activeDomain\n      }\n    }\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        if(reply.body.code === 200){\n          console.log(\"Reply Value Log: \",reply.body.value);\n          resolve(reply.body.value);\n        }\n        else {\n          console.log(\"Error Log: \", reply.body.description);\n          reject(reply.body.description);\n        }\n      });\n    });\n  }\n\n  /** Advanced Search for dataObjects registered in domain registry\n  * @deprecated Deprecated. Use discoverDataObjectsPerName instead\n  * @param  {String}           name                  name of the dataObject\n  * @param  {Array<string>}    schema (Optional)     types of dataObject schemas\n  * @param  {Array<string>}    resources (Optional)  types of dataObject resources\n  * @param  {String}           domain (Optional)     domain of the registry to search\n  */\n  discoverDataObject(name, schema, resources, domain) {\n    let _this = this;\n    let activeDomain;\n    //let userIdentifier = convertToUserURL(user);\n\n    activeDomain = (!domain) ? _this.domain : domain;\n\n    let msg = {\n      type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: name,\n      criteria: {resources: resources, dataSchemes: schema}\n      }\n    };\n\n    return new Promise(function(resolve, reject) {\n\n      _this.messageBus.postMessage(msg, (reply) => {\n        console.log('[Discovery]', reply)\n\n        if(reply.body.code>299)\n            return reject(reply.body.description || reply.body.desc )\n\n        let hyperties = reply.body.value;\n\n        if (hyperties) {\n          resolve(hyperties);\n        } else {\n          resolve({});\n        }\n      });\n    });\n  }\n\n  /** Advanced Search for Hyperties registered in domain registry\n  * @deprecated Deprecated. Use discoverHyperties instead\n  * @param  {String}           user                  user identifier, either in url or email format\n  * @param  {Array<string>}    schema (Optional)     types of hyperties schemas\n  * @param  {Array<string>}    resources (Optional)  types of hyperties resources\n  * @param  {String}           domain (Optional)     domain of the registry to search\n  */\n  discoverHyperty(user, schema, resources, domain) {\n    let _this = this;\n    let activeDomain;\n    let userIdentifier = convertToUserURL(user);\n\n    if (!domain) {\n      activeDomain = _this.domain;\n    } else {\n      activeDomain = domain;\n    }\n\n\n\n    return new Promise(function(resolve, reject) {\n\n      console.log('[Discovery.discoverHyperty] ACTIVE DOMAIN -> ', activeDomain, 'user->', user, 'schema->', schema, 'resources->', resources, 'domain->', domain);\n      if (user.includes(':') && !user.includes('user://')) {\n        console.log('[Discovery.discoverHyperty] ' + user + ' is legacy domain');\n        let legacyUser = { userID: user, hypertyID: user, schema: schema, resources: resources };\n        return resolve(legacyUser);\n      }\n      let msg = {\n        type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: userIdentifier,\n        criteria: {resources: resources, dataSchemes: schema}\n        }\n      };\n\n      console.info('[Discovery] msg to send->', msg);\n\n      _this.messageBus.postMessage(msg, (reply) => {\n\n        console.info('[Discovery] ON discoverHyperty->', reply);\n        let hyperties = reply.body.value;\n\n        if (hyperties) {\n          resolve(hyperties);\n        } else {\n          reject('No Hyperty was found');\n        }\n      });\n    });\n  }\n\n  /**\n  * function to request about users registered in domain registry, and\n  * return the last hyperty instance registered by the user.\n  * @deprecated Deprecated. Use discoverHyperty instead\n  * @param  {email}              email\n  * @param  {domain}            domain (Optional)\n  */\n  discoverHypertyPerUser(email, domain) {\n    let _this = this;\n    let activeDomain;\n\n    return new Promise(function(resolve, reject) {\n\n      // Hack for legacy users\n      if (email.includes(':') && !email.includes('user://')) {\n        console.log('[Discovery.discoverHyperty] ' + email +'is legacy domain');\n        let legacyUser = { id: email, hypertyURL: email, descriptor: 'unknown' };\n        return resolve(legacyUser);\n      }\n\n      if (!domain) {\n        activeDomain = _this.domain;\n      } else {\n        activeDomain = domain;\n      }\n\n      let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\n\n\n      // message to query domain registry, asking for a user hyperty.\n      let message = {\n        type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: identityURL}\n      };\n\n      console.info('[Discovery] Message: ', message, activeDomain, identityURL);\n\n      //console.info('[Discovery] message READ', message);\n\n      _this.messageBus.postMessage(message, (reply) => {\n        console.info('[Discovery] message reply', reply);\n\n        let hyperty;\n        let mostRecent;\n        let lastHyperty;\n        let value = reply.body.value;\n\n        for (hyperty in value) {\n          if (value[hyperty].lastModified !== undefined) {\n            if (mostRecent === undefined) {\n              mostRecent = new Date(value[hyperty].lastModified);\n              lastHyperty = hyperty;\n            } else {\n              let hypertyDate = new Date(value[hyperty].lastModified);\n              if (mostRecent.getTime() < hypertyDate.getTime()) {\n                mostRecent = hypertyDate;\n                lastHyperty = hyperty;\n              }\n            }\n          }\n        }\n\n        console.info('[Discovery] Last Hyperty: ', lastHyperty, mostRecent);\n\n        let hypertyURL = lastHyperty;\n\n        if (hypertyURL === undefined) {\n          return reject('User Hyperty not found');\n        }\n\n        let idPackage = {\n          id: email,\n          descriptor: value[hypertyURL].descriptor,\n          hypertyURL: hypertyURL\n        };\n\n        console.info('[Discovery] ===> hypertyDiscovery messageBundle: ', idPackage);\n        resolve(idPackage);\n      });\n    });\n  }\n\n  /**\n  * function to request about users registered in domain registry, and\n  * return the all the hyperties registered by the user\n  * @deprecated Deprecated. Use discoverHyperty instead\n  * @param  {email}              email\n  * @param  {domain}            domain (Optional)\n  */\n  discoverHypertiesPerUser(email, domain) {\n    let _this = this;\n    let activeDomain;\n    console.log('on Function->', email);\n    return new Promise(function(resolve, reject) {\n\n      if (email.includes(':') && !email.includes('user://')) {\n        console.log('[Discovery.discoverHyperty] is legacy domain');\n        let legacyUser = { userID: email, hypertyID: email, schema: schema, resources: resources };\n        return resolve(legacyUser);\n      }\n\n      if (!domain) {\n        activeDomain = _this.domain;\n      } else {\n        activeDomain = domain;\n      }\n\n      let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\n\n      // message to query domain registry, asking for a user hyperty.\n      let message = {\n        type: 'read', from: _this.discoveryURL, to: 'domain://registry.' + activeDomain + '/', body: { resource: identityURL}\n      };\n\n      console.log('[Discovery] Message discoverHypertiesPerUser: ', message, activeDomain, identityURL);\n\n      //console.info('[Discovery] message READ', message);\n\n      _this.messageBus.postMessage(message, (reply) => {\n        console.info('[Discovery] discoverHypertiesPerUser reply', reply);\n\n        let value = reply.body.value;\n\n        if (!value) {\n          return reject('User Hyperty not found');\n        }\n\n        resolve(value);\n      });\n    });\n  }\n\n}\n\nexport default Discovery;\n",
    "static": true,
    "longname": "src/discovery/Discovery.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 58,
    "kind": "class",
    "name": "Discovery",
    "memberof": "src/discovery/Discovery.js",
    "static": true,
    "longname": "src/discovery/Discovery.js~Discovery",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/discovery/Discovery.js",
    "importStyle": "Discovery",
    "description": "Core Discovery interface\nClass to allow applications to search for hyperties and DataObjects using the message bus",
    "lineNumber": 30,
    "interface": false
  },
  {
    "__docId__": 59,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#constructor",
    "access": null,
    "description": "To initialise the HypertyDiscover, which will provide the support for hyperties to\nquery users registered in outside the internal core.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "msgbus",
        "description": "msgbus"
      },
      {
        "nullable": null,
        "types": [
          "RuntimeURL"
        ],
        "spread": false,
        "optional": false,
        "name": "runtimeURL",
        "description": "runtimeURL"
      }
    ]
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "_isLegacyUser",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#_isLegacyUser",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry associated with some user identifier (eg email, name ...)",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userIdentifier",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "discoverHypertiesPerUserProfileData",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHypertiesPerUserProfileData",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry associated with some user identifier (eg email, name ...)",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userIdentifier",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "discoverDataObjectsPerUserProfileData",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObjectsPerUserProfileData",
    "access": null,
    "description": "Advanced Search for DataObjects registered in domain registry associated with some user identifier (eg email, name ...)",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userIdentifier",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "discoverHypertiesPerGUID",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHypertiesPerGUID",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry associated with some GUID",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "guidURL",
        "description": "guid URL e.g user-guid://<unique-user-identifier>"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "discoverDataObjectsPerGUID",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObjectsPerGUID",
    "access": null,
    "description": "Advanced Search for DataObjects registered in domain registry associated with some GUID",
    "lineNumber": 203,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "guidURL",
        "description": "guid URL e.g user-guid://<unique-user-identifier>"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "discoverHyperties",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHyperties",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "discoverDataObjects",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObjects",
    "access": null,
    "description": "Advanced Search for DataObjects registered in domain registry",
    "lineNumber": 299,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of dataObjects schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of dataObjects resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "discoverHypertyPerURL",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHypertyPerURL",
    "access": null,
    "description": "function to request about hyperties registered in domain registry, and\nreturn the hyperty information, if found.",
    "lineNumber": 348,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "hyperty URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "discoverDataObjectPerURL",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObjectPerURL",
    "access": null,
    "description": "function to request about dataObject registered in domain registry, and\nreturn the dataObject information, if found.",
    "lineNumber": 388,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "discoverDataObjectsPerName",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObjectsPerName",
    "access": null,
    "description": "function to request about an dataObjects registered in domain registry with a given name, and\nreturn the dataObjects information, if found.",
    "lineNumber": 430,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "dataObject URL"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of dataObjects schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of dataObjects resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "discoverDataObjectsPerReporter",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObjectsPerReporter",
    "access": null,
    "description": "function to request about specific reporter dataObject registered in domain registry, and\nreturn the dataObjects from that reporter.",
    "lineNumber": 481,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "reporter",
        "description": "dataObject reporter"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of dataObjects schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of dataObjects resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "discoverDataObject",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverDataObject",
    "access": null,
    "description": "Advanced Search for dataObjects registered in domain registry",
    "lineNumber": 532,
    "deprecated": "Deprecated. Use discoverDataObjectsPerName instead",
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "name of the dataObject"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of dataObject schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of dataObject resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "discoverHyperty",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHyperty",
    "access": null,
    "description": "Advanced Search for Hyperties registered in domain registry",
    "lineNumber": 571,
    "deprecated": "Deprecated. Use discoverHyperties instead",
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "user identifier, either in url or email format"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "(Optional)     types of hyperties schemas"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "resources",
        "description": "(Optional)  types of hyperties resources"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)     domain of the registry to search"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "discoverHypertyPerUser",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHypertyPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the last hyperty instance registered by the user.",
    "lineNumber": 621,
    "deprecated": "Deprecated. Use discoverHyperty instead",
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "discoverHypertiesPerUser",
    "memberof": "src/discovery/Discovery.js~Discovery",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/discovery/Discovery.js~Discovery#discoverHypertiesPerUser",
    "access": null,
    "description": "function to request about users registered in domain registry, and\nreturn the all the hyperties registered by the user",
    "lineNumber": 702,
    "deprecated": "Deprecated. Use discoverHyperty instead",
    "params": [
      {
        "nullable": null,
        "types": [
          "email"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "domain"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "(Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/identity/Crypto.js",
    "content": "/**\n* Class with the cryptographic functions for the authentication protocol\n*\n*/\nclass Crypto {\n\n  constructor() {\n    let _this = this;\n\n  }\n\n  /**\n  * encode a byteArray value in base 64 encode\n  * @param   {byteArray}    value    byteArray value\n  * @return  {string}   encoded value\n  */\n  encode(value) {\n    return btoa(value);\n  }\n\n  /**\n  * decode a base64 value in a new Uint8Array\n  * @param   {string}    value    value encoded in base 64\n  * @return  {byteArray} decodedValue\n  */\n  decode(value) {\n    return new Uint8Array(JSON.parse('[' + atob(value) + ']'));\n  }\n\n  encryptRSA(pubKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAencryptKey(new Uint8Array(pubKey)).then(function(publicKey) {\n\n        crypto.subtle.encrypt(\n            {\n              name: 'RSA-OAEP'\n            },\n            publicKey, //from generateKey or importKey above\n            data //ArrayBuffer of data you want to encrypt\n        )\n        .then(function(encrypted) {\n          //returns an ArrayBuffer containing the encrypted data\n          //console.log('crypto-encryptRSA', new Uint8Array(encrypted));\n          resolve(new Uint8Array(encrypted));\n\n        }).catch(function(err) {\n          console.log('crypto-encryptRSA', err);\n          reject(err);\n        });\n\n      });\n\n    });\n\n  }\n\n  decryptRSA(privKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAdecryptKey(privKey).then(function(privateKey) {\n\n        crypto.subtle.decrypt(\n            {\n              name: 'RSA-OAEP'\n            },\n            privateKey, //from generateKey or importKey above\n            data //ArrayBuffer of the data\n        )\n        .then(function(decrypted) {\n\n          let decryptedData = new Uint8Array(decrypted);\n\n          //console.log('crypto-decryptRSA', decryptedData);\n          resolve(decryptedData);\n\n        }).catch(function(err) {\n          console.log('crypto-decryptRSA', err);\n          reject(err);\n        });\n      });\n\n    });\n  }\n\n  signRSA(privKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAsignKey(privKey).then(function(privateKey) {\n\n        crypto.subtle.sign(\n            {\n              name: 'RSASSA-PKCS1-v1_5'\n            },\n            privateKey, //from generateKey or importKey above\n            _this._utf8Encode(data) //ArrayBuffer of data you want to sign\n        )\n        .then(function(signature) {\n          //returns an ArrayBuffer containing the signature\n          //console.log('crypto-signRSA', new Uint8Array(signature));\n          resolve(new Uint8Array(signature));\n\n        }).catch(function(err) {\n          console.log('crypto-signRSA', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  verifyRSA(pubKey, data, signature) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importRSAverifyKey(pubKey).then(function(publicKey) {\n\n        crypto.subtle.verify(\n            {\n              name: 'RSASSA-PKCS1-v1_5'\n            },\n            publicKey, //from generateKey or importKey above\n            signature, //ArrayBuffer of the signature\n            _this._utf8Encode(data) //ArrayBuffer of the data\n        )\n        .then(function(isvalid) {\n          //returns a boolean on whether the signature is true or not\n          //console.log('crypto-verifyRSA', isvalid);\n          resolve(isvalid);\n\n        }).catch(function(err) {\n          console.log('crypto-verifyRSA', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  encryptAES(key, data, iv) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importAESkey(key).then(function(aesKey) {\n\n        crypto.subtle.encrypt(\n            {\n              name: 'AES-CBC',\n              //Don't re-use initialization vectors!\n              //Always generate a new iv every time your encrypt!\n              iv: iv\n            },\n            aesKey, //from generateKey or importKey above\n            _this._utf8Encode(data) //ArrayBuffer of data you want to encrypt\n        )\n        .then(function(encrypted) {\n          //returns an ArrayBuffer containing the encrypted data\n          //console.log('crypto-encryptAES', new Uint8Array(encrypted));\n          resolve(new Uint8Array(encrypted));\n\n        }).catch(function(err) {\n          console.log('crypto-encryptAES', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  decryptAES(key, data, iv) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      _this._importAESkey(key).then(function(aesKey) {\n\n        crypto.subtle.decrypt(\n            {\n              name: 'AES-CBC',\n              iv: iv\n            },\n            aesKey, //from generateKey or importKey above\n            data //ArrayBuffer of the data\n        )\n        .then(function(decrypted) {\n\n          let decodedData = _this._utf8Decode(new Uint8Array(decrypted));\n          //console.log('crypto-decryptAES', decodedData);\n          resolve(decodedData);\n\n        }).catch(function(err) {\n          console.log('crypto-decryptAES', err);\n          reject(err);\n        });\n\n      });\n\n    });\n  }\n\n  /**\n  * creates a hash using the HMAC algorithm\n  * @param  {byteArray}    key       key to be used in the hmac\n  * @param  {string}      data       information to be hashed\n  * @return  {byteArray}   signature  resulting hash\n  */\n  hashHMAC(key, data) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      _this._importHMACkey(key).then(function(hmacKey) {\n\n        crypto.subtle.sign(\n        {\n          name: 'HMAC'\n        },\n        hmacKey, //from generateKey or importKey above\n        _this._utf8Encode(data) //ArrayBuffer of data you want to sign\n        )\n        .then(function(signature) {\n          //console.log('crypto-hashHMAC', signature);\n\n          //returns an ArrayBuffer containing the signature\n          resolve(new Uint8Array(signature));\n\n        }).catch(function(err) {\n          console.log('crypto-hashHMAC', err);\n          reject(err);\n        });\n      });\n    });\n  }\n\n  /**\n  * verifies an hash using the HMAC algorithm\n  * @param  {byteArray}    key       key to be used in the hmac\n  * @param  {string}      data       information to be hashed to compare\n  * @param  {byteArray}  signature   hash to compare with the received data\n  * @return  {boolean}   isvalid     boolean saying if the data corresponds to the hash received\n  */\n  verifyHMAC(key, data, signature) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n\n      _this._importHMACkey(key).then(function(hmacKey) {\n\n        crypto.subtle.verify(\n          {\n            name: 'HMAC'\n          },\n          hmacKey, //from generateKey or importKey above\n          signature, //ArrayBuffer of the signature\n          _this._utf8Encode(data) //ArrayBuffer of the data\n        )\n        .then(function(isvalid) {\n          //returns a boolean on whether the signature is true or not\n          //console.log('crypto-verifyHMAC', isvalid);\n          (isvalid) ? resolve(isvalid) : reject(isvalid);\n\n        }).catch(function(err) {\n          console.error('crypto-verifyHMAC', err);\n          reject(err);\n        });\n\n      });\n    });\n  }\n\n  /**\n  * generates a RSA public/private key pair with a modulus length of 2048 bits\n  * @return  {JSON}   keyPair    json containing the public and private keys\n  */\n  generateRSAKeyPair() {\n    let _this = this;\n    let keyPair = {};\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.generateKey(\n      {\n        name: 'RSA-PSS',\n        modulusLength: 2048, //can be 1024, 2048, or 4096\n        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n      },\n      true, //whether the key is extractable (i.e. can be used in exportKey)\n      ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\n\n      ).then(function(key) {\n        //returns a keypair object\n        //console.log(key);\n\n        crypto.subtle.exportKey(\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          key.publicKey //can be a publicKey or privateKey, as long as extractable was true\n        ).then(function(publicKey) {\n          //returns the exported key data\n          keyPair.public  = new Uint8Array(publicKey);\n          return crypto.subtle.exportKey(\n            'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n            key.privateKey //can be a publicKey or privateKey, as long as extractable was true\n          );\n        }).then(function(privateKey) {\n          keyPair.private  = new Uint8Array(privateKey);\n          //console.log('crypto-generateRSAKeyPair', keyPair);\n\n          resolve(keyPair);\n\n        }).catch(function(err) {\n          console.error(err);\n          reject(err);\n        });\n\n      }).catch(function(err) {\n        console.error(err);\n        reject(err);\n      });\n    });\n  }\n\n  /**\n  * Generates a 128 bit random value.\n  * @return {byteArray}  array    random value\n  */\n  generateIV() {\n    let _this = this;\n\n    let array = new  Uint8Array(16);\n    crypto.getRandomValues(array);\n\n    return array;\n  }\n\n  /**\n  * Generates a 256 bit random value. 32 bits are extrated from the machine time,\n  * the remaining are generated randomly\n  * @return {byteArray}  array    random value\n  */\n  generateRandom() {\n    let _this = this;\n\n    let array = new  Uint8Array(32);\n    crypto.getRandomValues(array);\n\n    let date = Date.now();\n    let dateEncoded = _this._utf8Encode(date);\n\n    //extract the least significant 4 bytes in the date\n    let finalDate = dateEncoded.slice(dateEncoded.length - 4, dateEncoded.length);\n\n    // add in the first 4 bytes of the array the bytes extracted previously;\n    for (let i = 0; i < 4; i++) { array[i] = finalDate[i]; }\n    return array;\n  }\n\n  /**\n  * generates a premaster secret (PMS) of 48 bytes (384 bits) randomly\n  * @return {byteArray}  array    premaster secret key\n  */\n  generatePMS() {\n    let _this = this;\n\n    let array = new Uint8Array(48);\n    crypto.getRandomValues(array);\n    return array;\n  }\n\n  /**\n  * generates a masterKey secret (PMS) of 48 bytes (384 bits) using the premaster secret and\n  * two randoms\n  * @return {byteArray}  array    master secret key with 48 bytes\n  */\n  generateMasterSecret(hmacKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      let key = new Uint8Array(48);\n      let seed = data;\n\n      _this._digest(hmacKey).then((digestedKey) => {\n\n        _this.hashHMAC(digestedKey, seed).then(function(keypart0) {\n\n          //copy the first 32 bytes into the key\n          for (let i = 0; i < 32; i++) { key[i] = keypart0[i]; }\n          return _this.hashHMAC(digestedKey, seed + keypart0);\n\n        }).then(function(keypart1) {\n\n          //copy the first 16 bytes to the key remaining 16 bytes\n          for (let i = 0; i < 16; i++) { key[i + 32] = keypart1[i]; }\n          //console.log('crypto-generateMasterSecret', key);\n          resolve(key);\n\n        }).catch(function(err) {\n          console.log('crypto-generateMasterSecret', err);\n          reject(err);\n        });\n      });\n\n    });\n  }\n\n  /**\n  * generates both users MAC and encryption keys. generate as output an array\n  * with 4 byteArray each with 32 bytes\n  * @param  {byteArray}        secret       secret to be used in the HMAC function\n  * @param  {String}           data         information to be used as seed\n  * @return {Array<byteArray>} key          array with the information to generate keys\n  */\n  generateKeys(hmacKey, data) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      let key = [];\n      let seed = data;\n\n      // iterate 4 times to obtain a 1024 key size\n      _this.hashHMAC(hmacKey, seed).then(function(keypart0) {\n        key.push(keypart0);\n        return _this.hashHMAC(hmacKey, seed + keypart0);\n\n      }).then(function(keypart1) {\n        key.push(keypart1);\n        return _this.hashHMAC(hmacKey, seed + keypart1);\n\n      }).then(function(keypart2) {\n        key.push(keypart2);\n        return _this.hashHMAC(hmacKey, seed + keypart2);\n\n      }).then(function(keypart3) {\n        key.push(keypart3);\n\n        //console.log('crypto-generateKeys', key);\n        resolve(key);\n\n      }).catch(function(err) {\n        //console.log('crypto-generateKeys', err);\n        reject(err);\n      });\n\n      //console.log(hmacKey, data);\n    });\n  }\n\n  _importRSAsignKey(privKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          privKey,\n          {   //these are the algorithm options\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['sign'] //'verify' for public key import, 'sign' for private key imports\n      )\n      .then(function(privateKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAsignKey', privateKey);\n        resolve(privateKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAsignKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _importRSAverifyKey(pubKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          pubKey,\n          {   //these are the algorithm options\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['verify'] //'verify' for public key import, 'sign' for private key imports\n      )\n      .then(function(publicKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAverifyKey', publicKey);\n        resolve(publicKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAverifyKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _importRSAencryptKey(pubKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'spki', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          pubKey,\n          {   //these are the algorithm options\n            name: 'RSA-OAEP',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['encrypt'] //'encrypt' or 'wrapKey' for public key import or\n                      //'decrypt' or 'unwrapKey' for private key imports\n      )\n      .then(function(publicKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAencryptKey', publicKey);\n        resolve(publicKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAencryptKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _importRSAdecryptKey(privKey) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'pkcs8', //can be 'jwk' (public or private), 'spki' (public only), or 'pkcs8' (private only)\n          privKey,\n          {   //these are the algorithm options\n            name: 'RSA-OAEP',\n            hash: {name: 'SHA-256'} //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['decrypt'] //'encrypt' or 'wrapKey' for public key import or\n                      //'decrypt' or 'unwrapKey' for private key imports\n      )\n      .then(function(privateKey) {\n        //returns a publicKey (or privateKey if you are importing a private key)\n        //console.log('crypto-_importRSAdecryptKey', privateKey);\n        resolve(privateKey);\n\n      }).catch(function(err) {\n        console.error('crypto-_importRSAdecryptKey', err);\n        reject(err);\n      });\n    });\n  }\n\n  concatPMSwithRandoms(pms, toRandom, fromRandom) {\n    let _this = this;\n\n    let finalKey = new Uint8Array(pms.length + toRandom.length + fromRandom.length);\n\n    // add PremasterKey\n    for (let i = 0; i < pms.length; i++) {\n      finalKey[i] = pms[i];\n    }\n\n    //add to random\n    for (let i = 0; i < toRandom.length; i++) {\n      finalKey[i + pms.length] = pms[i];\n    }\n\n    //add from random\n    for (let i = 0; i < fromRandom.length; i++) {\n      finalKey[i + pms.length + toRandom.length] = pms[i];\n    }\n\n    return finalKey;\n  }\n\n  _generate256bitKey() {\n    let array = new  Uint8Array(32);\n    crypto.getRandomValues(array);\n\n    return array;\n  }\n\n  /**\n  * imports the secret to the HMAC function\n  * @param  {byteArray}   arrayBuffer     bytes to import as key\n  * @return {JSON}       key              key ready to be used in the HMAC cryptographic function\n  */\n  _importHMACkey(arrayBuffer) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      _this._digest(arrayBuffer).then((key) => {\n\n        crypto.subtle.importKey(\n        'raw', //can be 'jwk' or 'raw'\n        key,\n        {   //this is the algorithm options\n          name: 'HMAC',\n          hash: {name: 'SHA-256'}, //can be 'SHA-1', 'SHA-256', 'SHA-384', or 'SHA-512'\n          length: 256 //optional, if you want your key length to differ from the hash function's block length\n        },\n        true, //whether the key is extractable (i.e. can be used in exportKey)\n        ['sign', 'verify'] //can be any combination of 'sign' and 'verify'\n        ).then(function(key) {\n          //returns the symmetric key\n          //console.log('crypto-_importHMACkey', key);\n          resolve(key);\n        })\n        .catch(function(err) {\n          reject(err);\n        });\n      });\n    });\n  }\n\n  _digest(value) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.digest(\n          {\n            name: 'SHA-256'\n          },\n          value //The data you want to hash as an ArrayBuffer\n      )\n      .then(function(hash) {\n        //returns the hash as an ArrayBuffer\n        //console.log('crypto-digest', new Uint8Array(hash));\n        resolve(new Uint8Array(hash));\n      })\n      .catch(function(err) {\n        console.error(err);\n        reject(err);\n      });\n\n    });\n  }\n\n  _importAESkey(arrayBuffer) {\n    return new Promise(function(resolve, reject) {\n      crypto.subtle.importKey(\n          'raw', //can be 'jwk' or 'raw'\n          arrayBuffer,\n          {   //this is the algorithm options\n            name: 'AES-CBC'\n          },\n          true, //whether the key is extractable (i.e. can be used in exportKey)\n          ['encrypt', 'decrypt'] //can be 'encrypt', 'decrypt', 'wrapKey', or 'unwrapKey'\n      )\n      .then(function(key) {\n        //returns the symmetric key\n        //console.log('crypto-importAESkey', key);\n        resolve(key);\n      })\n      .catch(function(err) {\n        console.error('crypto-importAESkey', err);\n        reject(err);\n      });\n    });\n  }\n\n  _utf8Encode(s) {\n    return new TextEncoder('utf-8').encode(s);\n  }\n\n  _utf8Decode(s) {\n    return new TextDecoder('utf-8').decode(s);\n  }\n}\n\nexport default Crypto;\n",
    "static": true,
    "longname": "src/identity/Crypto.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "class",
    "name": "Crypto",
    "memberof": "src/identity/Crypto.js",
    "static": true,
    "longname": "src/identity/Crypto.js~Crypto",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/identity/Crypto.js",
    "importStyle": "Crypto",
    "description": "Class with the cryptographic functions for the authentication protocol",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 77,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "encode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#encode",
    "access": null,
    "description": "encode a byteArray value in base 64 encode",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "byteArray value"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "encoded value"
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "decode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#decode",
    "access": null,
    "description": "decode a base64 value in a new Uint8Array",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "value encoded in base 64"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "decodedValue"
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "encryptRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#encryptRSA",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "decryptRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#decryptRSA",
    "access": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "signRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#signRSA",
    "access": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "verifyRSA",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#verifyRSA",
    "access": null,
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "signature",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "encryptAES",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#encryptAES",
    "access": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "iv",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "decryptAES",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#decryptAES",
    "access": null,
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "iv",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "hashHMAC",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#hashHMAC",
    "access": null,
    "description": "creates a hash using the HMAC algorithm",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to be used in the hmac"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "information to be hashed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "signature  resulting hash"
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "verifyHMAC",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#verifyHMAC",
    "access": null,
    "description": "verifies an hash using the HMAC algorithm",
    "lineNumber": 247,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "key to be used in the hmac"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "information to be hashed to compare"
      },
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": "hash to compare with the received data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "isvalid     boolean saying if the data corresponds to the hash received"
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "generateRSAKeyPair",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateRSAKeyPair",
    "access": null,
    "description": "generates a RSA public/private key pair with a modulus length of 2048 bits",
    "lineNumber": 280,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "keyPair    json containing the public and private keys"
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "generateIV",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateIV",
    "access": null,
    "description": "Generates a 128 bit random value.",
    "lineNumber": 331,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    random value"
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "generateRandom",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateRandom",
    "access": null,
    "description": "Generates a 256 bit random value. 32 bits are extrated from the machine time,\nthe remaining are generated randomly",
    "lineNumber": 345,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    random value"
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "generatePMS",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generatePMS",
    "access": null,
    "description": "generates a premaster secret (PMS) of 48 bytes (384 bits) randomly",
    "lineNumber": 366,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    premaster secret key"
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "generateMasterSecret",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateMasterSecret",
    "access": null,
    "description": "generates a masterKey secret (PMS) of 48 bytes (384 bits) using the premaster secret and\ntwo randoms",
    "lineNumber": 379,
    "params": [
      {
        "name": "hmacKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "byteArray"
      ],
      "spread": false,
      "description": "array    master secret key with 48 bytes"
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "generateKeys",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#generateKeys",
    "access": null,
    "description": "generates both users MAC and encryption keys. generate as output an array\nwith 4 byteArray each with 32 bytes",
    "lineNumber": 417,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "secret",
        "description": "secret to be used in the HMAC function"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "information to be used as seed"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<byteArray>"
      ],
      "spread": false,
      "description": "key          array with the information to generate keys"
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "_importRSAsignKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAsignKey",
    "access": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "_importRSAverifyKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAverifyKey",
    "access": null,
    "description": null,
    "lineNumber": 479,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "_importRSAencryptKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAencryptKey",
    "access": null,
    "description": null,
    "lineNumber": 505,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pubKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "_importRSAdecryptKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importRSAdecryptKey",
    "access": null,
    "description": null,
    "lineNumber": 532,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "privKey",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "concatPMSwithRandoms",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#concatPMSwithRandoms",
    "access": null,
    "description": null,
    "lineNumber": 559,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "pms",
        "types": [
          "*"
        ]
      },
      {
        "name": "toRandom",
        "types": [
          "*"
        ]
      },
      {
        "name": "fromRandom",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "_generate256bitKey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_generate256bitKey",
    "access": null,
    "description": null,
    "lineNumber": 582,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "_importHMACkey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importHMACkey",
    "access": null,
    "description": "imports the secret to the HMAC function",
    "lineNumber": 594,
    "params": [
      {
        "nullable": null,
        "types": [
          "byteArray"
        ],
        "spread": false,
        "optional": false,
        "name": "arrayBuffer",
        "description": "bytes to import as key"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "key              key ready to be used in the HMAC cryptographic function"
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "_digest",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_digest",
    "access": null,
    "description": null,
    "lineNumber": 623,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "_importAESkey",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_importAESkey",
    "access": null,
    "description": null,
    "lineNumber": 646,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "arrayBuffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "_utf8Encode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_utf8Encode",
    "access": null,
    "description": null,
    "lineNumber": 669,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "s",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "_utf8Decode",
    "memberof": "src/identity/Crypto.js~Crypto",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Crypto.js~Crypto#_utf8Decode",
    "access": null,
    "description": null,
    "lineNumber": 673,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "s",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "src/identity/GuiFake.js",
    "content": "/**\n* fake class for the gui to select the identity,\n* TODO replace with the proper identity GUI\n*\n*/\nclass GuiFake {\n\n  constructor(url, messageBus) {\n    let _this = this;\n\n    _this._url = url;\n    _this._waitTime = 10000;\n    _this._messageBus = messageBus;\n\n    _this._messageBus.addListener(_this._url, msg => {\n\n      if (msg.hasOwnProperty('type') &&\n          msg.type === 'create' &&\n          msg.body.hasOwnProperty('value') &&\n          msg.body.value.hasOwnProperty('identities') &&\n          msg.body.value.hasOwnProperty('idps')) {\n\n        let identities = msg.body.value.identities;\n        let idps = msg.body.value.idps;\n\n        let value;\n\n        if (identities[0] !== undefined) {\n          value = {type: 'identity', value: identities[0], code: 200};\n        } else {\n          value = {type: 'idp', value: idps[0].domain, code: 200};\n        }\n\n        let replyMsg = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value};\n\n        // to test on the identity side the listener without the timeout\n        // can represent the time the user takes to choose and identity\n        if (msg.body.value === 'wait') {\n\n          setTimeout(() => {\n            _this._messageBus.postMessage(replyMsg);\n          }, _this._waitTime);\n        } else {\n          _this._messageBus.postMessage(replyMsg);\n        }\n      } else {\n        console.log('Ignoring messages not intended to FakeGUI.', msg );\n      }\n    });\n  }\n\n}\n\nexport default GuiFake;\n",
    "static": true,
    "longname": "src/identity/GuiFake.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "GuiFake",
    "memberof": "src/identity/GuiFake.js",
    "static": true,
    "longname": "src/identity/GuiFake.js~GuiFake",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/identity/GuiFake.js",
    "importStyle": "GuiFake",
    "description": "fake class for the gui to select the identity,\nTODO replace with the proper identity GUI",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/GuiFake.js~GuiFake",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/GuiFake.js~GuiFake#constructor",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "messageBus",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "file",
    "name": "src/identity/Identity.js",
    "content": "/**\n* The Identity Data Model is used to model the reTHINK User entity. The Identity data model is handled by Identity Management functionality.\n*\n*/\nclass Identity {\n\n  constructor(guid, type) {\n    let _this = this;\n\n    _this.guid = guid;\n    _this.type = type;\n    _this.identifiersList = {};\n\n  }\n\n  addIdentity(identifier) {\n    let _this = this;\n    let identityInformation = {\n      idAssertion: '',\n      serviceAddress: '',\n      authenticationData: '',\n      authorisationData: '',\n      userProfile: ''\n    };\n    _this.identifiersList[identifier] = identityInformation;\n  }\n\n  addIdAssertion(identifier, assertion, idp, scope) {\n    let _this = this;\n\n    let newIdAssertion = new IdAssertion(assertion, idp, scope);\n\n    _this.idAssertionList.push(newIdAssertion);\n  }\n}\n\nclass IdAssertion {\n\n  constructor(assertion, idp, scope) {\n    let _this = this;\n\n    _this.assertion = assertion;\n    _this.idp = idp;\n    _this.scope = scope;\n  }\n\n}\n\nclass IdValidation {\n\n  constructor(identity, contents) {\n    let _this = this;\n    _this.identity = identity;\n    _this.contents = contents;\n  }\n\n  validates(identity, contents) {\n    //TODO implement the logic\n\n  }\n}\n\nexport default Identity;\n",
    "static": true,
    "longname": "src/identity/Identity.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 109,
    "kind": "class",
    "name": "IdAssertion",
    "memberof": "src/identity/Identity.js",
    "static": true,
    "longname": "src/identity/Identity.js~IdAssertion",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/identity/Identity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 110,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Identity.js~IdAssertion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~IdAssertion#constructor",
    "access": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "assertion",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 111,
    "kind": "class",
    "name": "IdValidation",
    "memberof": "src/identity/Identity.js",
    "static": true,
    "longname": "src/identity/Identity.js~IdValidation",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/identity/Identity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 112,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Identity.js~IdValidation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~IdValidation#constructor",
    "access": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identity",
        "types": [
          "*"
        ]
      },
      {
        "name": "contents",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "validates",
    "memberof": "src/identity/Identity.js~IdValidation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~IdValidation#validates",
    "access": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identity",
        "types": [
          "*"
        ]
      },
      {
        "name": "contents",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 114,
    "kind": "class",
    "name": "Identity",
    "memberof": "src/identity/Identity.js",
    "static": true,
    "longname": "src/identity/Identity.js~Identity",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/identity/Identity.js",
    "importStyle": "Identity",
    "description": "The Identity Data Model is used to model the reTHINK User entity. The Identity data model is handled by Identity Management functionality.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 115,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/Identity.js~Identity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~Identity#constructor",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "guid",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "addIdentity",
    "memberof": "src/identity/Identity.js~Identity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~Identity#addIdentity",
    "access": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "addIdAssertion",
    "memberof": "src/identity/Identity.js~Identity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/Identity.js~Identity#addIdAssertion",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identifier",
        "types": [
          "*"
        ]
      },
      {
        "name": "assertion",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "scope",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 118,
    "kind": "file",
    "name": "src/identity/IdentityModule.js",
    "content": "\nimport {divideURL, getUserURLFromEmail, getUserEmailFromURL, isDataObjectURL, convertToUserURL, getUserIdentityDomain, isLegacy } from '../utils/utils.js';\nimport Identity from './Identity';\nimport Crypto from './Crypto';\nimport GuiFake from './GuiFake';\nimport { WatchingYou } from 'service-framework/dist/Utils';\n\n/**\n*\n* The Identity Module (Id Module) is the component responsible for handling the\n* user identity and the association of this identity with the Hyperty instances,\n* in order to make Hyperty instances identifiable. The identity in the reTHINK project\n* is not fixed to a unique Identity Service Provider, but obtained through several\n* different Identity sources. With this approach, the Id Module provides to the user the\n* option to choose the preferred method for authentication.\n* This module will thus able to support multiple Identity acquisition methods,\n* such as OpenID connect 1.0, Kerberos System, or authentication through smart cards.\n* For example, a user with a Google account can use the Google as an Identity Provider to provide Identity Tokens,\n*  which can be used by the Identity Module to associate it with a Hyperty instance.\n*\n* The Identity Module uses a node package, the HelloJS, which is a client-side JavaScript API for authentication\n* that facilitates the requests for the OpenID connect protocol. This method allows for some abstraction\n* when making requests for different Identity Providers, such as OpenID connect used by Google, Facebook, Microsoft, for example.\n*\n* When a request for a user identity is made using the method loginWithRP(identifier, scope),\n* this method will analyse the Identity Provider chosen to obtain an identity and will use the HelloJS node package\n* with the selected Identity Provider and identity scope. After the HelloJS request for an Access Token\n* to the Identity Providers, the user will be prompted to authenticate towards the Identity Provider.\n* Upon receiving the Access Token, this token is validated with a RESTful web service request to an endpoint\n* on the Identity Provider Authorization Server, and after the validation is done,\n* an ID token is obtained with the information according to the scope required.\n* This ID token is then preserved in this module that can obtained through the getIdentities()\n* and is passed as return value of the loginWithRP function. The methods generateAssertion and validateAssertion have not yet been developed.\n*\n*/\nclass IdentityModule {\n\n  /**\n  * This is the constructor to initialise the Identity Module it does not require any input.\n  */\n  constructor(runtimeURL, runtimeCapabilities, storageManager, dataObjectsStorage) {\n    let _this = this;\n\n    if (!runtimeURL) throw new Error('runtimeURL is missing.');\n    if (!storageManager) throw new Error('storageManager is missing');\n\n    _this._runtimeURL = runtimeURL;\n    _this.storageManager = storageManager;\n    _this.dataObjectsStorage = dataObjectsStorage;\n    _this._idmURL = _this._runtimeURL + '/idm';\n    _this._guiURL = _this._runtimeURL + '/identity-gui';\n    _this.runtimeCapabilities = runtimeCapabilities;\n\n    _this._domain = divideURL(_this._runtimeURL).domain;\n\n    _this.watchingYou = new WatchingYou();\n\n    //to store items with this format: {identity: identityURL, token: tokenID}\n    _this.identities = [];\n    _this.identitiesList =  _this.watchingYou.watch('identitiesList', {}, true);\n    _this.emailsList = [];\n    let newIdentity = new Identity('guid', 'HUMAN');\n    _this.identity = newIdentity;\n    _this.crypto = new Crypto();\n    _this.currentIdentity;\n\n    //stores the association of the dataObject and the Hyperty registered within\n    _this.dataObjectsIdentity = {};\n\n    // hashTable to store all the crypto information between two hyperties\n    _this.chatKeys = {};\n\n    // hashTable to store the symmetric keys to be used in the chat group\n    _this.dataObjectSessionKeys = {};\n\n    //failsafe to enable/disable all the criptographic functions\n    _this.isToUseEncryption = true;\n\n    // variable to know if the GUI is deployed to choose the identity. if the real GUI is not deployed, a fake gui is deployed instead.\n    _this.guiDeployed = false;\n\n    // verification of nodeJS, and in case it is nodeJS then disable encryption\n    // TODO improve later, this exists because the crypto lib uses browser cryptographic methods\n    //_this.isToUseEncryption = (window) ? true : false;\n\n    _this._loadIdentities();\n\n  }\n\n  callIdentityModuleFunc(methodName, parameters) {\n    let _this = this;\n    let message;\n\n    return new Promise((resolve, reject) => {\n      message = { type: 'execute', to: _this._guiURL, from: _this._idmURL,\n        body: { resource: 'identity', method: methodName, params: parameters }, };\n      let id = _this._messageBus.postMessage(message);\n\n      //add listener without timout\n      _this._messageBus.addResponseListener(_this._idmURL, id, msg => {\n        _this._messageBus.removeResponseListener(_this._idmURL, id);\n\n        let result = msg.body.value;\n        resolve(result);\n      });\n    });\n  }\n\n  /**\n  * return the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n  get messageBus() {\n    let _this = this;\n    return _this._messageBus;\n  }\n\n  /**\n  * Set the messageBus in this Registry\n  * @param {MessageBus}           messageBus\n  */\n  set messageBus(messageBus) {\n    let _this = this;\n    _this._messageBus = messageBus;\n    _this.addGUIListeners();\n  }\n\n  addGUIListeners() {\n    let _this = this;\n\n    _this._messageBus.addListener(_this._idmURL, (msg) => {\n      let funcName = msg.body.method;\n\n      let returnedValue;\n      if (funcName === 'deployGUI') {\n        returnedValue = _this.deployGUI();\n      } else if (funcName === 'getIdentitiesToChoose') {\n        returnedValue = _this.getIdentitiesToChoose();\n      } else if (funcName === 'unregisterIdentity') {\n        let email = msg.body.params.email;\n        returnedValue = _this.unregisterIdentity(email);\n      } else if (funcName === 'generateRSAKeyPair') {\n        // because generateRSAKeyPair is a promise\n        // we have to send the message only after getting the key pair\n        _this.crypto.generateRSAKeyPair().then((keyPair) => {\n          let value = {type: 'execute', value: keyPair, code: 200};\n          let replyMsg = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value};\n          _this._messageBus.postMessage(replyMsg);\n        });\n        return;\n      } else if (funcName === 'sendGenerateMessage') {\n        let contents = msg.body.params.contents;\n        let origin = msg.body.params.origin;\n        let usernameHint = msg.body.params.usernameHint;\n        let ipDomain = msg.body.params.ipDomain;\n        _this.sendGenerateMessage(contents, origin, usernameHint, ipDomain).then((returnedValue) => {\n          let value = {type: 'execute', value: returnedValue, code: 200};\n          let replyMsg = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value};\n          _this._messageBus.postMessage(replyMsg);\n        });\n        return;\n      } else if (funcName === 'storeIdentity') {\n        let result = msg.body.params.result;\n        let keyPair = msg.body.params.keyPair;\n        _this.storeIdentity(result, keyPair).then((returnedValue) => {\n          let value = {type: 'execute', value: returnedValue, code: 200};\n          let replyMsg = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value};\n          _this._messageBus.postMessage(replyMsg);\n        });\n        return;\n      } /*else if (funcName === 'selectIdentityForHyperty') {\n        let origin = msg.body.params.origin;\n        let idp = msg.body.params.idp;\n        let idHint = msg.body.params.idHint;\n        _this.selectIdentityForHyperty(origin, idp, idHint);\n        return;\n      }*/\n\n      // if the function requested is not a promise\n      let value = {type: 'execute', value: returnedValue, code: 200};\n      let replyMsg = {id: msg.id, type: 'response', to: msg.from, from: msg.to, body: value};\n      _this._messageBus.postMessage(replyMsg);\n    });\n  }\n\n  /**\n  * return the registry in this idModule\n  * @param {registry}           registry\n  */\n  get registry() {\n    let _this = this;\n    return _this._registry;\n  }\n\n  /**\n  * Set the registry in this idModule\n  * @param {registry}     reg\n  */\n  set registry(registry) {\n    let _this = this;\n    _this._registry = registry;\n  }\n\n  /**\n  * Function to return all the identities registered within a session by a user.\n  * These identities are returned in an array containing a JSON package for each user identity.\n  * @return {Array<Identities>}         Identities\n  */\n  getIdentities() {\n    let _this = this;\n    return _this.identities;\n  }\n\n  /**\n  * gets all the information from a given userURL\n  * @param  {String}  userURL     user url\n  * @return {JSON}    identity    identity bundle from the userURL\n  */\n  getIdentity(userURL) {\n    let _this = this;\n\n    for (let index in _this.identities) {\n\n      let identity = _this.identities[index];\n      if (identity.identity === userURL) {\n        return identity;\n      }\n    }\n\n    throw 'identity not found';\n  }\n\n  _seconds_since_epoch() {\n    return Math.floor( Date.now() / 1000 );\n  }\n\n  _loadIdentities() {\n    let _this = this;\n    return new Promise((resolve) => {\n\n      _this.storageManager.get('idModule:identities').then((identities) => {\n\n        if (identities) {\n          _this.identities = identities;\n\n          identities.forEach((identity) => {\n            let timeNow = _this._seconds_since_epoch();\n            let expires = 0;\n\n            if (identity.info && identity.info.expires ) {\n              expires = identity.info.expires;\n            }  else if (identity.info && identity.info.tokenIDJSON && identity.info.tokenIDJSON.exp)\n              expires = identity.info.tokenIDJSON.exp;\n\n            if (expires > timeNow) {\n              _this.currentIdentity = identity.messageInfo;\n              _this.currentIdentity.expires = expires;\n            }\n\n          });\n        }\n\n\n        resolve();\n      });\n    });\n  }\n\n  deployGUI() {\n    let _this = this;\n    _this.guiDeployed = true;\n  }\n\n  /**\n   * GetValidToken is for non legacy hyperties and verifies if the Token is still valid\n   * if the token is invalid it requests a new token\n   * @param  {String} hypertyURL hypertyURL\n   * @return {Promise}\n   */\n  _getValidToken(hypertyURL) {\n    let _this = this;\n    return new Promise((resolve, reject) => {\n      _this.getIdToken(hypertyURL).then(function(identity) {\n        console.log('[Identity.IdentityModule.getValidToken] Token', identity);\n        let time_now = _this._seconds_since_epoch();\n        let complete_id = _this.getIdentity(identity.userProfile.userURL);\n        let expiration_date = undefined;\n\n        if (complete_id.hasOwnProperty('info')) {\n          if (complete_id.info.hasOwnProperty('expires')) {\n            expiration_date = complete_id.info.expires;\n          } else if (complete_id.info.hasOwnProperty('tokenIDJSON')) {\n            expiration_date = complete_id.info.tokenIDJSON.exp;\n          } else {\n            // throw 'The ID Token does not have an expiration time';\n            console.log('The ID Token does not have an expiration time');\n          }\n        } else {\n          // throw 'The ID Token does not have an expiration time';\n          console.log('The ID Token does not have an expiration time')\n        }\n\n        console.log('[Identity.IdentityModule.getValidToken] Token expires in', expiration_date);\n        console.log('[Identity.IdentityModule.getValidToken] time now:', time_now);\n\n        // TODO: this should not be verified in this way\n        // we should contact the IDP to verify this instead of using the local clock\n        // but this works for now...\n        if (time_now >= expiration_date) {\n          // delete current identity\n          _this.deleteIdentity(complete_id.identity);\n\n          // generate new idToken\n          _this.callGenerateMethods(identity.idp).then((value) => {\n            resolve(value.messageInfo);\n          });\n        } else {\n          resolve(identity);\n        }\n        resolve(identity);\n      }).catch(function(error) {\n        console.error('[Identity.IdentityModule.getToken] error on getToken', error);\n        reject(error);\n      });\n    });\n  }\n\n  /**\n  * get a Token to be added to a message\n  * @param  {String}  fromURL     origin of the message\n  * @param  {String}  toURL     target of the message\n  * @return {JSON}    token    token to be added to the message\n  */\n  getToken(fromURL, toUrl) {\n    let _this = this;\n    return new Promise(function(resolve, reject) {\n      console.log('[Identity.IdentityModule.getToken] from->', fromURL, '  to->', toUrl);\n\n      if (toUrl) {\n//        console.log('toUrl', toUrl);\n        _this.registry.isLegacy(toUrl).then(function(result) {\n          console.log('[Identity.IdentityModule.getToken] isLEGACY: ', result);\n          if (result) {\n\n            // TODO: check if in the future other legacy hyperties have expiration times\n            // if so the check should be made here (or in the getAccessToken function)\n            let token = _this.getAccessToken(toUrl);\n            if (token)              { return resolve(token); }\n\n            let domain = getUserIdentityDomain(toUrl);\n\n            // check if process to get token has already started\n            if (_this.identitiesList[domain] && _this.identitiesList[domain].status === 'in-progress') {\n              // The process to get the token has already started, let's wait by watching its status\n\n              _this.watchingYou.observe('identitiesList', (change) => {\n\n                console.log('[Identity.IdentityModule.getToken]  identitiesList changed ' + _this.identitiesList);\n\n                let keypath = change.keypath;\n\n                if (keypath.includes('status'))\n                  keypath = keypath.replace('.status', '');\n\n                if (keypath === domain && change.name === 'status' && change.newValue === 'created') {\n                  console.log('[Identity.IdentityModule.getToken] token is created ' + _this.identitiesList[domain]);\n                  return resolve(_this.getAccessToken(toUrl));\n                }\n              });\n            } else { //Token does not exist and the process to get has not started yet\n\n              _this.identitiesList[domain] = {\n                status: 'in-progress'\n              };\n\n              console.log('[Identity.IdentityModule.getToken] for-> ', domain);\n              _this.callGenerateMethods(domain).then((value) => {\n                console.log('[Identity.IdentityModule.getToken] CallGeneratemethods', value);\n                let token = _this.getAccessToken(toUrl);\n                if (token) {\n                  return resolve(token);\n                } else {\n                  return reject('No Access token found');\n                }\n              }, (err) => {\n                console.error('[Identity.IdentityModule.getToken] error CallGeneratemethods');\n                return reject(err);\n              });\n            }\n\n          } else {\n            _this._getValidToken(fromURL).then((identity) => {\n              resolve(identity);\n            });\n          }\n        });\n      } else {\n        _this._getValidToken(fromURL).then((identity) => {\n          resolve(identity);\n        });\n      }\n    });\n  }\n\n  /**\n  * get an Id Token for a HypertyURL\n  * @param  {String}  hypertyURL     the Hyperty address\n  * @return {JSON}    token    Id token to be added to the message\n  */\n  getIdToken(hypertyURL) {\n    let _this = this;\n    return new Promise(function(resolve, reject) {\n      let splitURL = hypertyURL.split('://');\n      if (splitURL[0] !== 'hyperty') {\n\n        _this._getHypertyFromDataObject(hypertyURL).then((returnedHypertyURL) => {\n          let userURL = _this.registry.getHypertyOwner(returnedHypertyURL);\n\n          if (userURL) {\n\n            for (let index in _this.identities) {\n              let identity = _this.identities[index];\n              if (identity.identity === userURL) {\n                return resolve(identity.messageInfo);\n              }\n            }\n          } else {\n            return reject('no identity was found ');\n          }\n        }).catch((reason) => {\n          console.error('no identity was found: ', reason);\n          reject(reason);\n        });\n      } else {\n        let userURL = _this.registry.getHypertyOwner(hypertyURL);\n        if (userURL) {\n\n          for (let index in _this.identities) {\n            let identity = _this.identities[index];\n            if (identity.identity === userURL) {\n              // TODO check this getIdToken when we run on nodejs environment;\n              if (identity.hasOwnProperty('messageInfo')) {\n                return resolve(identity.messageInfo);\n              } else {\n                return resolve(identity);\n              }\n            }\n          }\n        } else {\n          return reject('no identity was found.');\n        }\n      }\n    });\n  }\n\n  /**\n  * get an Access Token for a legacyURL\n  * @param  {String}  legacyURL     the legacy address\n  * @return {JSON}    token    Access token to be added to the message\n  */\n\n  getAccessToken(url) {\n    let _this = this;\n\n  /*  let urlSplit = url.split('.');\n    let length = urlSplit.length;*/\n\n    let domainToCheck = divideURL(url).domain;\n\n    if (url.includes('protostub')) {\n      domainToCheck = domainToCheck.replace(domainToCheck.split('.')[0] + '.', '');\n    }\n\n    let identityToReturn;\n    let expiration_date = undefined;\n    let time_now = _this._seconds_since_epoch();\n    for (let index in _this.identities) {\n      let identity = _this.identities[index];\n      if (identity.hasOwnProperty('interworking') && identity.interworking.domain === domainToCheck) {\n        // check if there is expiration time\n        if (identity.hasOwnProperty('info') && identity.info.hasOwnProperty('expirates')) {\n          expiration_date = identity.info.expires;\n          console.log('[Identity.IdentityModule.getAccessToken] Token expires in', expiration_date);\n          console.log('[Identity.IdentityModule.getAccessToken] time now:', time_now);\n\n          // TODO: this should not be verified in this way\n          // we should contact the IDP to verify this instead of using the local clock\n          // but this works for now...\n          if (time_now >= expiration_date) {\n            // delete current identity\n            _this.deleteIdentity(identity.identity);\n            return null; // the getToken function then generates a new token\n          }\n        } // else this access token has no expiration time\n\n        if (identity.hasOwnProperty('messageInfo') && identity.messageInfo.hasOwnProperty('userProfile') && identity.messageInfo.userProfile) {\n          identityToReturn = { userProfile: identity.messageInfo.userProfile, access_token: identity.interworking.access_token };\n          if (identity.hasOwnProperty('infoToken') && identity.infoToken.hasOwnProperty('id')) {\n            identityToReturn.userProfile.id = identity.infoToken.id;\n          }\n        }\n        return identityToReturn;\n      }\n    }\n\n    return null;\n  }\n\n  getIdentitiesToChoose() {\n    let _this = this;\n    let identities = _this.emailsList;\n    let idps = [{domain: 'google.com', type: 'idToken'}, {domain: 'microsoft.com', type: 'idToken'}, {domain: 'orange.fr', type: 'idToken'}, {domain: 'slack.com', type: 'Legacy'}];\n\n    return {identities: identities, idps: idps};\n  }\n\n  /**\n  * Function to return all the users URLs registered within a session\n  * These users URLs are returned in an array of strings.\n  * @param  {Boolean}  emailFormat (Optional)   boolean to indicate to return in email format\n  * @return {Array<String>}         users\n  */\n  getUsersIDs(emailFormat) {\n    let _this = this;\n    let users = [];\n\n    //if request comes with the emailFormat option, then convert url to email format\n    let converter = (emailFormat) ? getUserEmailFromURL : (value) => { return value; };\n\n    for (let index in _this.identities) {\n      let identity = _this.identities[index];\n      users.push(converter(identity.identity));\n    }\n    return users;\n  }\n\n  /**\n  * Function to return the selected Identity within a session\n  * @return {Identity}        identity         identity\n  */\n  getCurrentIdentity() {\n    let _this = this;\n    return _this.currentIdentity;\n  }\n\n  /**\n  * Function to set the current Identity with a given Identity\n  * @param {Identity}        identity         identity\n  */\n  setCurrentIdentity(identity) {\n    let _this = this;\n    _this.currentIdentity = identity;\n  }\n\n  /**\n  * Function to remove an identity from the Identities array\n  * @param {String}    userURL      userURL\n  */\n  deleteIdentity(userURL) {\n    let _this = this;\n\n    //let userURL = convertToUserURL(userID);\n\n    for (let identity in _this.identities) {\n      if (_this.identities[identity].identity === userURL) {\n        console.log('splice', _this.identities.splice(identity, 1));\n      }\n    }\n  }\n\n  /**\n  * Function to unregister an identity from the emailsList array and not show in to the GUI\n  * @param {String}    email      email\n  */\n  unregisterIdentity(email) {\n    let _this = this;\n\n    for (let e in _this.emailsList) {\n      if (_this.emailsList[e] === email) {\n        _this.emailsList.splice(e, 1);\n      }\n    }\n  }\n\n  /**\n  * Function that resolve and create the domainURL in case it is provided one. If not, resolve the default domainURL\n  * @param {String}     idpDomain     idpDomain (Optional)\n  */\n  _resolveDomain(idpDomain) {\n    if (!idpDomain) {\n      return 'domain-idp://google.com';\n    } else {\n      return 'domain-idp://' + idpDomain;\n    }\n  }\n\n  /**\n  * Function that sends a request to the GUI using messages. Sends all identities registered and\n  * the Idps supported, and return the identity/idp received by the GUI\n  * @param {Array<identity>}  identities      list of identitiies\n  * @param {Array<String>}    idps            list of idps to authenticate\n  * @return {Promise}         returns a chosen identity or idp\n  */\n  requestIdentityToGUI(identities, idps) {\n    let _this = this;\n    return new Promise(function(resolve, reject) {\n\n      //condition to check if the real GUI is deployed. If not, deploys a fake gui\n      if (_this.guiDeployed === false) {\n        let guiFakeURL = _this._guiURL;\n        let guiFake = new GuiFake(guiFakeURL, _this._messageBus);\n        _this.guiFake = guiFake;\n        _this.guiDeployed = true;\n      }\n\n      let message = {type: 'create', to: _this._guiURL, from: _this._idmURL,\n        body: {value: {identities: identities, idps: idps}}};\n\n      let id = _this._messageBus.postMessage(message);\n\n      //add listener without timout\n      _this._messageBus.addResponseListener(_this._idmURL, id, msg => {\n        _this._messageBus.removeResponseListener(_this._idmURL, id);\n\n        // todo: to return the user URL and not the email or identifier\n\n        if (msg.body.code === 200) {\n          let selectedIdentity = msg.body;\n\n          console.log('selectedIdentity: ', selectedIdentity.value);\n          resolve(selectedIdentity);\n        } else {\n          reject('error on requesting an identity to the GUI');\n        }\n      });\n    });\n  }\n\n  /**\n  * Function that fetch an identityAssertion from a user.\n  *\n  * @return {IdAssertion}              IdAssertion\n  */\n  getIdentityAssertion(identityBundle) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      //CHECK whether is browser environment or nodejs\n      //if it is browser, then create a fake identity\n\n      _this.runtimeCapabilities.isAvailable('browser').then((result) => {\n        console.log('runtime browser identity acquisition ', result);\n\n        if (!result) return;\n\n        //todo: only idp should be mandatory when identityBundle exists\n\n        if (identityBundle &&\n            identityBundle.hasOwnProperty('idp')) {\n\n          let idp = identityBundle.idp;\n          let origin = identityBundle.hasOwnProperty('origin') ? identityBundle.origin : 'origin';\n          let idHint = identityBundle.hasOwnProperty('idHint') ? identityBundle.idHint : '';\n\n          _this.selectIdentityForHyperty(origin, idp, idHint).then((assertion) => {\n            console.log('[IdentityModule] Identity selected by hyperty.');\n            return resolve(assertion);\n          }, (err) => { // if it got an error then just select identity from GUI\n            console.error('[IdentityModule] Could not select identity from hyperty.');\n            _this.selectIdentityFromGUI().then((newAssertion) => {\n              console.log('[IdentityModule] Identity selected by hyperty.');\n              return resolve(newAssertion);\n            }, (err) => {\n              return reject(err);\n            });\n          });\n        } else {\n\n          if (_this.currentIdentity && _this.currentIdentity.expires > _this._seconds_since_epoch() )\n          {\n            return resolve(_this.currentIdentity);\n          } else {\n            _this.selectIdentityFromGUI().then((assertion) => {\n            console.log('[IdentityModule] Identity selected from GUI.')\n            return resolve(assertion);\n          }, (err) => {\n            return reject(err);\n          });\n          }\n        }\n      }).catch(error => {\n        console.error('Error on identity acquisition ', error);\n        return reject(error);\n      });\n\n      _this.runtimeCapabilities.isAvailable('node').then((result) => {\n        console.log('node identity acquisition ', result);\n\n        if (!result) return;\n\n        if (_this.currentIdentity !== undefined) {\n          //TODO verify whether the token is still valid or not.\n          // should be needed to make further requests, to obtain a valid token\n          return resolve(_this.currentIdentity);\n        } else {\n          console.log('getIdentityAssertion for nodejs');\n          //let randomNumber = Math.floor((Math.random() * 10000) + 1);\n          let nodejsUser = 'nodejs-conference';\n\n          let userProfile = {\n            avatar: 'https://lh3.googleusercontent.com/-WaCrjVMMV-Q/AAAAAAAAAAI/AAAAAAAAAAs/8OlVqCpSB9c/photo.jpg',\n            cn: 'test nodejs',\n            username: nodejsUser + '@nodejs.com',\n            userURL: 'user://nodejs.com/' + nodejsUser + '@nodejs.com'\n          };\n\n          let identityBundle = {\n            assertion: 'assertion',\n            idp: 'nodejs',\n            identity: 'user://nodejs.com/' + nodejsUser + '@nodejs.com',\n            messageInfo: {\n              assertion: 'assertion',\n              idp: 'nodejs',\n              userProfile: userProfile\n            },\n            userProfile: userProfile\n          };\n          _this.currentIdentity = identityBundle;\n          _this.identities.push(identityBundle);\n          _this.storageManager.set('idModule:identities', 0, _this.identities).then(() => {\n\n            return resolve(identityBundle);\n          });\n        }\n\n      }).catch(error => {\n        console.log('Error on identity acquisition ', error);\n        reject(error);\n      });\n    });\n  }\n\n  getExistingValidToken() {\n\n  }\n\n  callGenerateMethods(idp, origin) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      let publicKey;\n      let userkeyPair;\n\n      //generates the RSA key pair\n      _this.crypto.generateRSAKeyPair().then(function(keyPair) {\n\n        publicKey = btoa(keyPair.public);\n        userkeyPair = keyPair;\n        return _this.generateAssertion(publicKey, origin, '', userkeyPair, idp);\n\n      }).then(function(url) {\n        _this.myHint = url;\n        return _this.generateAssertion(publicKey, origin, url, userkeyPair, idp);\n\n      }).then(function(value) {\n        if (value) {\n          resolve(value);\n        } else {\n          reject('Error on obtaining Identity');\n        }\n      }).catch(function(err) {\n        console.log(err);\n        reject(err);\n      });\n    });\n  }\n\n  loginSelectedIdentity(publicKey, origin, idp, keyPair, loginUrl) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      _this.callIdentityModuleFunc('openPopup', {urlreceived: loginUrl}).then((idCode) => {\n        return idCode;\n      }, (err) => {\n        console.error('Error while logging in for the selected identity.');\n        return reject(err);\n      }).then((idCode) => {\n        _this.sendGenerateMessage(publicKey, origin, idCode, idp).then((newResponse) => {\n          if (newResponse.hasOwnProperty('assertion')) {\n            _this.storeIdentity(newResponse, keyPair);\n          } else {\n            console.error('Error while logging in for the selected identity.');\n            return reject('Could not generate a valid assertion for selected identity.');\n          }\n        });\n      });\n    });\n  }\n\n  generateSelectedIdentity(publicKey, origin, idp, keyPair) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      _this.generateAssertion(publicKey, origin, '', keyPair, idp).then((loginUrl) => {\n        return loginUrl;\n      }).then(function(url) {\n        return _this.generateAssertion(publicKey, origin, url, keyPair, idp);\n      }).then(function(value) {\n        if (value) {\n          return resolve(value);\n        } else {\n          return reject('Error on obtaining Identity');\n        }\n      }).catch(function(err) {\n        console.error(err);\n        return reject(err);\n      });\n    });\n  }\n\n  selectIdentityForHyperty(origin, idp, idHint) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      //generates the RSA key pair\n      _this.crypto.generateRSAKeyPair().then(function(keyPair) {\n        let publicKey = btoa(keyPair.public);\n\n        _this.sendGenerateMessage(publicKey, origin, idHint, idp).then((response) => {\n          if (response.hasOwnProperty('assertion')) { // identity was logged in, just save it\n            _this.storeIdentity(response, keyPair).then((value) => {\n              return resolve(value);\n            }, (err) => {\n              return reject(err);\n            });\n          } else if(response.hasOwnProperty('loginUrl')) { // identity was not logged in\n            _this.loginSelectedIdentity(publicKey, origin, idp, keyPair, response.loginUrl).then((value) => {\n              return resolve(value);\n            }, (err) => {\n              return reject(err);\n            });\n          } else { // you should never get here, if you do then the IdP Proxy is not well implemented\n            console.error('GenerateAssertion returned invalid response.');\n            console.log('Proceeding by logging in.');\n            _this.generateSelectedIdentity(publicKey, origin, idp, keyPair).then((value) => {\n              return resolve(value);\n            }, (err) => {\n              return reject(err);\n            });\n          }\n        });\n      });\n    });\n  }\n\n  selectIdentityFromGUI(origin) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      let identitiesInfo = _this.getIdentitiesToChoose();\n\n      _this.requestIdentityToGUI(identitiesInfo.identities, identitiesInfo.idps).then(value => {\n\n        if (value.type === 'identity') {\n\n        //  let chosenID = getUserURLFromEmail(value.value);\n        // hack while the user url is not returned from requestIdentityToGUI;\n\n          let chosenID = 'user://' + _this.currentIdentity.idp + '/' + value.value;\n\n          // returns the identity info from the chosen id\n          for (let i in _this.identities) {\n            if (_this.identities[i].identity === chosenID) {\n              return resolve(_this.identities[i].messageInfo);\n            }\n          }\n          return reject('no identity was found .');\n        } else if (value.type === 'idp') {\n\n          _this.callGenerateMethods(value.value, origin).then((value) => {\n            return resolve(value);\n          }, (err) => {\n            return reject(err);\n          });\n\n        } else {\n          return reject('error on GUI received message.');\n        }\n      });\n    });\n  }\n\n  sendGenerateMessage(contents, origin, usernameHint, idpDomain) {\n    let _this = this;\n    let domain = _this._resolveDomain(idpDomain);\n    let message;\n\n    return new Promise((resolve, reject) => {\n      message = {type: 'execute', to: domain, from: _this._idmURL, body: {resource: 'identity', method: 'generateAssertion', params: {contents: contents, origin: origin, usernameHint: usernameHint}}};\n      _this._messageBus.postMessage(message, (res) => {\n        let result = res.body.value;\n\n        resolve(result);\n\n      });\n    });\n  }\n\n  storeIdentity(result, keyPair) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      if (!result.hasOwnProperty('assertion')) {\n        return reject('StoreIdentity: input is not an identity assertion.');\n      }\n\n      let splitedAssertion = result.assertion.split('.');\n      let assertionParsed;\n\n      //verify if the token contains the 3 components, or just the assertion\n      if (splitedAssertion[1]) {\n        assertionParsed = JSON.parse(atob(splitedAssertion[1]));\n      } else {\n\n        assertionParsed = JSON.parse(atob(result.assertion));\n      }\n      let idToken;\n\n      //TODO remove the verification and remove the tokenIDJSON from the google idpProxy;\n      if (assertionParsed.tokenIDJSON) {\n        idToken = assertionParsed.tokenIDJSON;\n      } else {\n        idToken = assertionParsed;\n      }\n\n      idToken.idp = result.idp;\n\n      let email = idToken.email || idToken.sub;\n\n      // let identifier = getUserURLFromEmail(email);\n\n      let identifier = 'user://' + idToken.idp.domain + '/' + email;\n\n      result.identity = identifier;\n\n      _this.identity.addIdentity(result);\n\n      // check if exists any infoToken in the result received\n      let infoToken = (result.infoToken) ? result.infoToken : {};\n\n      let commonName = idToken.name || email.substring(0, email.indexOf('@'));\n      let userProfileBundle = {username: email, cn: commonName, avatar: infoToken.picture, locale: infoToken.locale, userURL: identifier};\n\n      //creation of a new JSON with the identity to send via messages\n      let newIdentity = {userProfile: userProfileBundle, idp: result.idp.domain, assertion: result.assertion, expires: result.info.expires};\n      result.messageInfo = newIdentity;\n      result.keyPair = keyPair;\n\n      _this.currentIdentity = newIdentity;\n\n      //verify if the id already exists. If already exists then do not add to the identities list;\n      //to be reviewed since the identity contains data like the asssrtion and ley pairs that may be different if generated twice\n\n      let idAlreadyExists = false;\n      let oldId;\n      for (let identity in _this.identities) {\n        if (_this.identities[identity].identity === result.identity) {\n          idAlreadyExists = true;\n          oldId = _this.identities[identity].messageInfo;\n        }\n      }\n\n      if (idAlreadyExists) { // TODO: TIAGO maybe overwrite the identity\n        resolve(oldId);\n        let exists = false;\n\n        //check if the identity exists in emailList, if not add it\n        //This is useful if an identity was previously registered but was later unregistered\n        for (let i in _this.emailsList) {\n          if (_this.emailsList[i] === email) {\n            exists = true;\n            break;\n          }\n        }\n        if (!exists) {\n          _this.emailsList.push(email);\n        }\n\n      } else {\n        _this.emailsList.push(email);\n        _this.identities.push(result);\n        _this.storageManager.set('idModule:identities', 0, _this.identities).then(() => {\n          if (_this.identitiesList[idToken.idp.domain])\n            _this.identitiesList[idToken.idp.domain].status = 'created';\n\n          resolve(newIdentity);\n        });\n      }\n\n    });\n  }\n\n  /**\n  * Requests the IdpProxy from a given Domain for an identityAssertion\n  *\n  * @param  {DOMString} contents     contents\n  * @param  {DOMString} origin       origin\n  * @param  {DOMString} usernameHint usernameHint\n  * @param  {JSON}      keyPair       user keyPair\n  * @return {IdAssertion}              IdAssertion\n  */\n  generateAssertion(contents, origin, usernameHint, keyPair, idpDomain) {\n    let _this = this;\n\n    console.log('generateAssertion');\n\n    return new Promise(function(resolve, reject) {\n\n      _this.sendGenerateMessage(contents, origin, usernameHint, idpDomain).then((result) => {\n\n        if (result.loginUrl) {\n\n          _this.callIdentityModuleFunc('openPopup', {urlreceived: result.loginUrl}).then((value) => {\n            resolve(value);\n          }, (err) => {\n            reject(err);\n          });\n        } else if (result) {\n\n          _this.storeIdentity(result, keyPair).then((value) => {\n            resolve(value);\n          }, (err) => {\n            reject(err);\n          });\n\n        } else {\n          reject('error on obtaining identity information');\n        }\n\n      });\n    });\n  }\n\n  /**\n  * OTHER USER'S IDENTITY\n  */\n\n  /**\n  * Requests the IdpProxy from a given Domain to validate an IdentityAssertion\n  * Returns a promise with the result from the validation.\n  * @param  {DOMString} assertion\n  * @param  {DOMString} origin       origin\n  * @return {Promise}         Promise         promise with the result from the validation\n  */\n  validateAssertion(assertion, origin, idpDomain) {\n    let _this = this;\n\n    let domain = _this._resolveDomain(idpDomain);\n\n    let message = {type: 'execute', to: domain, from: _this._idmURL, body: {resource: 'identity', method: 'validateAssertion',\n      params: {assertion: assertion, origin: origin}}};\n\n    return new Promise(function(resolve, reject) {\n      _this._messageBus.postMessage(message, (result) => {\n        if (result.body.code === 200) {\n          resolve(result.body.value);\n        } else {\n          reject('error', result.body.code);\n        }\n      });\n    });\n  }\n\n  encryptMessage(message) {\n    let _this = this;\n\n    console.log('encrypt message ');\n\n    return new Promise(function(resolve, reject) {\n      let isHandShakeType = message.type === 'handshake';\n\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption && !isHandShakeType) {\n        console.log('encryption disabled');\n        return resolve(message);\n      }\n\n      //TODO remove this logic and move it to a util function\n      let splitedToURL = message.to.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      let isToDataObject = isDataObjectURL(dataObjectURL);\n      let isToLegacyIdentity = isLegacy(message.to);\n      let isFromHyperty = divideURL(message.from).type === 'hyperty';\n      let isToHyperty = divideURL(message.to).type === 'hyperty';\n\n      if (message.type === 'update') {\n        return resolve(message);\n      }\n\n      if (isToLegacyIdentity) {\n        resolve(message);\n      } else if (isFromHyperty && isToHyperty) {\n        let userURL = _this._registry.getHypertyOwner(message.from);\n        if (userURL) {\n\n          // check if exists any keys between two users\n          let chatKeys = _this.chatKeys[message.from + '<->' + message.to];\n          if (!chatKeys) {\n            chatKeys = _this._newChatCrypto(message, userURL);\n            console.log('createChatKey encrypt', message.from + message.to);\n            _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n            message.body.handshakePhase = 'startHandShake';\n          }\n\n          if (chatKeys.authenticated && !isHandShakeType) {\n\n            let iv = _this.crypto.generateIV();\n            _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, message.body.value, iv).then(encryptedValue => {\n\n              let filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, chatKeys.hypertyFrom.messageInfo);\n\n              _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage).then(hash => {\n                //console.log('result of hash ', hash);\n                let value = {iv: _this.crypto.encode(iv), value: _this.crypto.encode(encryptedValue), hash: _this.crypto.encode(hash)};\n                message.body.value = JSON.stringify(value);\n\n                resolve(message);\n              });\n            });\n\n            // if is a handshake message, just resolve it\n          } else if (isHandShakeType) {\n            resolve(message);\n\n            // else, starts a new handshake protocol\n          } else {\n            _this._doHandShakePhase(message, chatKeys).then(function(value) {\n              _this.chatKeys[message.from + '<->' + message.to] = value.chatKeys;\n\n              _this._messageBus.postMessage(value.message);\n              reject('encrypt handshake protocol phase ');\n            });\n          }\n        }\n\n      //if from hyperty to a dataObjectURL\n      } else if (isFromHyperty && isToDataObject) {\n\n        console.log('dataObject value to encrypt: ', message.body.value);\n        console.log('IdentityModule - encrypt from hyperty to dataobject ', message);\n\n        _this.storageManager.get('dataObjectSessionKeys').then((sessionKeys) => {\n          let dataObjectKey = sessionKeys ? sessionKeys[dataObjectURL] : null;\n\n          _this.dataObjectsStorage.getDataObject(dataObjectURL).then((isHypertyReporter) => {\n            //if no key exists, create a new one if is the reporter of dataObject\n            if (!dataObjectKey) {\n              // if the hyperty is the reporter of the dataObject then generates a session key\n              if (isHypertyReporter.owner && isHypertyReporter.owner === message.from) {\n\n                let sessionKey = _this.crypto.generateRandom();\n                _this.dataObjectSessionKeys[dataObjectURL] = {sessionKey: sessionKey, isToEncrypt: true};\n\n                // TIAGO - persistence issue #147\n                _this.storageManager.set('dataObjectSessionKeys', 0, _this.dataObjectSessionKeys);\n                dataObjectKey = _this.dataObjectSessionKeys[dataObjectURL];\n              }\n            }\n\n            //check if there is already a session key for the chat room\n            if (dataObjectKey) {\n\n              // and if is to apply encryption, encrypt the messages\n              if (dataObjectKey.isToEncrypt) {\n                let iv = _this.crypto.generateIV();\n\n                _this.crypto.encryptAES(dataObjectKey.sessionKey, _this.crypto.encode(JSON.stringify(message.body.value)), iv).then(encryptedValue => {\n\n                  let filteredMessage = _this._filterMessageToHash(message, message.body.value + iv, dataObjectKey.sessionKey);\n\n                  _this.crypto.hashHMAC(dataObjectKey.sessionKey, filteredMessage).then(hash => {\n                    //console.log('hash ', hash);\n\n                    let newValue = {value: _this.crypto.encode(encryptedValue), iv: _this.crypto.encode(iv), hash: _this.crypto.encode(hash)};\n\n                    message.body.value = JSON.stringify(newValue);\n                    resolve(message);\n                  });\n                });\n\n              // if not, just send the message\n              } else {\n                resolve(message);\n              }\n\n              // start the generation of a new session Key\n            } else {\n              reject('failed to decrypt message');\n            }\n          });\n        });\n      }\n    });\n  }\n\n  encryptDataObject(dataObject, sender) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      console.log('dataObject value to encrypt: ', dataObject);\n\n      let splitedToURL = sender.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      _this.storageManager.get('dataObjectSessionKeys').then((sessionKeys) => {\n        let dataObjectKey = sessionKeys ? sessionKeys[dataObjectURL] : null;\n\n        //check if there is already a session key for the chat room\n        if (dataObjectKey) {\n\n          // and if is to apply encryption, encrypt the messages\n          if (dataObjectKey.isToEncrypt) {\n            let iv = _this.crypto.generateIV();\n\n            _this.crypto.encryptAES(dataObjectKey.sessionKey, _this.crypto.encode(JSON.stringify(dataObject)), iv).then(encryptedValue => {\n              let newValue = { value: _this.crypto.encode(encryptedValue), iv: _this.crypto.encode(iv) };\n              console.log(\"encrypted dataObject\", newValue);\n              return resolve(newValue);\n            });\n\n          // if not, just send the message\n          } else {\n            console.log('The dataObject is not encrypted');\n            return resolve(dataObject);\n          }\n\n          // start the generation of a new session Key\n        } else {\n          return reject('No dataObjectKey for this dataObjectURL:', dataObjectURL);\n        }\n      });\n    });\n  }\n\n  decryptMessage(message) {\n    let _this = this;\n\n    console.log('decrypt message ');\n\n    return new Promise(function(resolve, reject) {\n      let isHandShakeType = message.type === 'handshake';\n\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption && !isHandShakeType) {\n        console.log('decryption disabled');\n        return resolve(message);\n      }\n\n      //TODO remove this logic and move it to a util function\n\n      let splitedToURL = message.to.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      let isToDataObject = isDataObjectURL(dataObjectURL);\n      let isFromHyperty = divideURL(message.from).type === 'hyperty';\n      let isToHyperty = divideURL(message.to).type === 'hyperty';\n\n      if (message.type === 'update') {\n        return resolve(message);\n      }\n\n      //is is hyperty to hyperty communication\n      if (isFromHyperty && isToHyperty) {\n        //console.log('decrypt hyperty to hyperty');\n        let userURL = _this._registry.getHypertyOwner(message.to);\n        if (userURL) {\n\n          let chatKeys = _this.chatKeys[message.to + '<->' + message.from];\n          if (!chatKeys) {\n            chatKeys = _this._newChatCrypto(message, userURL, 'decrypt');\n            _this.chatKeys[message.to + '<->' + message.from] = chatKeys;\n          }\n\n          if (chatKeys.authenticated && !isHandShakeType) {\n            let value = JSON.parse(message.body.value);\n            let iv = _this.crypto.decode(value.iv);\n            let data = _this.crypto.decode(value.value);\n            let hash = _this.crypto.decode(value.hash);\n            _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(decryptedData => {\n              console.log('decrypted value ', decryptedData);\n              message.body.value = decryptedData;\n\n              let filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n              _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(result => {\n                //console.log('result of hash verification! ', result);\n                message.body.assertedIdentity = true;\n                resolve(message);\n              });\n            });\n\n          } else if (isHandShakeType) {\n            _this._doHandShakePhase(message, chatKeys).then(function(value) {\n\n              //if it was started by doMutualAuthentication then ends the protocol\n              if (value === 'handShakeEnd') {\n                reject('decrypt handshake protocol phase ');\n\n              // if was started by a message, then resend that message\n              } else {\n                _this.chatKeys[message.to + '<->' + message.from] = value.chatKeys;\n                _this._messageBus.postMessage(value.message);\n                reject('decrypt handshake protocol phase ');\n              }\n            });\n          } else {\n            reject('wrong message do decrypt');\n          }\n        } else {\n          reject('error on decrypt message');\n        }\n\n        //if from hyperty to a dataObjectURL\n      } else if (isFromHyperty && isToDataObject) {\n        console.log('dataObject value to decrypt: ', message.body);\n\n        _this.storageManager.get('dataObjectSessionKeys').then((sessionKeys) => {\n          let dataObjectKey = sessionKeys ? sessionKeys[dataObjectURL] : null;\n\n          if (dataObjectKey) {\n\n            //check if is to apply encryption\n            if (dataObjectKey.isToEncrypt) {\n              let parsedValue = JSON.parse(message.body.value);\n              let iv = _this.crypto.decode(parsedValue.iv);\n              let encryptedValue = _this.crypto.decode(parsedValue.value);\n              let hash = _this.crypto.decode(parsedValue.hash);\n\n              _this.crypto.decryptAES(dataObjectKey.sessionKey, encryptedValue, iv).then(decryptedValue => {\n                let parsedValue = JSON.parse(atob(decryptedValue));\n                console.log('decrypted Value,', parsedValue);\n                message.body.value = parsedValue;\n\n                let filteredMessage = _this._filterMessageToHash(message, parsedValue + iv);\n\n                _this.crypto.verifyHMAC(dataObjectKey.sessionKey, filteredMessage, hash).then(result => {\n                  //console.log('result of hash verification! ', result);\n\n                  message.body.assertedIdentity = true;\n                  resolve(message);\n                });\n              });\n\n            //if not, just return the message\n            } else {\n              message.body.assertedIdentity = true;\n              resolve(message);\n            }\n\n          } else {\n            message.body.assertedIdentity = true;\n            resolve(message);\n\n            //reject('no sessionKey for chat room found');\n          }\n        });\n\n      } else {\n        reject('wrong message to decrypt');\n      }\n\n    });\n  }\n\n  decryptDataObject(dataObject, sender) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n      //if is not to apply encryption, then returns resolve\n      if (!_this.isToUseEncryption) {\n        console.log('decryption disabled');\n        return resolve(dataObject);\n      }\n\n      let splitedToURL = sender.split('/');\n      let dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3];\n      if (splitedToURL.length > 6) {\n        dataObjectURL = splitedToURL[0] + '//' + splitedToURL[2] + '/' + splitedToURL[3] + '/' + splitedToURL[4];\n      }\n\n      console.log('dataObject value to decrypt: ', dataObject);\n\n      _this.storageManager.get('dataObjectSessionKeys').then((sessionKeys) => {\n        let dataObjectKey = sessionKeys ? sessionKeys[dataObjectURL] : null;\n\n        if (dataObjectKey) {\n\n          //check if is to apply encryption\n          if (dataObjectKey.isToEncrypt) {\n            let iv = _this.crypto.decode(dataObject.iv);\n            let encryptedValue = _this.crypto.decode(dataObject.value);\n\n            _this.crypto.decryptAES(dataObjectKey.sessionKey, encryptedValue, iv).then(decryptedValue => {\n              let parsedValue = JSON.parse(atob(decryptedValue));\n              let newValue = { value: parsedValue, iv: _this.crypto.encode(iv) };\n              console.log('decrypted dataObject,', newValue);\n              return resolve(newValue);\n            });\n\n          //if not, just return the dataObject\n          } else {\n            console.log('The dataObject is not encrypted');\n            return resolve(dataObject);\n          }\n\n        } else {\n          return reject('No dataObjectKey for this dataObjectURL:', dataObjectURL);\n        }\n      });\n    });\n  }\n\n  doMutualAuthentication(sender, receiver) {\n    console.log('doMutualAuthentication: ', sender, receiver);\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      let dataObjectURL;\n\n      // check if the sender is a dataObject and if so stores that value\n      let reporterURL = _this.registry.getReporterURLSynchonous(sender);\n      if (reporterURL) {\n        dataObjectURL = sender;\n        sender = reporterURL;\n      }\n\n      let msg = {\n        to: receiver,\n        from: sender,\n        callback: undefined,\n        body: {handshakePhase: 'startHandShake', ignore: 'ignoreMessage'}\n      };\n\n      if (!sender || !receiver) {\n        return reject('sender or receiver missing on doMutualAuthentication');\n      }\n\n      let chatKeys = _this.chatKeys[sender + '<->' + receiver];\n      let userURL = _this._registry.getHypertyOwner(sender);\n\n      if (userURL) {\n\n        if (!chatKeys) {\n          // callback to resolve when finish the mutual authentication\n          let resolved = function(value) {\n            console.log('callback value:', value);\n            resolve(value);\n          };\n          msg.callback = resolved;\n          msg.dataObjectURL = dataObjectURL;\n\n          chatKeys = _this._newChatCrypto(msg, userURL);\n          _this.chatKeys[sender + '<->' + receiver] = chatKeys;\n        }\n\n        if (chatKeys.authenticated) {\n\n          let startSessionKeyExchange = {\n            to: sender,\n            from: receiver\n          };\n          chatKeys.dataObjectURL = dataObjectURL;\n          _this._sendReporterSessionKey(startSessionKeyExchange, chatKeys).then(value => {\n\n            _this._messageBus.postMessage(value.message);\n            resolve('exchange of chat sessionKey initiated');\n          });\n        } else {\n\n          _this._doHandShakePhase(msg, chatKeys);\n        }\n      } else {\n        reject('error on doMutualAuthentication');\n      }\n    });\n\n  }\n\n  _doHandShakePhase(message, chatKeys) {\n    let _this = this;\n\n    console.log('handshake phase');\n\n    return new Promise(function(resolve, reject) {\n\n      let handshakeType = message.body.handshakePhase;\n      let iv;\n      let hash;\n      let value = {};\n      let filteredMessage;\n      switch (handshakeType) {\n\n        case 'startHandShake':\n          chatKeys.keys.fromRandom = _this.crypto.generateRandom();\n\n          let startHandShakeMsg = {\n            type: 'handshake',\n            to: message.to,\n            from: message.from,\n            body: {\n              handshakePhase: 'senderHello',\n              value: _this.crypto.encode(chatKeys.keys.fromRandom)\n            }\n          };\n          chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(startHandShakeMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n\n          // check if was the encrypt function or the mutual authentication that request the\n          // start of the handShakePhase.\n          if (chatKeys.initialMessage) {\n            resolve({message: startHandShakeMsg, chatKeys: chatKeys});\n          } else {\n            _this.chatKeys[message.from + '<->' + message.to] = chatKeys;\n            _this._messageBus.postMessage(startHandShakeMsg);\n          }\n\n          break;\n        case 'senderHello':\n\n          console.log('senderHello');\n          chatKeys.handshakeHistory.senderHello = _this._filterMessageToHash(message);\n          chatKeys.keys.fromRandom = _this.crypto.decode(message.body.value);\n          chatKeys.keys.toRandom = _this.crypto.generateRandom();\n\n          let senderHelloMsg = {\n            type: 'handshake',\n            to: message.from,\n            from: message.to,\n            body: {\n              handshakePhase: 'receiverHello',\n              value: _this.crypto.encode(chatKeys.keys.toRandom)\n            }\n          };\n          chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(senderHelloMsg, undefined, chatKeys.hypertyFrom.messageInfo);\n          resolve({message: senderHelloMsg, chatKeys: chatKeys});\n\n          break;\n        case 'receiverHello':\n\n          console.log('receiverHello');\n          chatKeys.handshakeHistory.receiverHello = _this._filterMessageToHash(message);\n\n          _this.validateAssertion(message.body.identity.assertion, undefined, message.body.identity.idp).then((value) => {\n\n            //TODO remove later this verification as soon as all the IdP proxy are updated in the example\n            let encodedpublicKey = (typeof value.contents === 'string') ? value.contents : value.contents.nonce;\n\n            let receiverPublicKey = _this.crypto.decode(encodedpublicKey);\n            let premasterSecret = _this.crypto.generatePMS();\n            let toRandom = message.body.value;\n            chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n            chatKeys.hypertyTo.publicKey = receiverPublicKey;\n            chatKeys.hypertyTo.userID    = value.contents.email;\n            chatKeys.keys.toRandom  = _this.crypto.decode(toRandom);\n            chatKeys.keys.premasterKey = premasterSecret;\n\n            let concatKey = _this.crypto.concatPMSwithRandoms(premasterSecret, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n            return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            //generate the master key\n          }).then((masterKey) => {\n            chatKeys.keys.masterKey = masterKey;\n\n            return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            //generate the symmetric and hash keys\n          }).then((keys) => {\n\n            chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[0]);\n            chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[1]);\n            chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[2]);\n            chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[3]);\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            let messageStructure = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate'\n              }\n            };\n\n            // hash the value and the iv\n            filteredMessage = _this._filterMessageToHash(messageStructure, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n          }).then((hash) => {\n            value.hash = _this.crypto.encode(hash);\n\n            //encrypt the data\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok', iv);\n          }).then((encryptedData) => {\n            value.symetricEncryption = _this.crypto.encode(encryptedData);\n\n            return _this.crypto.encryptRSA(chatKeys.hypertyTo.publicKey, chatKeys.keys.premasterKey);\n\n          }).then((encryptedValue) => {\n\n            value.assymetricEncryption = _this.crypto.encode(encryptedValue);\n\n            let messageStructure = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate'\n              }\n            };\n\n            let messageToHash = _this._filterMessageToHash(messageStructure, chatKeys.keys.premasterKey, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.signRSA(chatKeys.hypertyFrom.privateKey, JSON.stringify(chatKeys.handshakeHistory) + JSON.stringify(messageToHash));\n\n          }).then(signature => {\n\n            value.signature = _this.crypto.encode(signature);\n\n            let receiverHelloMsg = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'senderCertificate',\n                value: btoa(JSON.stringify(value))\n              }\n            };\n            chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(receiverHelloMsg, 'ok' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            resolve({message: receiverHelloMsg, chatKeys: chatKeys});\n\n          }, error => reject(error));\n\n          break;\n        case 'senderCertificate':\n\n          console.log('senderCertificate');\n          let receivedValue = JSON.parse(atob(message.body.value));\n\n          _this.validateAssertion(message.body.identity.assertion, undefined, message.body.identity.idp).then((value) => {\n            let encryptedPMS = _this.crypto.decode(receivedValue.assymetricEncryption);\n\n            //TODO remove later this verification as soon as all the IdP proxy are updated in the example\n            let encodedpublicKey = (typeof value.contents === 'string') ? value.contents : value.contents.nonce;\n\n            let senderPublicKey = _this.crypto.decode(encodedpublicKey);\n            chatKeys.hypertyTo.assertion = message.body.identity.assertion;\n            chatKeys.hypertyTo.publicKey = senderPublicKey;\n            chatKeys.hypertyTo.userID    = value.contents.email;\n\n            return _this.crypto.decryptRSA(chatKeys.hypertyFrom.privateKey, encryptedPMS);\n\n          }, (error) => {\n            console.log(error);\n            reject('Error during authentication of identity');\n\n            //obtain the PremasterKey using the private key\n          }).then(pms => {\n\n            chatKeys.keys.premasterKey = new Uint8Array(pms);\n\n            let signature = _this.crypto.decode(receivedValue.signature);\n\n            let receivedmsgToHash = _this._filterMessageToHash(message, chatKeys.keys.premasterKey);\n\n            return _this.crypto.verifyRSA(chatKeys.hypertyTo.publicKey, JSON.stringify(chatKeys.handshakeHistory) + JSON.stringify(receivedmsgToHash), signature);\n\n            // validates the signature received\n          }).then(signValidationResult => {\n\n            console.log('signature validation result ', signValidationResult);\n            let concatKey = _this.crypto.concatPMSwithRandoms(chatKeys.keys.premasterKey, chatKeys.keys.toRandom, chatKeys.keys.fromRandom);\n\n            return _this.crypto.generateMasterSecret(concatKey, 'messageHistoric' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            // generates the master keys from the Premaster key and the randoms\n          }).then(masterKey => {\n            chatKeys.keys.masterKey = masterKey;\n\n            return _this.crypto.generateKeys(masterKey, 'key expansion' + chatKeys.keys.toRandom + chatKeys.keys.fromRandom);\n\n            // generates the symmetric keys to be used in the symmetric encryption\n          }).then(keys => {\n            chatKeys.keys.hypertyFromSessionKey = new Uint8Array(keys[0]);\n            chatKeys.keys.hypertyToSessionKey = new Uint8Array(keys[1]);\n            chatKeys.keys.hypertyFromHashKey = new Uint8Array(keys[2]);\n            chatKeys.keys.hypertyToHashKey = new Uint8Array(keys[3]);\n            iv = _this.crypto.decode(receivedValue.iv);\n            let data = _this.crypto.decode(receivedValue.symetricEncryption);\n\n            return _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv);\n\n          }).then(decryptedData => {\n            //console.log('decryptedData', decryptedData);\n\n            chatKeys.handshakeHistory.senderCertificate = _this._filterMessageToHash(message, decryptedData + iv);\n\n            let hashReceived = _this.crypto.decode(receivedValue.hash);\n\n            filteredMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hashReceived);\n\n          }).then(verifiedHash  => {\n\n            //console.log('result of hash verification ', verifiedHash);\n            let receiverFinishedMessage = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverFinishedMessage'\n              }\n            };\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            filteredMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, receiverFinishedMessage);\n          }).then(hash => {\n\n            value.hash = _this.crypto.encode(hash);\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!', iv);\n\n          }).then(encryptedValue => {\n            value.value = _this.crypto.encode(encryptedValue);\n            let receiverFinishedMessage = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverFinishedMessage',\n                value: btoa(JSON.stringify(value))\n              }\n            };\n\n            chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(receiverFinishedMessage, 'ok!' + iv, chatKeys.hypertyFrom.messageInfo);\n            chatKeys.authenticated = true;\n            resolve({message: receiverFinishedMessage, chatKeys: chatKeys});\n          });\n\n          break;\n        case 'receiverFinishedMessage':\n\n          console.log('receiverFinishedMessage');\n          chatKeys.authenticated = true;\n\n          value = JSON.parse(atob(message.body.value));\n\n          iv = _this.crypto.decode(value.iv);\n          let data = _this.crypto.decode(value.value);\n          hash = _this.crypto.decode(value.hash);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, data, iv).then(decryptedData => {\n            console.log('decryptedData', decryptedData);\n            chatKeys.handshakeHistory.receiverFinishedMessage = _this._filterMessageToHash(message, decryptedData + iv);\n\n            let filteredMessage = _this._filterMessageToHash(message, data + iv);\n            _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, hash).then(result => {\n              console.log('hash result', result);\n\n              // check if there was an initial message that was blocked and send it\n              if (chatKeys.initialMessage) {\n                let initialMessage = {\n                  type: 'create',\n                  to: message.from,\n                  from: message.to,\n                  body: {\n                    value: chatKeys.initialMessage.body.value\n                  }\n                };\n\n                resolve({message: initialMessage, chatKeys: chatKeys});\n\n                //sends the sessionKey to the subscriber hyperty\n              } else {\n                _this._sendReporterSessionKey(message, chatKeys).then(value => {\n                  resolve(value);\n                });\n              }\n            });\n          });\n\n          break;\n        case 'reporterSessionKey':\n\n          console.log('reporterSessionKey');\n\n          let valueIVandHash = JSON.parse(atob(message.body.value));\n          hash = _this.crypto.decode(valueIVandHash.hash);\n          iv = _this.crypto.decode(valueIVandHash.iv);\n          let encryptedValue = _this.crypto.decode(valueIVandHash.value);\n          let parsedValue;\n          let sessionKey;\n          let dataObjectURL;\n          let receiverAcknowledgeMsg;\n\n          console.log('[IdentityModule reporterSessionKey] - decryptAES: ', chatKeys.keys.hypertyToSessionKey, encryptedValue, iv);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, encryptedValue, iv).then(decryptedValue => {\n\n            parsedValue = JSON.parse(decryptedValue);\n            sessionKey = _this.crypto.decode(parsedValue.value);\n            dataObjectURL = parsedValue.dataObjectURL;\n\n            let messageToHash = _this._filterMessageToHash(message, decryptedValue + iv);\n\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, messageToHash, hash);\n\n          }).then(hashResult => {\n\n            //console.log('hash successfully validated ', hashResult);\n\n            _this.dataObjectSessionKeys[dataObjectURL] =  {sessionKey: sessionKey, isToEncrypt: true};\n\n            _this.storageManager.set('dataObjectSessionKeys', 0, _this.dataObjectSessionKeys);\n\n            iv = _this.crypto.generateIV();\n            value.iv = _this.crypto.encode(iv);\n\n            return _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, 'ok!!', iv);\n          }).then(encryptedValue => {\n\n            receiverAcknowledgeMsg = {\n              type: 'handshake',\n              to: message.from,\n              from: message.to,\n              body: {\n                handshakePhase: 'receiverAcknowledge'\n              }\n            };\n\n            value.value = _this.crypto.encode(encryptedValue);\n            let messageToHash = _this._filterMessageToHash(receiverAcknowledgeMsg, 'ok!!' + iv, chatKeys.hypertyFrom.messageInfo);\n\n            return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, messageToHash);\n          }).then(hashedMessage => {\n            let finalValue = btoa(JSON.stringify({value: value.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv}));\n\n            receiverAcknowledgeMsg.body.value = finalValue;\n            resolve({message: receiverAcknowledgeMsg, chatKeys: chatKeys});\n          });\n\n          break;\n        case 'receiverAcknowledge':\n\n          console.log('receiverAcknowledge');\n\n          let receivedvalueIVandHash = JSON.parse(atob(message.body.value));\n          let receivedHash = _this.crypto.decode(receivedvalueIVandHash.hash);\n          iv = _this.crypto.decode(receivedvalueIVandHash.iv);\n          let receivedEncryptedValue = _this.crypto.decode(receivedvalueIVandHash.value);\n\n          _this.crypto.decryptAES(chatKeys.keys.hypertyToSessionKey, receivedEncryptedValue, iv).then(decryptedValue => {\n\n            let filteredMessage = _this._filterMessageToHash(message, decryptedValue + iv);\n            return _this.crypto.verifyHMAC(chatKeys.keys.hypertyToHashKey, filteredMessage, receivedHash);\n          }).then(hashResult => {\n            //console.log('hashResult ', hashResult);\n\n            let callback = chatKeys.callback;\n\n            if (callback) {\n              callback('handShakeEnd');\n            }\n            resolve('handShakeEnd');\n          });\n\n          break;\n        default:\n          reject(message);\n      }\n    });\n  }\n\n  _sendReporterSessionKey(message, chatKeys) {\n    let _this = this;\n    let sessionKeyBundle = _this.dataObjectSessionKeys[chatKeys.dataObjectURL];\n    let reporterSessionKeyMsg;\n    let valueToEncrypt;\n    let sessionKey;\n    let iv;\n    let value = {};\n\n    return new Promise(function(resolve, reject) {\n\n      //if there is not yet a session Key, generates a new one\n      if (!sessionKeyBundle) {\n        sessionKey = _this.crypto.generateRandom();\n        _this.dataObjectSessionKeys[chatKeys.dataObjectURL] = {sessionKey: sessionKey, isToEncrypt: true};\n\n        _this.storageManager.set('dataObjectSessionKeys', 0, _this.dataObjectSessionKeys);\n      } else {\n        sessionKey = sessionKeyBundle.sessionKey;\n      }\n\n      valueToEncrypt = JSON.stringify({value: _this.crypto.encode(sessionKey), dataObjectURL: chatKeys.dataObjectURL});\n\n      iv = _this.crypto.generateIV();\n      value.iv = _this.crypto.encode(iv);\n      _this.crypto.encryptAES(chatKeys.keys.hypertyFromSessionKey, valueToEncrypt, iv).then(encryptedValue => {\n\n        reporterSessionKeyMsg = {\n          type: 'handshake',\n          to: message.from,\n          from: message.to,\n          body: {\n            handshakePhase: 'reporterSessionKey',\n            value: _this.crypto.encode(encryptedValue)\n          }\n        };\n\n        let filteredMessage = _this._filterMessageToHash(reporterSessionKeyMsg, valueToEncrypt + iv, chatKeys.hypertyFrom.messageInfo);\n\n        return _this.crypto.hashHMAC(chatKeys.keys.hypertyFromHashKey, filteredMessage);\n      }).then(hashedMessage => {\n\n        let valueWithHash = btoa(JSON.stringify({value: reporterSessionKeyMsg.body.value, hash: _this.crypto.encode(hashedMessage), iv: value.iv}));\n\n        reporterSessionKeyMsg.body.value = valueWithHash;\n        resolve({message: reporterSessionKeyMsg, chatKeys: chatKeys});\n      });\n    });\n  }\n\n  /**\n  * returns the reporter associated to the dataObject URL\n  * @param   {String}   dataObjectURL         dataObject url\n  * @return   {String}  reporter              dataObject url reporter\n  */\n  _getHypertyFromDataObject(dataObjectURL) {\n    let _this = this;\n\n    return new Promise(function(resolve, reject) {\n\n      //TODO remove this logic and move it to a util function\n\n      let splitedURL = dataObjectURL.split('/');\n      let finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3];\n      if (splitedURL.length > 6) {\n        finalURL = splitedURL[0] + '//' + splitedURL[2] + '/' + splitedURL[3] + '/' + splitedURL[4];\n      }\n\n      // check if is the creator of the hyperty\n      let reporterURL = _this.registry.getReporterURLSynchonous(finalURL);\n\n      if (reporterURL) {\n        resolve(reporterURL);\n      } else {\n        // check if there is already an association from an hypertyURL to the dataObject\n        let storedReporterURL = _this.dataObjectsIdentity[finalURL];\n\n        if (storedReporterURL) {\n          resolve(storedReporterURL);\n        } else {\n          // check if there is any hyperty that subscribed the dataObjectURL\n          let subscriberHyperty = _this.registry.getDataObjectSubscriberHyperty(dataObjectURL);\n\n          if (subscriberHyperty) {\n            resolve(subscriberHyperty);\n          } else {\n\n            // search in domain registry for the hyperty associated to the dataObject\n            // search in case is a subscriber who wants to know the reporter\n            _this.registry.discoverDataObjectPerURL(finalURL, splitedURL[2]).then(dataObject => {\n              _this.dataObjectsIdentity[finalURL] = dataObject.reporter;\n              resolve(dataObject.reporter);\n            }, err => {\n              reject(err);\n            });\n          }\n        }\n      }\n    });\n  }\n\n  /**\n  * filter the messages to hash, by removing some fields not generated by the runtime core\n  * @param {Message}  message                     message\n  * @param {String}  decryptedValue (Optional)    value from body.value in case it originally comes encrypted\n  * @param {JSON}  identity(Optional)    add the hyperty identity associated in case is not added to the initial message\n  * @return {Message}  new message filtered\n  */\n  _filterMessageToHash(message, decryptedValue, identity) {\n\n    return {\n      type: message.type,\n      from: message.from,\n      to: message.to,\n      body: {\n        identity: identity || message.body.identity,\n        value: decryptedValue || message.body.value,\n        handshakePhase: message.body.handshakePhase\n      }\n    };\n  }\n\n  /**\n  * generates the initial structure for the keys between two users\n  * @param {JSON}    message              initial message that triggers the mutual authentication\n  * @param {String}  userURL              userURL\n  * @param {boolean} receiver(Optional)  indicates if is the sender or the receiver that creates a new chat crypto\n  * @return {JSON} newChatCrypto  new JSON structure for the chat crypto\n  */\n  _newChatCrypto(message, userURL, receiver) {\n    let _this = this;\n\n    //check whether is the sender or the receiver to create a new chatCrypto\n    //to mantain consistency on the keys if the receiver create a new chatCrypto,\n    //then invert the fields\n    let from = (receiver) ? message.to : message.from;\n    let to = (receiver) ? message.from : message.to;\n\n    let userInfo = _this.getIdentity(userURL);\n\n    let newChatCrypto =\n      {\n        hypertyFrom:\n        {\n          hyperty: from,\n          userID: userInfo.messageInfo.userProfile.username,\n          privateKey: userInfo.keyPair.private,\n          publicKey: userInfo.keyPair.public,\n          assertion: userInfo.assertion,\n          messageInfo: userInfo.messageInfo\n        },\n        hypertyTo:\n        {\n          hyperty: to,\n          userID: undefined,\n          publicKey: undefined,\n          assertion: undefined\n        },\n        keys:\n        {\n          hypertyToSessionKey: undefined,\n          hypertyFromSessionKey: undefined,\n          hypertyToHashKey: undefined,\n          hypertyFromHashKey: undefined,\n          toRandom: undefined,\n          fromRandom: undefined,\n          premasterKey: undefined,\n          masterKey: undefined\n        },\n        handshakeHistory: {\n          senderHello: undefined,\n          receiverHello: undefined,\n          senderCertificate: undefined,\n          receiverFinishedMessage: undefined\n        },\n        initialMessage: (message.body.ignore) ? undefined : message,\n        callback: message.callback,\n        authenticated: false,\n        dataObjectURL: message.dataObjectURL\n      };\n\n    return newChatCrypto;\n  }\n}\n\nexport default IdentityModule;\n",
    "static": true,
    "longname": "src/identity/IdentityModule.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 119,
    "kind": "class",
    "name": "IdentityModule",
    "memberof": "src/identity/IdentityModule.js",
    "static": true,
    "longname": "src/identity/IdentityModule.js~IdentityModule",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/identity/IdentityModule.js",
    "importStyle": "IdentityModule",
    "description": "\nThe Identity Module (Id Module) is the component responsible for handling the\nuser identity and the association of this identity with the Hyperty instances,\nin order to make Hyperty instances identifiable. The identity in the reTHINK project\nis not fixed to a unique Identity Service Provider, but obtained through several\ndifferent Identity sources. With this approach, the Id Module provides to the user the\noption to choose the preferred method for authentication.\nThis module will thus able to support multiple Identity acquisition methods,\nsuch as OpenID connect 1.0, Kerberos System, or authentication through smart cards.\nFor example, a user with a Google account can use the Google as an Identity Provider to provide Identity Tokens,\n which can be used by the Identity Module to associate it with a Hyperty instance.\n\nThe Identity Module uses a node package, the HelloJS, which is a client-side JavaScript API for authentication\nthat facilitates the requests for the OpenID connect protocol. This method allows for some abstraction\nwhen making requests for different Identity Providers, such as OpenID connect used by Google, Facebook, Microsoft, for example.\n\nWhen a request for a user identity is made using the method loginWithRP(identifier, scope),\nthis method will analyse the Identity Provider chosen to obtain an identity and will use the HelloJS node package\nwith the selected Identity Provider and identity scope. After the HelloJS request for an Access Token\nto the Identity Providers, the user will be prompted to authenticate towards the Identity Provider.\nUpon receiving the Access Token, this token is validated with a RESTful web service request to an endpoint\non the Identity Provider Authorization Server, and after the validation is done,\nan ID token is obtained with the information according to the scope required.\nThis ID token is then preserved in this module that can obtained through the getIdentities()\nand is passed as return value of the loginWithRP function. The methods generateAssertion and validateAssertion have not yet been developed.",
    "lineNumber": 36,
    "interface": false
  },
  {
    "__docId__": 120,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#constructor",
    "access": null,
    "description": "This is the constructor to initialise the Identity Module it does not require any input.",
    "lineNumber": 41,
    "params": [
      {
        "name": "runtimeURL",
        "types": [
          "*"
        ]
      },
      {
        "name": "runtimeCapabilities",
        "types": [
          "*"
        ]
      },
      {
        "name": "storageManager",
        "types": [
          "*"
        ]
      },
      {
        "name": "dataObjectsStorage",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "callIdentityModuleFunc",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#callIdentityModuleFunc",
    "access": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "methodName",
        "types": [
          "*"
        ]
      },
      {
        "name": "parameters",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "get",
    "name": "messageBus",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#messageBus",
    "access": null,
    "description": "return the messageBus in this Registry",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "set",
    "name": "messageBus",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#messageBus",
    "access": null,
    "description": "Set the messageBus in this Registry",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "MessageBus"
        ],
        "spread": false,
        "optional": false,
        "name": "messageBus",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "addGUIListeners",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#addGUIListeners",
    "access": null,
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 125,
    "kind": "get",
    "name": "registry",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#registry",
    "access": null,
    "description": "return the registry in this idModule",
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "registry"
        ],
        "spread": false,
        "optional": false,
        "name": "registry",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "set",
    "name": "registry",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#registry",
    "access": null,
    "description": "Set the registry in this idModule",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "registry"
        ],
        "spread": false,
        "optional": false,
        "name": "reg",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "getIdentities",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentities",
    "access": null,
    "description": "Function to return all the identities registered within a session by a user.\nThese identities are returned in an array containing a JSON package for each user identity.",
    "lineNumber": 209,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Array<Identities>"
      ],
      "spread": false,
      "description": "Identities"
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "getIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentity",
    "access": null,
    "description": "gets all the information from a given userURL",
    "lineNumber": 219,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "user url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "identity    identity bundle from the userURL"
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "_seconds_since_epoch",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_seconds_since_epoch",
    "access": null,
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "_loadIdentities",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_loadIdentities",
    "access": null,
    "description": null,
    "lineNumber": 237,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "deployGUI",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#deployGUI",
    "access": null,
    "description": null,
    "lineNumber": 269,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "_getValidToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_getValidToken",
    "access": null,
    "description": "GetValidToken is for non legacy hyperties and verifies if the Token is still valid\nif the token is invalid it requests a new token",
    "lineNumber": 280,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyURL",
        "description": "hypertyURL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "getToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getToken",
    "access": null,
    "description": "get a Token to be added to a message",
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "fromURL",
        "description": "origin of the message"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "toURL",
        "description": "target of the message"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "token    token to be added to the message"
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "getIdToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdToken",
    "access": null,
    "description": "get an Id Token for a HypertyURL",
    "lineNumber": 410,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "hypertyURL",
        "description": "the Hyperty address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "token    Id token to be added to the message"
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "getAccessToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getAccessToken",
    "access": null,
    "description": "get an Access Token for a legacyURL",
    "lineNumber": 462,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "legacyURL",
        "description": "the legacy address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "token    Access token to be added to the message"
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "getIdentitiesToChoose",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentitiesToChoose",
    "access": null,
    "description": null,
    "lineNumber": 509,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "{\"identities\": *, \"idps\": *}"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "getUsersIDs",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getUsersIDs",
    "access": null,
    "description": "Function to return all the users URLs registered within a session\nThese users URLs are returned in an array of strings.",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "emailFormat",
        "description": "(Optional)   boolean to indicate to return in email format"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<String>"
      ],
      "spread": false,
      "description": "users"
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "getCurrentIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getCurrentIdentity",
    "access": null,
    "description": "Function to return the selected Identity within a session",
    "lineNumber": 541,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": "identity         identity"
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "setCurrentIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#setCurrentIdentity",
    "access": null,
    "description": "Function to set the current Identity with a given Identity",
    "lineNumber": 550,
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "identity"
      }
    ]
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "deleteIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#deleteIdentity",
    "access": null,
    "description": "Function to remove an identity from the Identities array",
    "lineNumber": 559,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "userURL"
      }
    ]
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "unregisterIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#unregisterIdentity",
    "access": null,
    "description": "Function to unregister an identity from the emailsList array and not show in to the GUI",
    "lineNumber": 575,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "email"
      }
    ]
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "_resolveDomain",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_resolveDomain",
    "access": null,
    "description": "Function that resolve and create the domainURL in case it is provided one. If not, resolve the default domainURL",
    "lineNumber": 589,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "idpDomain",
        "description": "idpDomain (Optional)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "requestIdentityToGUI",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#requestIdentityToGUI",
    "access": null,
    "description": "Function that sends a request to the GUI using messages. Sends all identities registered and\nthe Idps supported, and return the identity/idp received by the GUI",
    "lineNumber": 604,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<identity>"
        ],
        "spread": false,
        "optional": false,
        "name": "identities",
        "description": "list of identitiies"
      },
      {
        "nullable": null,
        "types": [
          "Array<String>"
        ],
        "spread": false,
        "optional": false,
        "name": "idps",
        "description": "list of idps to authenticate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "returns a chosen identity or idp"
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "getIdentityAssertion",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getIdentityAssertion",
    "access": null,
    "description": "Function that fetch an identityAssertion from a user.",
    "lineNumber": 644,
    "params": [
      {
        "name": "identityBundle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IdAssertion"
      ],
      "spread": false,
      "description": "IdAssertion"
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "getExistingValidToken",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#getExistingValidToken",
    "access": null,
    "description": null,
    "lineNumber": 744,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "callGenerateMethods",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#callGenerateMethods",
    "access": null,
    "description": null,
    "lineNumber": 748,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "loginSelectedIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#loginSelectedIdentity",
    "access": null,
    "description": null,
    "lineNumber": 780,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "publicKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyPair",
        "types": [
          "*"
        ]
      },
      {
        "name": "loginUrl",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "generateSelectedIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#generateSelectedIdentity",
    "access": null,
    "description": null,
    "lineNumber": 802,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "publicKey",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyPair",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "selectIdentityForHyperty",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#selectIdentityForHyperty",
    "access": null,
    "description": null,
    "lineNumber": 824,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "origin",
        "types": [
          "*"
        ]
      },
      {
        "name": "idp",
        "types": [
          "*"
        ]
      },
      {
        "name": "idHint",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "selectIdentityFromGUI",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#selectIdentityFromGUI",
    "access": null,
    "description": null,
    "lineNumber": 860,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "origin",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "sendGenerateMessage",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#sendGenerateMessage",
    "access": null,
    "description": null,
    "lineNumber": 897,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "contents",
        "types": [
          "*"
        ]
      },
      {
        "name": "origin",
        "types": [
          "*"
        ]
      },
      {
        "name": "usernameHint",
        "types": [
          "*"
        ]
      },
      {
        "name": "idpDomain",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "storeIdentity",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#storeIdentity",
    "access": null,
    "description": null,
    "lineNumber": 913,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "result",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyPair",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "generateAssertion",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#generateAssertion",
    "access": null,
    "description": "Requests the IdpProxy from a given Domain for an identityAssertion",
    "lineNumber": 1017,
    "params": [
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "contents",
        "description": "contents"
      },
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "origin",
        "description": "origin"
      },
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "usernameHint",
        "description": "usernameHint"
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "keyPair",
        "description": "user keyPair"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IdAssertion"
      ],
      "spread": false,
      "description": "IdAssertion"
    }
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "validateAssertion",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#validateAssertion",
    "access": null,
    "description": "Requests the IdpProxy from a given Domain to validate an IdentityAssertion\nReturns a promise with the result from the validation.",
    "lineNumber": 1060,
    "params": [
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "assertion",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "DOMString"
        ],
        "spread": false,
        "optional": false,
        "name": "origin",
        "description": "origin"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise         promise with the result from the validation"
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "encryptMessage",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#encryptMessage",
    "access": null,
    "description": null,
    "lineNumber": 1079,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "encryptDataObject",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#encryptDataObject",
    "access": null,
    "description": null,
    "lineNumber": 1215,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "dataObject",
        "types": [
          "*"
        ]
      },
      {
        "name": "sender",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "decryptMessage",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#decryptMessage",
    "access": null,
    "description": null,
    "lineNumber": 1257,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "decryptDataObject",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#decryptDataObject",
    "access": null,
    "description": null,
    "lineNumber": 1390,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "dataObject",
        "types": [
          "*"
        ]
      },
      {
        "name": "sender",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "doMutualAuthentication",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#doMutualAuthentication",
    "access": null,
    "description": null,
    "lineNumber": 1438,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "sender",
        "types": [
          "*"
        ]
      },
      {
        "name": "receiver",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "_doHandShakePhase",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_doHandShakePhase",
    "access": null,
    "description": null,
    "lineNumber": 1505,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "chatKeys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "_sendReporterSessionKey",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_sendReporterSessionKey",
    "access": null,
    "description": null,
    "lineNumber": 1903,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "chatKeys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "_getHypertyFromDataObject",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_getHypertyFromDataObject",
    "access": null,
    "description": "returns the reporter associated to the dataObject URL",
    "lineNumber": 1958,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "dataObjectURL",
        "description": "dataObject url"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "reporter              dataObject url reporter"
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "_filterMessageToHash",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_filterMessageToHash",
    "access": null,
    "description": "filter the messages to hash, by removing some fields not generated by the runtime core",
    "lineNumber": 2011,
    "params": [
      {
        "nullable": null,
        "types": [
          "Message"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "message"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "decryptedValue",
        "description": "(Optional)    value from body.value in case it originally comes encrypted"
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "identity(Optional)",
        "description": "add the hyperty identity associated in case is not added to the initial message"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": "new message filtered"
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_newChatCrypto",
    "memberof": "src/identity/IdentityModule.js~IdentityModule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/IdentityModule.js~IdentityModule#_newChatCrypto",
    "access": null,
    "description": "generates the initial structure for the keys between two users",
    "lineNumber": 2032,
    "params": [
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": "initial message that triggers the mutual authentication"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "userURL"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "receiver(Optional)",
        "description": "indicates if is the sender or the receiver that creates a new chat crypto"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": "newChatCrypto  new JSON structure for the chat crypto"
    }
  },
  {
    "__docId__": 165,
    "kind": "file",
    "name": "src/identity/OpenIdLib.js",
    "content": "//import hello from 'hellojs';\n\n/**\n*  class to facilitate the operations with the openID connect, through several Identity Providers\n*\n*/\nclass OpenIdLib {\n\n  constructor(identityProvider, clientID) {\n    let _this = this;\n    _this.clientID = clientID;\n    _this.identityProvider = identityProvider;\n\n    switch (identityProvider) {\n      case 'google':\n        let googleInfo = new GoogleInfo();\n        _this.info = googleInfo;\n        break;\n      case 'facebook':\n        let facebookInfo = new FacebookInfo();\n        _this.info = facebookInfo;\n        break;\n      case 'windows':\n        let microsoftInfo = new MicrosoftInfo();\n        _this.info = microsoftInfo;\n        break;\n      default:\n        break;\n    }\n  }\n\n  openPopup() {\n    let _this = this;\n\n    let REDIRECT   =   _this.info.REDIRECT;\n    let URL        =   _this.info.URL;\n\n    let acToken;\n    let tokenType;\n    let expiresIn;\n\n    return new Promise(function(resolve,reject) {\n\n      //function to parse the query string in the given URL to obatin certain values\n      function gup(url, name) {\n        name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\n        let regexS = '[\\\\#&?]' + name + '=([^&#]*)';\n        let regex = new RegExp(regexS);\n        let results = regex.exec(url);\n        if (results === null)\n        return '';\n        else\n        return results[1];\n      }\n\n      /*hello.init({google: '808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com',\n                 facebook: '655302667942219',\n                 windows: 'asdf197f6ad6-808f-4ddc-b725-3d8fe2660349'});\n      hello(_this.identityProvider).login({scope: 'email'}).then(function(token) {\n        console.log(token);\n        resolve(token.authResponse.access_token);\n      }, function(error) {\n        console.log('errorValidating ', error);\n        reject(error);\n      });*/\n\n      let win = window.open(URL, 'openIDrequest', 'width=800, height=600');\n      let pollTimer = window.setInterval(function() {\n        try {\n          //console.log(win.document.URL);\n\n          if (win.closed) {\n            reject('Some error occured.');\n            clearInterval(pollTimer);\n          }\n\n          let redirectURL = document.URL;//window.location.origin;\n          if (win.document.URL.indexOf('REDIRECT') !== -1 || win.document.URL.indexOf(redirectURL) !== -1) {\n            window.clearInterval(pollTimer);\n            let url =   win.document.URL;\n\n            //not working yet. Some problems with the 'POST' method\n            if (_this.identityProvider === 'windows') {\n              let code = gup(url, 'code');\n              let sessionState = gup(url, 'session_state');\n\n              let reqAccessURL = _this.info.TOKENEND + 'redirect_uri=' + _this.info.REDIRECT + '&grant_type=authorization_code' + '&client_id=' + _this.info.CLIENTID + '&code=' + code;\n\n              win.close();\n\n              let req = new XMLHttpRequest();\n              req.open('POST',  _this.info.TOKENEND, true);\n              req.setRequestHeader('Access-Control-Allow-Origin', '*');\n\n              let data = new FormData();\n              data.append('redirect_uri', _this.info.REDIRECT);\n              data.append('grant_type', 'authorization_code');\n              data.append('client_id', _this.info.CLIENTID);\n              data.append('code', code);\n\n              req.onreadystatechange = function(e) {\n                if (req.readyState === 4) {\n                  if (req.status === 200) {\n\n                    resolve('null');\n                  } else if (req.status === 400) {\n                    reject('There was an error processing the token');\n                  } else {\n                    reject('something else other than 200 was returned');\n                  }\n                }\n              };\n              req.send(data);\n\n            } else {\n\n              acToken =   gup(url, 'access_token');\n              tokenType = gup(url, 'token_type'); //FACEBOOK does not return tokenType in the field\n              expiresIn = gup(url, 'expires_in');\n\n              win.close();\n\n              if (_this.identityProvider === 'facebook') {\n                _this.info.VALIDURL = 'https://graph.facebook.com/debug_token?input_token=' + acToken + '&access_token=';\n              }\n\n              //after receiving the access token, google requires to validate first the token to prevent confused deputy problem.\n              resolve(acToken);\n            }\n          }\n        } catch (e) {\n          //console.log(e);\n        }\n      }, 1000);\n    });\n  }\n\n  validateToken(token) {\n    let _this = this;\n    let tokenID;\n    let VALIDURL = _this.info.VALIDURL;\n    return new Promise(function(resolve, reject) {\n      let req = new XMLHttpRequest();\n      req.open('GET', VALIDURL + token, true);\n\n      req.onreadystatechange = function(e) {\n        if (req.readyState === 4) {\n          if (req.status === 200) {\n            tokenID = JSON.parse(req.responseText);\n\n            resolve({token:token, tokenID: tokenID});\n          } else if (req.status === 400) {\n            reject('There was an error processing the token');\n          } else {\n            reject('something else other than 200 was returned');\n          }\n        }\n      };\n      req.send();\n\n    });\n  }\n\n  //function to exchange the access token with an ID Token containing the information\n  getInfoToken(token, tokenID) {\n    let _this = this;\n\n    return new Promise(function(resolve,reject) {\n      let USERINFURL =   _this.info.USERINFURL;\n\n      let req = new XMLHttpRequest();\n      req.open('GET', USERINFURL + token, true);\n\n      req.onreadystatechange = function(e) {\n        if (req.readyState === 4) {\n          if (req.status === 200) {\n            let infoToken = JSON.parse(req.responseText);\n            let email = infoToken.email;\n\n            //contruct the identityURL to be defined as in specification\n            // model: user://<idpdomain>/<user-identifier>\n            let identityURL = 'user://' + email.substring(email.indexOf('@') + 1, email.length) + '/' + email.substring(0, email.indexOf('@'));\n\n            //TODO remove later the 'token' field key\n            let identityBundle = {identity: identityURL, token: infoToken, accessToken: token, idToken: tokenID, infoToken: infoToken, idp: 'google'};\n\n            resolve(identityBundle);\n          } else if (req.status === 400) {\n            reject('There was an error processing the token');\n          } else {\n            reject('something else other than 200 was returned');\n          }\n        }\n      };\n      req.send();\n    });\n  }\n}\n\n//Google works fine with OpenID connect\nclass GoogleInfo {\n  constructor() {\n    let _this = this;\n    _this.OAUTHURL   =   'https://accounts.google.com/o/oauth2/auth?';\n    _this.SCOPE      =   'email%20profile';\n    _this.CLIENTID   =   '808329566012-tqr8qoh111942gd2kg007t0s8f277roi.apps.googleusercontent.com';\n    _this.REDIRECT   =    document.URL;\n    _this.TYPE       =   'token';\n    _this.VALIDURL   =   'https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=';\n    _this.USERINFURL =   'https://www.googleapis.com/oauth2/v1/userinfo?access_token=';\n\n    _this.URL        =   _this.OAUTHURL + 'scope=' + _this.SCOPE + '&client_id=' + _this.CLIENTID + '&redirect_uri=' + _this.REDIRECT + '&response_type=' + _this.TYPE;\n  }\n}\n\n//Facebook only provides the support for Oauth2 Tokens, and do not directly provide support for OpenID connect. So, no 'oficial' ID token can be requested, just information about the user.\nclass FacebookInfo {\n  constructor() {\n    let _this = this;\n    _this.OAUTHURL   =    'https://www.facebook.com/dialog/oauth?';\n    _this.CLIENTID   =    655302667942219;\n    _this.REDIRECT   =    document.URL; // 'http://localhost:8080/example/index.html';\n    _this.TYPE       =    'token';\n    _this.VALIDURL   =    'https://graph.facebook.com/debug_token?input_token='; //must be updated later\n    _this.USERINFURL = 'https://graph.facebook.com/v2.5/me?fields=id,name,email,picture&access_token=';\n    _this.URL        =    _this.OAUTHURL + 'client_id=' + _this.CLIENTID + '&redirect_uri=' + _this.REDIRECT + '&response_type=' + _this.TYPE;\n  }\n}\n\n\n//Microsoft is not yet implemented to obtain the Access token / ID token. Some troubles to request the Access token, since it is required to make a http Post request with the authorization code.\nclass MicrosoftInfo {\n  constructor() {\n    let _this = this;\n    _this.OAUTHURL   =    'https://login.microsoftonline.com/common/oauth2/authorize?';\n    _this.CLIENTID   =    '7e2f3589-4b38-4b1c-a321-c9251de00ef2';\n    _this.REDIRECT   =    document.URL;//'http%3A%2F%2Flocalhost%3A8080%2Fexample%2Findex%2Ehtml'\n    _this.TYPE       =    'code';\n\n    _this.TOKENEND   =    'https://login.microsoftonline.com/3fa4042c-7c4d-4382-aba8-fc8ec61103a4/oauth2/token';\n    _this.AUTHEND    =    'https://login.microsoftonline.com/3fa4042c-7c4d-4382-aba8-fc8ec61103a4/oauth2/authorize?';\n\n    _this.URL        =    _this.AUTHEND + 'response_type=' + _this.TYPE + '&client_id=' +\n    _this.CLIENTID ;//+ '&redirect_uri=' + _this.REDIRECT;\n  }\n\n}\n\nexport default OpenIdLib;\n",
    "static": true,
    "longname": "src/identity/OpenIdLib.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 166,
    "kind": "class",
    "name": "GoogleInfo",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~GoogleInfo",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/identity/OpenIdLib.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 167,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~GoogleInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~GoogleInfo#constructor",
    "access": null,
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 168,
    "kind": "class",
    "name": "FacebookInfo",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~FacebookInfo",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/identity/OpenIdLib.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 169,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~FacebookInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~FacebookInfo#constructor",
    "access": null,
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 170,
    "kind": "class",
    "name": "MicrosoftInfo",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~MicrosoftInfo",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/identity/OpenIdLib.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 232,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 171,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~MicrosoftInfo",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~MicrosoftInfo#constructor",
    "access": null,
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 172,
    "kind": "class",
    "name": "OpenIdLib",
    "memberof": "src/identity/OpenIdLib.js",
    "static": true,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/identity/OpenIdLib.js",
    "importStyle": "OpenIdLib",
    "description": " class to facilitate the operations with the openID connect, through several Identity Providers",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 173,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#constructor",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "identityProvider",
        "types": [
          "*"
        ]
      },
      {
        "name": "clientID",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "openPopup",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#openPopup",
    "access": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "validateToken",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#validateToken",
    "access": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "token",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "getInfoToken",
    "memberof": "src/identity/OpenIdLib.js~OpenIdLib",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/identity/OpenIdLib.js~OpenIdLib#getInfoToken",
    "access": null,
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "token",
        "types": [
          "*"
        ]
      },
      {
        "name": "tokenID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "file",
    "name": "src/syncher/DataObject.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport SyncObject, {ChangeType, ObjectType} from './ProxyObject';\nimport DataObjectChild from './DataObjectChild';\nimport {deepClone} from '../utils/utils.js';\n\n/**\n * Main extension class for observers and reporters, with common properties and methods.\n * Children management is common for observers and reporters.\n */\nclass DataObject {\n  /* private\n  _version: number\n\n  _owner: HypertyURL\n  _url: ObjectURL\n  _schema: Schema\n  _bus: MiniBus\n  _status: on | paused\n  _syncObj: SyncData\n\n  _children: { id: DataObjectChild }\n  _childrenListeners: [MsgListener]\n\n  ----event handlers----\n  _onAddChildHandler: (event) => void\n  */\n\n  /**\n   * @ignore\n   * Should not be used directly by Hyperties. It's called by the Syncher create or subscribe method's\n   */\n  //constructor(syncher, url, created, reporter, runtime, schema, name, initialStatus, initialData, childrens, mutual = true, resumed = false, description, tags, resources, observerStorage, publicObservation) {\n  constructor(input) {\n    let _this = this;\n\n    function throwMandatoryParmMissingError(par) {\n      throw '[DataObject] ' + par + ' mandatory parameter is missing';\n    }\n\n    input.syncher ? _this._syncher = input.syncher : throwMandatoryParmMissingError('syncher');\n    input.url ?  _this._url = input.url : throwMandatoryParmMissingError('url');\n    input.created ? _this._created = input.created : throwMandatoryParmMissingError('created');\n    input.reporter ? _this._reporter = input.reporter : throwMandatoryParmMissingError('reporter');\n    input.runtime ? _this._runtime = input.runtime : throwMandatoryParmMissingError('runtime');\n    input.schema ? _this._schema = input.schema : throwMandatoryParmMissingError('schema');\n    input.name ? _this._name = input.name : throwMandatoryParmMissingError('name');\n\n\n    _this._status = input.status;\n\n    if (input.data) {\n      _this._syncObj = new SyncObject(input.data);\n    } else {\n      _this._syncObj = new SyncObject({});\n    }\n    _this._childrens = input.childrens;\n\n    //TODO: For Further Study\n    _this._mutualAuthentication = input.mutual;\n\n    _this._version = 0;\n    _this._childId = 0;\n    _this._childrenListeners = [];\n\n    _this._resumed = input.resume;\n\n    if (input.resume) { _this._version = input.version; }\n\n    _this._owner = input.syncher._owner;\n    _this._bus = input.syncher._bus;\n\n    if (input.description) _this._description = input.description;\n    if (input.tags) _this._tags = input.tags;\n    if (input.resources) _this._resources = input.resources;\n    if (input.observerStorage) _this._observerStorage = input.observerStorage;\n    if (input.publicObservation) _this._publicObservation = input.publicObservation;\n\n    _this._metadata = Object.assign(input);\n    _this._metadata.lastModified = _this._metadata.created;\n\n    delete _this._metadata.data;\n    delete _this._metadata.syncher;\n    delete _this._metadata.authorise;\n\n  }\n\n  _getLastChildId() {\n    let _this = this;\n\n    let childIdInt = 0;\n    let childIdString = _this._owner + '#' + childIdInt;\n\n\n    Object.keys(_this._childrens).filter((key) => {\n      if (_this._childrens[key].childId > childIdString) {\n        childIdString = _this._childrens[key].childId;\n      }\n    });\n\n    return childIdInt = Number(childIdString.split('#')[1]);\n  }\n\n  _allocateListeners() {\n    let _this = this;\n\n    let childBaseURL = _this._url + '/children/';\n    console.log('[Data Object - AllocateListeners] - ', _this._childrens);\n    if (_this._childrens) {\n      _this._childrens.forEach((child) => {\n        let childURL = childBaseURL + child;\n        let listener = _this._bus.addListener(childURL, (msg) => {\n          //ignore msg sent by himself\n          if (msg.from !== this._owner) {\n            console.log('DataObject-Children-RCV: ', msg);\n            switch (msg.type) {\n              case 'create': _this._onChildCreate(msg); break;\n              case 'delete': console.log(msg); break;\n              default: _this._changeChildren(msg); break;\n            }\n          }\n        });\n\n        _this._childrenListeners.push(listener);\n      });\n    }\n  }\n\n  _releaseListeners() {\n    let _this = this;\n\n    _this._childrenListeners.forEach((listener) => {\n      listener.remove();\n    });\n\n    if (_this._childrenObjects) {\n      Object.keys(_this._childrenObjects).forEach((key) => {\n        _this._childrenObjects[key]._releaseListeners();\n      });\n    }\n  }\n\n\n    /**\n     *\n     */\n    resumeChildrens(childrens) {\n      let _this = this;\n\n      let childIdString = this._owner + '#' + this._childId;\n\n      if (childrens && !_this._childrenObjects) {\n        _this._childrenObjects = {};\n      }\n\n      //setup childrens data from subscription\n      Object.keys(childrens).forEach((childrenResource) => {\n        let children = childrens[childrenResource];\n\n        Object.keys(children).forEach((childId) => {\n          let childInput = children[childId].value;\n          console.log('[DataObject.resumeChildrens] new DataObjectChild: ', childrenResource, children, childInput);\n          childInput.parentObject = _this;\n          childInput.parent = _this._url;\n          _this._childrenObjects[childId] = new DataObjectChild(childInput);\n          _this._childrenObjects[childId].identity = children[childId].identity;\n\n          if (childId > childIdString) {\n            childIdString = childId;\n          }\n\n          console.log('[DataObjectReporter.resumeChildrens] - resumed: ', this._childrenObjects[childId]);\n        });\n      });\n\n      this._childId = Number(childIdString.split('#')[1]);\n    }\n\n    /**\n     * All Metadata about the Data Object\n     * @type {Object} -\n     */\n\n  get metadata() { return this._metadata; }\n\n  /**\n   * Object URL of reporter or observer\n   * @type {ObjectURL}\n   */\n  get url() { return this._url; }\n\n  /**\n   * Object schema URL (this field is not yet stable, and is subsject to change)\n   * @type {SchemaURL}\n   */\n  get schema() { return this._schema; }\n\n  /**\n   * Status of the reporter or observer connection (this field is not yet stable, and is subsject to change)\n   * @type {Status} - Enum of: on | paused\n   */\n  get status() { return this._status; }\n\n  /**\n   * Data structure to be synchronized.\n   * @type {JSON} - JSON structure that should follow the defined schema, if any.\n   */\n  get data() { return this._syncObj.data; }\n\n  /**\n   * All created children's since the subscription, doesn't contain all children's since reporter creation.\n   * @type {Object<ChildId, DataObjectChild>}\n   */\n  get childrens() { return this._childrenObjects; }\n\n  /**\n   * @ignore\n   */\n  pause() {\n    //TODO: this feature needs more analise\n    throw 'Not implemented';\n  }\n\n  /**\n   * @ignore\n   */\n  resume() {\n    //TODO: this feature needs more analise\n    throw 'Not implemented';\n  }\n\n  /**\n   * @ignore\n   */\n  stop() {\n    //TODO: should remove the subscription and send message unsubscribe?\n    throw 'Not implemented';\n  }\n\n  /**\n   * Create and add a DataObjectChild to a children collection.\n   * @param {String} children - Children name where the child is added.\n   * @param {JSON} initialData - Initial data of the child\n   * @param  {MessageBodyIdentity} identity - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.\n   * @param  {SyncChildMetadata} input - (optional) All additional metadata about the DataObjectChild.\n   * @return {Promise<DataObjectChild>} - Return Promise to a new DataObjectChild.\n   */\n\n  addChild(children, initialData, identity, input) {\n    let _this = this;\n\n    let childInput  = Object.assign({}, input);\n    //create new child unique ID, based on hypertyURL\n    _this._childId++;\n    childInput.url = _this._owner + '#' + _this._childId;\n    let msgChildPath = _this._url + '/children/' + children;\n\n    childInput.parentObject = _this;\n    childInput.data = initialData;\n    childInput.reporter = _this._owner;\n    childInput.created = (new Date).toISOString();\n    childInput.runtime = _this._runtime;\n    childInput.schema = _this._schema;\n    childInput.parent = _this.url;\n\n    let newChild = new DataObjectChild(childInput);\n\n\n    let bodyValue = newChild.metadata;\n    bodyValue.data = initialData;\n\n    //FLOW-OUT: this message will be sent directly to a resource child address: MessageBus\n    let requestMsg = {\n      type: 'create', from: _this._owner, to: msgChildPath,\n      body: { resource: childInput.url, value: bodyValue }\n    };\n\n    if (identity)      { requestMsg.body.identity = identity; }\n\n    //TODO: For Further Study\n    if (!_this._mutualAuthentication) requestMsg.body.mutualAuthentication = _this._mutualAuthentication;\n\n    console.log('[DataObject.addChild] added ', newChild);\n\n    //returns promise, in the future, the API may change to asynchronous call\n    return new Promise((resolve) => {\n      let msgId = _this._bus.postMessage(requestMsg);\n\n      newChild.onChange((event) => {\n        _this._onChange(event, { path: msgChildPath, childId: childInput.url });\n      });\n\n      if (!_this._childrenObjects) { _this._childrenObjects = {}; }\n\n      _this._childrenObjects[childInput.url] = newChild;\n\n      resolve(newChild);\n    });\n  }\n\n  /**\n   * Setup the callback to process create and delete of childrens.\n   * @param {function(event: MsgEvent)} callback\n   */\n  onAddChild(callback) {\n    this._onAddChildrenHandler = callback;\n  }\n\n  //FLOW-IN: message received from a remote DataObject -> addChild\n  _onChildCreate(msg) {\n    let _this = this;\n    let childInput = deepClone(msg.body.value);\n    childInput.parentObject = _this;\n\n    console.log('[DataObject._onChildCreate] receivedBy ' + _this._owner + ' : ', msg);\n    let newChild = new DataObjectChild(childInput);\n\n    if (!_this._childrenObjects) { _this._childrenObjects = {}; }\n\n    _this._childrenObjects[childInput.url] = newChild;\n\n    //todo: remove response below\n    setTimeout(() => {\n      //FLOW-OUT: will flow to DataObjectChild -> _onResponse\n      _this._bus.postMessage({\n        id: msg.id, type: 'response', from: msg.to, to: msg.from,\n        body: { code: 200, source: _this._owner }\n      });\n    });\n\n    let event = {\n      type: msg.type,\n      from: msg.from,\n      url: msg.to,\n      value: msg.body.value.data,\n      childId: childInput.url,\n      identity: msg.body.identity\n    };\n\n    if (_this._onAddChildrenHandler) {\n      console.log('ADD-CHILDREN-EVENT: ', event);\n      _this._onAddChildrenHandler(event);\n    }\n  }\n\n  //send delta messages to subscriptions\n  _onChange(event, childInfo) {\n    let _this = this;\n\n    _this._metadata.lastModified = (new Date).toISOString();\n\n    _this._version++;\n\n    if (_this._status === 'live') {\n      //FLOW-OUT: this message will be sent directly to a resource changes address: MessageBus\n      let changeMsg = {\n        type: 'update', from: _this._url, to: _this._url + '/changes',\n        body: { version: _this._version, source: _this._owner, attribute: event.field, lastModified: _this._metadata.lastModified }\n      };\n\n      console.log('[DataObject - _onChange] - ', event, childInfo, changeMsg);\n\n      if (event.oType === ObjectType.OBJECT) {\n        if (event.cType !== ChangeType.REMOVE) {\n          changeMsg.body.value = event.data;\n        }\n      } else {\n        changeMsg.body.attributeType = event.oType;\n        changeMsg.body.value = event.data;\n        if (event.cType !== ChangeType.UPDATE) {\n          changeMsg.body.operation = event.cType;\n        }\n      }\n\n      //childInfo must have (path, childId)\n      if (childInfo) {\n        changeMsg.to = childInfo.path;\n        changeMsg.body.resource = childInfo.childId;\n      }\n\n      //TODO: For Further Study\n      if (!_this._mutualAuthentication) changeMsg.body.mutualAuthentication = _this._mutualAuthentication;\n\n      _this._bus.postMessage(changeMsg);\n    }\n  }\n\n  //FLOW-IN: delta message received from a remote DataObjectReporter or DataObjectChild when changing data\n  _changeObject(syncObj, msg) {\n    let _this = this;\n\n    //TODO: update version ?\n    //how to handle an incorrect version ? Example: receive a version 3 when the observer is in version 1, where is the version 2 ?\n    //will we need to confirm the reception ?\n    if (_this._version + 1 === msg.body.version) {\n      _this._version++;\n      let path = msg.body.attribute;\n      let value = deepClone(msg.body.value);\n      let findResult = syncObj.findBefore(path);\n\n      if (msg.body.lastModified) {\n        _this._metadata.lastModified = msg.body.lastModified;\n      } else {\n        _this._metadata.lastModified = (new Date).toISOString();\n      }\n\n      if (msg.body.attributeType === ObjectType.ARRAY) {\n        if (msg.body.operation === ChangeType.ADD) {\n          let arr = findResult.obj;\n          let index = findResult.last;\n          Array.prototype.splice.apply(arr, [index, 0].concat(value));\n        } else if (msg.body.operation === ChangeType.REMOVE) {\n          let arr = findResult.obj;\n          let index = findResult.last;\n          arr.splice(index, value);\n        } else {\n          findResult.obj[findResult.last] = value; // UPDATE\n        }\n      } else {\n        if (msg.body.value) {\n          findResult.obj[findResult.last] = value; // UPDATE or ADD\n        } else {\n          delete findResult.obj[findResult.last]; // REMOVE\n        }\n      }\n    } else {\n      //TODO: how to handle unsynchronized versions?\n      console.log('UNSYNCHRONIZED VERSION: (data => ' + _this._version + ', msg => ' + msg.body.version + ')');\n    }\n  }\n\n  //FLOW-IN: message received from a remote DataObjectChild when changing data\n  _changeChildren(msg) {\n    let _this = this;\n    console.log('Change children: ', _this._owner, msg);\n\n    let childId = msg.body.resource;\n    let children = _this._childrenObjects[childId];\n\n    if (children) {\n      _this._changeObject(children._syncObj, msg);\n    } else {\n      console.log('No children found for: ', childId);\n    }\n  }\n\n}\n\nexport default DataObject;\n",
    "static": true,
    "longname": "src/syncher/DataObject.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 178,
    "kind": "class",
    "name": "DataObject",
    "memberof": "src/syncher/DataObject.js",
    "static": true,
    "longname": "src/syncher/DataObject.js~DataObject",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/DataObject.js",
    "importStyle": "DataObject",
    "description": "Main extension class for observers and reporters, with common properties and methods.\nChildren management is common for observers and reporters.",
    "lineNumber": 32,
    "interface": false
  },
  {
    "__docId__": 179,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#constructor",
    "access": null,
    "description": "",
    "lineNumber": 55,
    "ignore": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "_getLastChildId",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_getLastChildId",
    "access": null,
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "_allocateListeners",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_allocateListeners",
    "access": null,
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 150,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "resumeChildrens",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#resumeChildrens",
    "access": null,
    "description": "",
    "lineNumber": 168,
    "params": [
      {
        "name": "childrens",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "_childId",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_childId",
    "access": null,
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "get",
    "name": "metadata",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#metadata",
    "access": null,
    "description": "All Metadata about the Data Object",
    "lineNumber": 205,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 186,
    "kind": "get",
    "name": "url",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#url",
    "access": null,
    "description": "Object URL of reporter or observer",
    "lineNumber": 211,
    "type": {
      "nullable": null,
      "types": [
        "ObjectURL"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 187,
    "kind": "get",
    "name": "schema",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#schema",
    "access": null,
    "description": "Object schema URL (this field is not yet stable, and is subsject to change)",
    "lineNumber": 217,
    "type": {
      "nullable": null,
      "types": [
        "SchemaURL"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 188,
    "kind": "get",
    "name": "status",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#status",
    "access": null,
    "description": "Status of the reporter or observer connection (this field is not yet stable, and is subsject to change)",
    "lineNumber": 223,
    "type": {
      "nullable": null,
      "types": [
        "Status"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 189,
    "kind": "get",
    "name": "data",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#data",
    "access": null,
    "description": "Data structure to be synchronized.",
    "lineNumber": 229,
    "type": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 190,
    "kind": "get",
    "name": "childrens",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#childrens",
    "access": null,
    "description": "All created children's since the subscription, doesn't contain all children's since reporter creation.",
    "lineNumber": 235,
    "type": {
      "nullable": null,
      "types": [
        "Object<ChildId, DataObjectChild>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "pause",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#pause",
    "access": null,
    "description": "",
    "lineNumber": 240,
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "resume",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#resume",
    "access": null,
    "description": "",
    "lineNumber": 248,
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "stop",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#stop",
    "access": null,
    "description": "",
    "lineNumber": 256,
    "ignore": true,
    "params": []
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "addChild",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#addChild",
    "access": null,
    "description": "Create and add a DataObjectChild to a children collection.",
    "lineNumber": 270,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "children",
        "description": "Children name where the child is added."
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "initialData",
        "description": "Initial data of the child"
      },
      {
        "nullable": null,
        "types": [
          "MessageBodyIdentity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "(optional) identity data to be added to identity the user reporter. To be used for legacy identities."
      },
      {
        "nullable": null,
        "types": [
          "SyncChildMetadata"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "(optional) All additional metadata about the DataObjectChild."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DataObjectChild>"
      ],
      "spread": false,
      "description": "Return Promise to a new DataObjectChild."
    }
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "onAddChild",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#onAddChild",
    "access": null,
    "description": "Setup the callback to process create and delete of childrens.",
    "lineNumber": 326,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "_onAddChildrenHandler",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_onAddChildrenHandler",
    "access": null,
    "description": null,
    "lineNumber": 327,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "_onChildCreate",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_onChildCreate",
    "access": null,
    "description": null,
    "lineNumber": 331,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "_onChange",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_onChange",
    "access": null,
    "description": null,
    "lineNumber": 368,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      },
      {
        "name": "childInfo",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "_changeObject",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_changeObject",
    "access": null,
    "description": null,
    "lineNumber": 410,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "syncObj",
        "types": [
          "*"
        ]
      },
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "_changeChildren",
    "memberof": "src/syncher/DataObject.js~DataObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObject.js~DataObject#_changeChildren",
    "access": null,
    "description": null,
    "lineNumber": 454,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 201,
    "kind": "file",
    "name": "src/syncher/DataObjectChild.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport SyncObject from './ProxyObject';\n//import { deepClone } from '../utils/utils.js';\n\n/**\n * The class returned from the DataObject addChildren call or from onAddChildren if remotely created.\n */\nclass DataObjectChild /* implements SyncStatus */ {\n  /* private\n\n  ----event handlers----\n  _onResponseHandler: (event) => void\n  */\n\n  /**\n   * @ignore\n   * Should not be used directly by Hyperties. It's called by the DataObject.addChildren\n   */\n  constructor(input) {\n    let _this = this;\n\n    function throwMandatoryParmMissingError(par) {\n      throw '[DataObjectChild] ' + par + ' mandatory parameter is missing';\n    }\n\n    input.parent ?  _this._parent = input.parent : throwMandatoryParmMissingError('parent');\n    input.url ?  _this._url = input.url : throwMandatoryParmMissingError('url');\n    input.created ? _this._created = input.created : throwMandatoryParmMissingError('created');\n    input.reporter ? _this._reporter = input.reporter : throwMandatoryParmMissingError('reporter');\n    input.runtime ? _this._runtime = input.runtime : throwMandatoryParmMissingError('runtime');\n    input.schema ? _this._schema = input.schema : throwMandatoryParmMissingError('schema');\n    input.parentObject ? _this._parentObject = input.parentObject : throwMandatoryParmMissingError('parentObject');\n\n    if (input.name) _this._name = input.name;\n    if (input.description) _this._description = input.description;\n    if (input.tags) _this._tags = input.tags;\n    if (input.resources) _this._resources = input.resources;\n    if (input.observerStorage) _this._observerStorage = input.observerStorage;\n    if (input.publicObservation) _this._publicObservation = input.publicObservation;\n\n    if (input.data) {\n      _this._syncObj = new SyncObject(input.data);\n    } else {\n      _this._syncObj = new SyncObject({});\n    }\n\n    console.log('[DataObjectChild -  Constructor] - ', _this._syncObj);\n\n    _this._bus = _this._parentObject._bus;\n    _this._owner = _this._parentObject._owner;\n\n    _this._allocateListeners();\n\n    _this._metadata = input;\n\n    delete _this._metadata.data;\n    delete _this._metadata.parentObject;\n\n  }\n\n  _allocateListeners() {\n    let _this = this;\n\n    //this is only needed for children reporters\n    if (_this._reporter === _this._owner) {\n      _this._listener = _this._bus.addListener(_this._reporter, (msg) => {\n        if (msg.type === 'response' && msg.id === _this._msgId) {\n          console.log('DataObjectChild.onResponse:', msg);\n          _this._onResponse(msg);\n        }\n      });\n    }\n  }\n\n  _releaseListeners() {\n    let _this = this;\n\n    if (_this._listener) {\n      _this._listener.remove();\n    }\n  }\n\n  /**\n   * Release and delete object data\n   */\n  delete() {\n    let _this = this;\n\n\n    _this._releaseListeners();\n\n    //TODO: send delete message ?\n  }\n\n  /**\n   * All Metadata about the Child Data Object\n   * @type {Object} -\n   */\n  get metadata() { return this._metadata; }\n\n  /**\n   * Children ID generated on addChildren. Unique identifier\n   * @type {URL} - URL of the format <HypertyURL>#<numeric-sequence>\n   */\n  get childId() { return this._childId; }\n\n  /**\n   * Data Structure to be synchronized.\n   * @type {JSON} - JSON structure that should follow the defined schema, if any.\n   */\n  get data() { return this._syncObj.data; }\n\n  /**\n   * Set for this dataObjectChild an identity\n   * @method identity\n   * @param  {Identity} identity identity from who created the message\n   */\n  set identity(identity) { this._identity = identity; }\n\n  /**\n   * Get for this dataObjectChild an identity\n   * @method identity\n   * @return {Identity} identity from who created the message\n   */\n  get identity() { return this._identity; }\n\n  /**\n   * Register the change listeners sent by the reporter child\n   * @param {function(event: MsgEvent)} callback\n   */\n  onChange(callback) {\n    this._syncObj.observe((event) => {\n      console.log('[DataObjectChild - observer] - ', event);\n      callback(event);\n    });\n  }\n\n  /**\n   * Setup the callback to process response notifications of the creates\n   * @param {function(event: MsgEvent)} callback\n   */\n  onResponse(callback) {\n    this._onResponseHandler = callback;\n  }\n\n  //FLOW-IN: message received from a remote DataObject -> _onChildCreate\n  _onResponse(msg) {\n    let _this = this;\n\n    let event = {\n      type: msg.type,\n      url: msg.body.source,\n      code: msg.body.code\n    };\n\n    if (_this._onResponseHandler) {\n      _this._onResponseHandler(event);\n    }\n  }\n\n}\n\nexport default DataObjectChild;\n",
    "static": true,
    "longname": "src/syncher/DataObjectChild.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 202,
    "kind": "class",
    "name": "DataObjectChild",
    "memberof": "src/syncher/DataObjectChild.js",
    "static": true,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/DataObjectChild.js",
    "importStyle": "DataObjectChild",
    "description": "The class returned from the DataObject addChildren call or from onAddChildren if remotely created.",
    "lineNumber": 30,
    "interface": false
  },
  {
    "__docId__": 203,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#constructor",
    "access": null,
    "description": "",
    "lineNumber": 41,
    "ignore": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "_allocateListeners",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#_allocateListeners",
    "access": null,
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "delete",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#delete",
    "access": null,
    "description": "Release and delete object data",
    "lineNumber": 108,
    "params": []
  },
  {
    "__docId__": 207,
    "kind": "get",
    "name": "metadata",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#metadata",
    "access": null,
    "description": "All Metadata about the Child Data Object",
    "lineNumber": 121,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 208,
    "kind": "get",
    "name": "childId",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#childId",
    "access": null,
    "description": "Children ID generated on addChildren. Unique identifier",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "URL"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 209,
    "kind": "get",
    "name": "data",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#data",
    "access": null,
    "description": "Data Structure to be synchronized.",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "JSON"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 210,
    "kind": "set",
    "name": "identity",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#identity",
    "access": null,
    "description": "Set for this dataObjectChild an identity",
    "lineNumber": 140,
    "unknown": [
      {
        "tagName": "@method",
        "tagValue": "identity"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Identity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "identity from who created the message"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "member",
    "name": "_identity",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#_identity",
    "access": null,
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "get",
    "name": "identity",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#identity",
    "access": null,
    "description": "Get for this dataObjectChild an identity",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@method",
        "tagValue": "identity"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Identity"
      ],
      "spread": false,
      "description": "identity from who created the message"
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "onChange",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#onChange",
    "access": null,
    "description": "Register the change listeners sent by the reporter child",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "onResponse",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#onResponse",
    "access": null,
    "description": "Setup the callback to process response notifications of the creates",
    "lineNumber": 164,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "_onResponseHandler",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#_onResponseHandler",
    "access": null,
    "description": null,
    "lineNumber": 165,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "_onResponse",
    "memberof": "src/syncher/DataObjectChild.js~DataObjectChild",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectChild.js~DataObjectChild#_onResponse",
    "access": null,
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 217,
    "kind": "file",
    "name": "src/syncher/DataObjectObserver.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport { deepClone } from '../utils/utils';\nimport SyncObject, {ChangeType, ObjectType} from './ProxyObject';\n\nimport DataObject from './DataObject';\nimport DataObjectChild from './DataObjectChild';\n\nlet FilterType = {ANY: 'any', START: 'start', EXACT: 'exact'};\n\n/**\n * The class returned from the Syncher subscribe call.\n * To be used as an observation point from a DataObjectReporter change.\n */\nclass DataObjectObserver extends DataObject /* implements SyncStatus */ {\n  /* private\n  _changeListener: MsgListener\n\n  ----event handlers----\n  _filters: {<filter>: {type: <start, exact>, callback: <function>} }\n  */\n\n  /**\n   * @ignore\n   * Should not be used directly by Hyperties. It's called by the Syncher.subscribe method\n   */\n\n  //TODO: For Further Study\n  constructor(input) {\n    //todo: check why\n    //input.initialData = input.initialData.data;\n\n    super(input);\n\n    let _this = this;\n\n    _this._version = input.version;\n    _this._filters = {};\n\n    _this._syncObj.observe((event) => {\n      _this._onFilter(event);\n    });\n\n\n    _this._allocateListeners();\n  }\n\n  /**\n   * Sync Data Object Observer with last version of Data Object Reporter. Useful for Resumes\n   */\n  sync() {\n\n    let _this = this;\n    console.info('[DataObjectObserver_sync] synchronising ');\n\n    _this._syncher.read(_this._metadata.url).then((value)=>{\n      console.info('[DataObjectObserver_sync] value to sync: ', value);\n\n      if (value.version != _this._version) {\n        console.info('[DataObjectObserver_sync] updating existing data: ', _this.data);\n\n        Object.assign(_this.data || {}, deepClone(value.data));\n\n        _this._metadata = deepClone(value);\n\n        delete _this._metadata.data;\n\n        _this._version = value.version;\n      }\n\n    }).catch((reason) => {\n      console.info('[DataObjectObserver_sync] sync failed: ', reason);\n    });\n\n  }\n\n  _allocateListeners() {\n    super._allocateListeners();\n    let _this = this;\n\n    _this._changeListener = _this._bus.addListener(_this._url + '/changes', (msg) => {\n      if (msg.type === 'update') {\n        console.log('DataObjectObserver-' + _this._url + '-RCV: ', msg);\n        _this._changeObject(_this._syncObj, msg);\n      }\n    });\n  }\n\n  _releaseListeners() {\n    super._releaseListeners();\n    let _this = this;\n\n    _this._changeListener.remove();\n  }\n\n  /**\n   * Release and delete object data\n   */\n  delete() {\n    let _this = this;\n\n    _this._releaseListeners();\n    delete _this._syncher._observers[_this._url];\n  }\n\n  /**\n   * Release and delete object data\n   */\n  unsubscribe() {\n    let _this = this;\n\n    //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onLocalUnSubscribe\n    let unSubscribeMsg = {\n      type: 'unsubscribe', from: _this._owner, to: _this._syncher._subURL,\n      body: { resource: _this._url }\n    };\n\n    _this._bus.postMessage(unSubscribeMsg, (reply) => {\n      console.log('DataObjectObserver-UNSUBSCRIBE: ', reply);\n      if (reply.body.code === 200) {\n        _this._releaseListeners();\n        delete _this._syncher._observers[_this._url];\n      }\n    });\n  }\n\n  /**\n   * Register the change listeners sent by the reporter\n   * @param {string} filter - Filter that identifies the field (separated dot path). Accepts * at the end for a more unrestricted filtering.\n   * @param {function(event: MsgEvent)} callback\n   */\n  onChange(filter, callback) {\n    let key = filter;\n    let filterObj = {\n      type: FilterType.EXACT,\n      callback: callback\n    };\n\n    let idx = filter.indexOf('*');\n    if (idx === filter.length - 1) {\n      if (idx === 0) {\n        filterObj.type = FilterType.ANY;\n      } else {\n        filterObj.type = FilterType.START;\n        key = filter.substr(0, filter.length - 1);\n      }\n    }\n\n    this._filters[key] = filterObj;\n  }\n\n  _onFilter(event) {\n    let _this = this;\n\n    Object.keys(_this._filters).forEach((key) => {\n      let filter = _this._filters[key];\n      if (filter.type === FilterType.ANY) {\n        //match anything\n        filter.callback(event);\n      } else if (filter.type === FilterType.START) {\n        //if starts with filter...\n        if (event.field.indexOf(key) === 0) {\n          filter.callback(event);\n        }\n      } else if (filter.type === FilterType.EXACT) {\n        //exact match\n        if (event.field === key) {\n          filter.callback(event);\n        }\n      }\n    });\n  }\n}\n\nexport default DataObjectObserver;\n",
    "static": true,
    "longname": "src/syncher/DataObjectObserver.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 218,
    "kind": "variable",
    "name": "FilterType",
    "memberof": "src/syncher/DataObjectObserver.js",
    "static": true,
    "longname": "src/syncher/DataObjectObserver.js~FilterType",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/syncher/DataObjectObserver.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"ANY\": string, \"START\": string, \"EXACT\": string}"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "class",
    "name": "DataObjectObserver",
    "memberof": "src/syncher/DataObjectObserver.js",
    "static": true,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/DataObjectObserver.js",
    "importStyle": "DataObjectObserver",
    "description": "The class returned from the Syncher subscribe call.\nTo be used as an observation point from a DataObjectReporter change.",
    "lineNumber": 36,
    "interface": false,
    "extends": [
      "src/syncher/DataObject.js~DataObject"
    ]
  },
  {
    "__docId__": 220,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#constructor",
    "access": null,
    "description": "",
    "lineNumber": 50,
    "ignore": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "sync",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#sync",
    "access": null,
    "description": "Sync Data Object Observer with last version of Data Object Reporter. Useful for Resumes",
    "lineNumber": 72,
    "params": []
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "_allocateListeners",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#_allocateListeners",
    "access": null,
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "delete",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#delete",
    "access": null,
    "description": "Release and delete object data",
    "lineNumber": 120,
    "params": []
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "unsubscribe",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#unsubscribe",
    "access": null,
    "description": "Release and delete object data",
    "lineNumber": 130,
    "params": []
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "onChange",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#onChange",
    "access": null,
    "description": "Register the change listeners sent by the reporter",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filter",
        "description": "Filter that identifies the field (separated dot path). Accepts * at the end for a more unrestricted filtering."
      },
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "_onFilter",
    "memberof": "src/syncher/DataObjectObserver.js~DataObjectObserver",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectObserver.js~DataObjectObserver#_onFilter",
    "access": null,
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 228,
    "kind": "file",
    "name": "src/syncher/DataObjectReporter.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport DataObject from './DataObject';\n\nimport DataObjectChild from './DataObjectChild';\n\nimport { deepClone } from '../utils/utils.js';\n\n/**\n * The class returned from the Syncher create call.\n * To be used as a reporter point, changes will be submited to DataObjectObserver instances.\n */\nclass DataObjectReporter extends DataObject /* implements SyncStatus */ {\n  /* private\n  _subscriptions: <hypertyUrl: { status: string } }>\n\n  ----event handlers----\n  _onSubscriptionHandler: (event) => void\n  _onResponseHandler: (event) => void\n  _onReadHandler: (event) => void\n  */\n\n  /**\n   * @ignore\n   * Should not be used directly by Hyperties. It's called by the Syncher.create method\n   */\n\n   //constructor(syncher, url, created, reporter, runtime, schema, name, initialStatus, initialData, childrens, mutual = true, resumed = false, description, tags, resources, observerStorage, publicObservation) {\n  constructor(input) {\n\n    super(input);\n    let _this = this;\n\n    _this._subscriptions = {};\n\n    _this._syncObj.observe((event) => {\n      console.log('[Syncher.DataObjectReporter] ' + _this.url + ' publish change: ', event);\n      _this._onChange(event);\n    });\n\n    _this._allocateListeners();\n  }\n\n  _allocateListeners() {\n    super._allocateListeners();\n    let _this = this;\n\n    _this._objectListener = _this._bus.addListener(_this._url, (msg) => {\n      console.log('[Syncher.DataObjectReporter] listener ' + _this._url + ' Received: ', msg);\n      switch (msg.type) {\n        case 'response': _this._onResponse(msg); break;\n        case 'read': _this._onRead(msg); break;\n      }\n    });\n  }\n\n  _releaseListeners() {\n    super._releaseListeners();\n    let _this = this;\n\n    _this._objectListener.remove();\n  }\n\n  /**\n   * Send invitations (create messages) to hyperties, observers list.\n   * @param  {HypertyURL[]} observers List of Hyperty URL's\n   */\n  inviteObservers(observers) {\n    let _this = this;\n\n    //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onCreate\n    // TODO: remove value and add resources? should similar to 1st create\n    let inviteMsg = {\n      type: 'create', from: _this._syncher._owner, to: _this._syncher._subURL,\n      body: { resume: false, resource: _this._url, schema: _this._schema, value: _this._metadata, authorise: observers }\n    };\n\n    _this._bus.postMessage(inviteMsg);\n  }\n\n  /**\n   * Release and delete object data\n   */\n  delete() {\n    let _this = this;\n\n    //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onDelete\n    let deleteMsg = {\n      type: 'delete', from: _this._owner, to: _this._syncher._subURL,\n      body: { resource: _this._url }\n    };\n\n    _this._bus.postMessage(deleteMsg, (reply) => {\n      console.log('DataObjectReporter-DELETE: ', reply);\n      if (reply.body.code === 200) {\n        _this._releaseListeners();\n        delete _this._syncher._reporters[_this._url];\n\n        _this._syncObj = {};\n      }\n    });\n  }\n\n  /**\n   * Subscriptions requested and accepted to this reporter\n   * @type {Object<HypertyURL, SyncSubscription>}\n   */\n  get subscriptions() { return this._subscriptions; }\n\n  /**\n   * Setup the callback to process subscribe and unsubscribe notifications\n   * @param {function(event: MsgEvent)} callback function to receive events\n   */\n  onSubscription(callback) {\n    this._onSubscriptionHandler = callback;\n  }\n\n  /**\n   * Setup the callback to process response notifications of the create's\n   * @param {function(event: MsgEvent)} callback function to receive events\n   */\n  onResponse(callback) {\n    this._onResponseHandler = callback;\n  }\n\n  /**\n   * Setup the callback to process read notifications\n   * @param {function(event: MsgEvent)} callback\n   */\n  onRead(callback) {\n    this._onReadHandler = callback;\n  }\n\n  //FLOW-IN: message received from parent Syncher -> _onForward\n  _onForward(msg) {\n    let _this = this;\n\n    console.log('DataObjectReporter-RCV: ', msg);\n    switch (msg.body.type) {\n      case 'subscribe': _this._onSubscribe(msg); break;\n      case 'unsubscribe': _this._onUnSubscribe(msg); break;\n    }\n  }\n\n  //FLOW-IN: message received from this -> _onForward: emitted by a remote Syncher -> subscribe\n  _onSubscribe(msg) {\n    let _this = this;\n    let hypertyUrl = msg.body.from;\n    console.log('[DataObjectReporter._onSubscribe]', msg);\n\n    let event = {\n      type: msg.body.type,\n      url: hypertyUrl,\n\n      identity: msg.body.identity,\n\n      accept: () => {\n        //create new subscription\n        let sub = { url: hypertyUrl, status: 'live' };\n        _this._subscriptions[hypertyUrl] = sub;\n        if (_this.metadata.subscriptions) { _this.metadata.subscriptions.push(sub.url); }\n\n        let msgValue = _this._metadata;\n        msgValue.data = deepClone(_this.data);\n        msgValue.version = _this._version;\n\n        //process and send childrens data\n        let childrenValues = {};\n\n        if (_this._childrenObjects) {\n          Object.keys(_this._childrenObjects).forEach((childrenId) => {\n            let childrenData = _this._childrenObjects[childrenId].data;\n            childrenValues[childrenId] = deepClone(childrenData);\n          });\n          msgValue.childrenObjects = childrenValues;\n        }\n\n        let sendMsg = {\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\n          body: { code: 200, schema: _this._schema, value: msgValue }\n        };\n\n        //TODO: For Further Study\n        if (msg.body.hasOwnProperty('mutualAuthentication') && !msg.body.mutualAuthentication) {\n          sendMsg.body.mutualAuthentication = this._mutualAuthentication;\n          this._mutualAuthentication = msg.body.mutualAuthentication;\n        }\n\n        //send ok response message\n        _this._bus.postMessage(sendMsg);\n\n        return sub;\n      },\n\n      reject: (reason) => {\n        //send reject response message\n        _this._bus.postMessage({\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\n          body: { code: 403, desc: reason }\n        });\n      }\n    };\n\n    if (_this._onSubscriptionHandler) {\n      console.log('SUBSCRIPTION-EVENT: ', event);\n      _this._onSubscriptionHandler(event);\n    }\n  }\n\n  //FLOW-IN: message received from this -> _onForward: emitted by a remote DataObjectObserver -> unsubscribe\n  _onUnSubscribe(msg) {\n    let _this = this;\n    let hypertyUrl = msg.body.from;\n\n    //let sub = _this._subscriptions[hypertyUrl];\n    delete _this._subscriptions[hypertyUrl];\n\n    let event = {\n      type: msg.body.type,\n      url: hypertyUrl,\n      identity: msg.body.identity\n    };\n\n    if (_this._onSubscriptionHandler) {\n      console.log('UN-SUBSCRIPTION-EVENT: ', event);\n      _this._onSubscriptionHandler(event);\n    }\n  }\n\n  //FLOW-IN: message received from ReporterURL address: emited by a remote Syncher -> _onRemoteCreate -> event.ack\n  _onResponse(msg) {\n    let _this = this;\n\n    let event = {\n      type: msg.type,\n      url: msg.from,\n      code: msg.body.code\n    };\n\n    if (_this._onResponseHandler) {\n      console.log('RESPONSE-EVENT: ', event);\n      _this._onResponseHandler(event);\n    }\n  }\n\n  //FLOW-IN: message received from ReporterURL address: emited by a remote Syncher -> read\n  _onRead(msg) {\n    let _this = this;\n    let objectValue = deepClone(_this.metadata);\n    objectValue.data = deepClone(_this.data);\n    objectValue.version = _this._version;\n\n    let response = {\n      id: msg.id, type: 'response', from: msg.to, to: msg.from,\n      body: { code: 200, value: objectValue }\n    };\n\n    let event = {\n      type: msg.type,\n      url: msg.from,\n\n      accept: () => {\n        _this._bus.postMessage(response);\n      },\n\n      reject: (reason) => {\n        _this._bus.postMessage({\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\n          body: { code: 401, desc: reason }\n        });\n      }\n    };\n\n    // if the requester is an authorised observer, the data object is responded otherwise an event is triggered\n    let subscriptions = [];\n\n    if (_this.metadata.subscriptions) {\n      subscriptions = _this.metadata.subscriptions;\n    } else if (_this._subscriptions) {\n      subscriptions = Object.keys(_this._subscriptions).map(function(key) { return _this._subscriptions[key]; });\n    }\n\n    if (subscriptions.indexOf(msg.from) != -1) {\n      _this._bus.postMessage(response);\n    } else if (_this._onReadHandler) {\n      console.log('READ-EVENT: ', event);\n      _this._onReadHandler(event);\n    }\n  }\n\n}\n\nexport default DataObjectReporter;\n",
    "static": true,
    "longname": "src/syncher/DataObjectReporter.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 229,
    "kind": "class",
    "name": "DataObjectReporter",
    "memberof": "src/syncher/DataObjectReporter.js",
    "static": true,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/DataObjectReporter.js",
    "importStyle": "DataObjectReporter",
    "description": "The class returned from the Syncher create call.\nTo be used as a reporter point, changes will be submited to DataObjectObserver instances.",
    "lineNumber": 34,
    "interface": false,
    "extends": [
      "src/syncher/DataObject.js~DataObject"
    ]
  },
  {
    "__docId__": 230,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#constructor",
    "access": null,
    "description": "",
    "lineNumber": 50,
    "ignore": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "_allocateListeners",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_allocateListeners",
    "access": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "inviteObservers",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#inviteObservers",
    "access": null,
    "description": "Send invitations (create messages) to hyperties, observers list.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "HypertyURL[]"
        ],
        "spread": false,
        "optional": false,
        "name": "observers",
        "description": "List of Hyperty URL's"
      }
    ]
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "delete",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#delete",
    "access": null,
    "description": "Release and delete object data",
    "lineNumber": 105,
    "params": []
  },
  {
    "__docId__": 235,
    "kind": "get",
    "name": "subscriptions",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#subscriptions",
    "access": null,
    "description": "Subscriptions requested and accepted to this reporter",
    "lineNumber": 129,
    "type": {
      "nullable": null,
      "types": [
        "Object<HypertyURL, SyncSubscription>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "onSubscription",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#onSubscription",
    "access": null,
    "description": "Setup the callback to process subscribe and unsubscribe notifications",
    "lineNumber": 135,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "function to receive events"
      }
    ]
  },
  {
    "__docId__": 237,
    "kind": "member",
    "name": "_onSubscriptionHandler",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onSubscriptionHandler",
    "access": null,
    "description": null,
    "lineNumber": 136,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "onResponse",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#onResponse",
    "access": null,
    "description": "Setup the callback to process response notifications of the create's",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "function to receive events"
      }
    ]
  },
  {
    "__docId__": 239,
    "kind": "member",
    "name": "_onResponseHandler",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onResponseHandler",
    "access": null,
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "onRead",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#onRead",
    "access": null,
    "description": "Setup the callback to process read notifications",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 241,
    "kind": "member",
    "name": "_onReadHandler",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onReadHandler",
    "access": null,
    "description": null,
    "lineNumber": 152,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "_onForward",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onForward",
    "access": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "_onSubscribe",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "_mutualAuthentication",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_mutualAuthentication",
    "access": null,
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "_onUnSubscribe",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onUnSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 232,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 246,
    "kind": "method",
    "name": "_onResponse",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onResponse",
    "access": null,
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 247,
    "kind": "method",
    "name": "_onRead",
    "memberof": "src/syncher/DataObjectReporter.js~DataObjectReporter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataObjectReporter.js~DataObjectReporter#_onRead",
    "access": null,
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 248,
    "kind": "file",
    "name": "src/syncher/DataProvisional.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n * @access private\n * This class is responsible for collecting delta changes in remote objects, before the response of subscription reach the observer.\n * It's used in Syncher -> subscribe. The flow is defined as:\n * 1. (observer) --subscribe--> (reporter)\n * 2. (observer) <--delta updates-- (reporter)\n * 3. (observer) <--subscribe response-- (reporter)\n * This means that there could be delta updates transferred before the subscription confirmation.\n * Since there is no DataObjectObserver before the ubscription confirmation, there should be some other object collecting the updates.\n * Provisional data is applied to the DataObjectObserver after confirmation. Or discarded if there is no confirmation.\n */\nclass DataProvisional {\n  /* private\n  _childrenListeners: [MsgListener]\n  _listener: MsgListener\n\n  _changes: []\n  */\n\n  constructor(owner, url, bus, children) {\n    let _this = this;\n\n    _this._owner = owner;\n    _this._url = url;\n    _this._bus = bus;\n    _this._children = children;\n\n    _this._changes = [];\n    _this._allocateListeners();\n  }\n\n  _allocateListeners() {\n    let _this = this;\n\n    _this._listener = _this._bus.addListener(_this._url, (msg) => {\n      console.log('DataProvisional-' + _this._url + '-RCV: ', msg);\n      _this._changes.push(msg);\n    });\n\n    /*\n    _this._childrenListeners = [];\n    if (_this._children) {\n      let childBaseURL = url + '/children/';\n      _this._children.forEach((child) => {\n        let childURL = childBaseURL + child;\n        let listener = _this._bus.addListener(childURL, (msg) => {\n          //ignore msg sent by himself\n          if (msg.from !== owner) {\n            console.log(msg);\n          }\n        });\n\n        _this._childrenListeners.push(listener);\n      });\n    }*/\n  }\n\n  _releaseListeners() {\n    let _this = this;\n\n    _this._listener.remove();\n\n    /*_this._childrenListeners.forEach((listener) => {\n      listener.remove();\n    });*/\n  }\n\n  get children() { return this._children; }\n\n  apply(observer) {\n    let _this = this;\n    _this._changes.forEach((change) => {\n      observer._changeObject(observer._syncObj, change);\n    });\n  }\n}\n\nexport default DataProvisional;\n",
    "static": true,
    "longname": "src/syncher/DataProvisional.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 249,
    "kind": "class",
    "name": "DataProvisional",
    "memberof": "src/syncher/DataProvisional.js",
    "static": true,
    "longname": "src/syncher/DataProvisional.js~DataProvisional",
    "access": "private\nThis class is responsible for collecting delta changes in remote objects, before the response of subscription reach the observer.\nIt's used in Syncher -> subscribe. The flow is defined as:\n1. (observer) --subscribe--> (reporter)\n2. (observer) <--delta updates-- (reporter)\n3. (observer) <--subscribe response-- (reporter)\nThis means that there could be delta updates transferred before the subscription confirmation.\nSince there is no DataObjectObserver before the ubscription confirmation, there should be some other object collecting the updates.\nProvisional data is applied to the DataObjectObserver after confirmation. Or discarded if there is no confirmation.",
    "export": true,
    "importPath": "service-framework/src/syncher/DataProvisional.js",
    "importStyle": "DataProvisional",
    "description": "",
    "lineNumber": 35,
    "interface": false
  },
  {
    "__docId__": 250,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/DataProvisional.js~DataProvisional",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataProvisional.js~DataProvisional#constructor",
    "access": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "owner",
        "types": [
          "*"
        ]
      },
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "bus",
        "types": [
          "*"
        ]
      },
      {
        "name": "children",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "_allocateListeners",
    "memberof": "src/syncher/DataProvisional.js~DataProvisional",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataProvisional.js~DataProvisional#_allocateListeners",
    "access": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "_releaseListeners",
    "memberof": "src/syncher/DataProvisional.js~DataProvisional",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataProvisional.js~DataProvisional#_releaseListeners",
    "access": null,
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 253,
    "kind": "get",
    "name": "children",
    "memberof": "src/syncher/DataProvisional.js~DataProvisional",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataProvisional.js~DataProvisional#children",
    "access": null,
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "apply",
    "memberof": "src/syncher/DataProvisional.js~DataProvisional",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/DataProvisional.js~DataProvisional#apply",
    "access": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "observer",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 255,
    "kind": "file",
    "name": "src/syncher/ProxyObject.js",
    "content": "import 'proxy-observe';\nimport {parseAttributes} from '../utils/utils';\n\nconst objectType = {ARRAY: '[object Array]', OBJECT: '[object Object]' };\n\n/**\n * @access private\n * Main class that maintains a JSON object, and observes changes in this object, recursively.\n * Internal objects and arrays are also observed.\n */\nclass SyncObject {\n\n  constructor(initialData) {\n    let _this = this;\n\n    _this._observers = [];\n    _this._filters = {};\n\n    this._data = initialData || {};\n\n    this._internalObserve(this._data);\n  }\n\n  get data() { return this._data; }\n\n  observe(callback) {\n    this._observers.push(callback);\n  }\n\n  find(path) {\n    let list = parseAttributes(path);\n\n    return this._findWithSplit(list);\n  }\n\n  findBefore(path) {\n    let result = {};\n    let list = parseAttributes(path);\n    result.last = list.pop();\n    result.obj = this._findWithSplit(list);\n\n    return result;\n  }\n\n  _findWithSplit(list) {\n    let obj = this._data;\n    list.forEach((value) => {\n      obj = obj[value];\n    });\n\n    return obj;\n  }\n\n  _internalObserve(object) {\n\n    let handler = (changeset) => {\n\n      changeset.every((change) => {\n        this._onChanges(change);\n      });\n\n    };\n\n    this._data = Object.deepObserve(object, handler);\n\n  }\n\n  _fireEvent(event) {\n    this._observers.forEach((callback) => {\n      callback(event);\n    });\n  }\n\n  _onChanges(change) {\n\n    let obj = change.object;\n    let objType;\n\n    if (obj.constructor === Object) {\n      objType = ObjectType.OBJECT;\n    }\n\n    if (obj.constructor === Array) {\n      objType = ObjectType.ARRAY;\n    }\n\n    let fieldString = change.keypath;\n\n    // console.log('Field:', fieldString);\n    // console.log('type:', change.type);\n\n    //let oldValue = change.oldValue;\n    let newValue = obj[change.name];\n\n    // console.info(change.type + ' | Field: ' + fieldString + ' | New Value:', JSON.stringify(newValue), fieldString.includes('length'));\n\n    if (change.type === 'update' && !fieldString.includes('.length')) {\n      this._fireEvent({\n        cType: ChangeType.UPDATE,\n        oType: objType,\n        field: fieldString,\n        data: newValue\n      });\n    }\n\n    if (change.type === 'add') {\n      this._fireEvent({\n        cType: ChangeType.ADD,\n        oType: objType,\n        field: fieldString,\n        data: newValue\n      });\n    }\n\n    if (change.type === 'delete') {\n      this._fireEvent({\n        cType: ChangeType.REMOVE,\n        oType: objType,\n        field: fieldString\n      });\n    }\n  }\n\n}\n\nexport let ChangeType = {UPDATE: 'update', ADD: 'add', REMOVE: 'remove'};\nexport let ObjectType = {OBJECT: 'object', ARRAY: 'array'};\nexport default SyncObject;\n",
    "static": true,
    "longname": "src/syncher/ProxyObject.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 256,
    "kind": "variable",
    "name": "objectType",
    "memberof": "src/syncher/ProxyObject.js",
    "static": true,
    "longname": "src/syncher/ProxyObject.js~objectType",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/syncher/ProxyObject.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"ARRAY\": string, \"OBJECT\": string}"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "variable",
    "name": "ChangeType",
    "memberof": "src/syncher/ProxyObject.js",
    "static": true,
    "longname": "src/syncher/ProxyObject.js~ChangeType",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/ProxyObject.js",
    "importStyle": "{ChangeType}",
    "description": null,
    "lineNumber": 126,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"UPDATE\": string, \"ADD\": string, \"REMOVE\": string}"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "variable",
    "name": "ObjectType",
    "memberof": "src/syncher/ProxyObject.js",
    "static": true,
    "longname": "src/syncher/ProxyObject.js~ObjectType",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/ProxyObject.js",
    "importStyle": "{ObjectType}",
    "description": null,
    "lineNumber": 127,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"OBJECT\": string, \"ARRAY\": string}"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "class",
    "name": "SyncObject",
    "memberof": "src/syncher/ProxyObject.js",
    "static": true,
    "longname": "src/syncher/ProxyObject.js~SyncObject",
    "access": "private\nMain class that maintains a JSON object, and observes changes in this object, recursively.\nInternal objects and arrays are also observed.",
    "export": true,
    "importPath": "service-framework/src/syncher/ProxyObject.js",
    "importStyle": "SyncObject",
    "description": "",
    "lineNumber": 11,
    "interface": false
  },
  {
    "__docId__": 260,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#constructor",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "initialData",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 261,
    "kind": "member",
    "name": "_data",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#_data",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "get",
    "name": "data",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#data",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "observe",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#observe",
    "access": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "find",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#find",
    "access": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "findBefore",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#findBefore",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "_findWithSplit",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#_findWithSplit",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "list",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "_internalObserve",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#_internalObserve",
    "access": null,
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 268,
    "kind": "member",
    "name": "_data",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#_data",
    "access": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "_fireEvent",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#_fireEvent",
    "access": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "_onChanges",
    "memberof": "src/syncher/ProxyObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/ProxyObject.js~SyncObject#_onChanges",
    "access": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "change",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 271,
    "kind": "file",
    "name": "src/syncher/SyncObject.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nimport {deepClone} from '../utils/utils.js';\n\n/**\n * @access private\n * Main class that maintains a JSON object, and observes changes in this object, recursively.\n * Internal objects and arrays are also observed.\n */\nclass SyncObject {\n  /* private\n    _data: any;\n    _observers: ((event: ChangeEvent) => void)[]\n  */\n\n  constructor(initialData) {\n    let _this = this;\n\n    _this._observers = [];\n    _this._filters = {};\n\n    if (initialData) {\n      _this._data = deepClone(initialData);\n    } else {\n      _this._data = {};\n    }\n\n    _this._internalObserve(new Path(), _this._data);\n  }\n\n  get data() { return this._data; }\n\n  observe(callback) {\n    this._observers.push(callback);\n  }\n\n  find(path) {\n    let list = path.split('.');\n\n    return this._findWithSplit(list);\n  }\n\n  findBefore(path) {\n    let result = {};\n    let list = path.split('.');\n    result.last = list.pop();\n    result.obj = this._findWithSplit(list);\n\n    return result;\n  }\n\n  _findWithSplit(list) {\n    let obj = this._data;\n    list.forEach((value) => {\n      obj = obj[value];\n    });\n\n    return obj;\n  }\n\n  _fireEvent(event) {\n    this._observers.forEach((callback) => {\n      callback(event);\n    });\n  }\n\n  _isObservable(obj) {\n    if (obj.constructor === Object || obj.constructor === Array) {\n      return true;\n    }\n\n    return false;\n  }\n\n  _internalObserve(path, obj) {\n    let _this = this;\n\n    if (_this._isObservable(obj)) {\n      let handler = (changes) => {\n        _this._onChanges(path, changes);\n      };\n\n      if (obj.constructor === Object) {\n        Object.observe(obj, handler);\n        for (let prop in obj) {\n          if (_this._isObservable(obj[prop])) {\n            _this._internalObserve(path.new(prop), obj[prop]);\n          }\n        }\n      } else if (obj.constructor === Array) {\n        Array.observe(obj, handler);\n        for (let prop in obj) {\n          if (_this._isObservable(obj[prop])) {\n            let np = path.new(new ArrayIndex(obj[prop], prop));\n            _this._internalObserve(np, obj[prop]);\n          }\n        }\n      }\n    }\n  }\n\n  _onChanges(path, changes) {\n    for (let i in changes) {\n      let obj = changes[i].object;\n      let objType;\n\n      if (obj.constructor === Object) {\n        objType = ObjectType.OBJECT;\n      }\n\n      if (obj.constructor === Array) {\n        objType = ObjectType.ARRAY;\n      }\n\n      if (changes[i].type === 'splice') {\n        let idx = changes[i].index;\n        let field = path.new('' + idx);\n        let fieldString = field.toString();\n\n        let removeSize = changes[i].removed.length;\n        if (removeSize !== 0) {\n          let removeValues = changes[i].removed;\n          removeValues.forEach((value, index) => {\n            if (this._isObservable(value)) {\n              path.removeIndex(idx + index);\n            }\n          });\n\n          this._fireEvent({\n            cType: ChangeType.REMOVE,\n            oType: objType,\n            field: fieldString,\n            data: removeSize\n          });\n        }\n\n        let addSize = changes[i].addedCount;\n        if (addSize !== 0) {\n          let addValues = obj.slice(idx, idx + addSize);\n          addValues.forEach((value, index) => {\n            if (this._isObservable(value)) {\n              let np = path.new(new ArrayIndex(value, idx + index));\n              this._internalObserve(np, value);\n            }\n          });\n\n          this._fireEvent({\n            cType: ChangeType.ADD,\n            oType: objType,\n            field: fieldString,\n            data: deepClone(addValues)\n          });\n        }\n\n        //re-define paths...\n        if (idx !== obj.length - 1) {\n          path.reIndexFrom(obj);\n        }\n      } else {\n        let field = path.new(changes[i].name);\n        let fieldString = field.toString();\n\n        if (fieldString.indexOf('Symbol') !== -1) {\n          //hack for PhantomJS2\n          //console.log('SYMBOL: ', changes[i]);\n          continue;\n        }\n\n        //let oldValue = changes[i].oldValue;\n        let newValue = obj[changes[i].name];\n        if (changes[i].type === 'update') {\n          this._fireEvent({\n            cType: ChangeType.UPDATE,\n            oType: objType,\n            field: fieldString,\n            data: deepClone(newValue)\n          });\n        }\n\n        if (changes[i].type === 'add') {\n          this._internalObserve(field, newValue);\n          this._fireEvent({\n            cType: ChangeType.ADD,\n            oType: objType,\n            field: fieldString,\n            data: deepClone(newValue)\n          });\n        }\n\n        if (changes[i].type === 'delete') {\n          this._fireEvent({\n            cType: ChangeType.REMOVE,\n            oType: objType,\n            field: fieldString\n          });\n        }\n      }\n    }\n  }\n}\n\n//dynamic path for Array index...\nclass Path {\n\n  constructor() {\n    this._path = [];\n    this._observables = {}; //<index:ArrayIndex>\n  }\n\n  removeIndex(idx) {\n    //console.log('REMOVE-PATH ' + idx);\n    delete this._observables[idx];\n  }\n\n  reIndexFrom(array) {\n    Object.keys(this._observables).forEach((key) => {\n      let arrayIndex = this._observables[key];\n      let idx = array.indexOf(arrayIndex.obj);\n      if (arrayIndex.idx != idx) {\n        //console.log('RE-INDEX: ' + key + '->' + idx);\n        arrayIndex.idx = idx;\n        delete this._observables[key];\n        this._observables[idx] = arrayIndex;\n      }\n    });\n  }\n\n  new(idx) {\n    if (idx.constructor == ArrayIndex) {\n      //console.log('PATH-OBSERV: ', idx);\n      this._observables[idx.idx] = idx;\n    }\n\n    let nPath = this.clone();\n    nPath._path.push(idx);\n\n    return nPath;\n  }\n\n  clone() {\n    let nPath = new Path();\n    this._path.forEach((value) => {\n      nPath._path.push(value);\n    });\n\n    return nPath;\n  }\n\n  toString() {\n    //TODO: optimize!!\n    let str = '';\n    this._path.forEach((value, index) => {\n      if (index === 0) {\n        str = value.toString();\n      } else {\n        str += '.' + value.toString();\n      }\n    });\n\n    return str;\n  }\n}\n\nclass ArrayIndex {\n\n  constructor(obj, idx) {\n    this.obj = obj;\n    this.idx = idx;\n  }\n\n  toString() {\n    return this.idx.toString();\n  }\n}\n\nexport var ChangeType = {UPDATE: 'update', ADD: 'add', REMOVE: 'remove'};\nexport var ObjectType = {OBJECT: 'object', ARRAY: 'array'};\nexport default SyncObject;\n",
    "static": true,
    "longname": "src/syncher/SyncObject.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 272,
    "kind": "class",
    "name": "Path",
    "memberof": "src/syncher/SyncObject.js",
    "static": true,
    "longname": "src/syncher/SyncObject.js~Path",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/syncher/SyncObject.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 273,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/SyncObject.js~Path",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#constructor",
    "access": null,
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 274,
    "kind": "member",
    "name": "_path",
    "memberof": "src/syncher/SyncObject.js~Path",
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#_path",
    "access": null,
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "member",
    "name": "_observables",
    "memberof": "src/syncher/SyncObject.js~Path",
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#_observables",
    "access": null,
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "removeIndex",
    "memberof": "src/syncher/SyncObject.js~Path",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#removeIndex",
    "access": null,
    "description": null,
    "lineNumber": 231,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "idx",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "reIndexFrom",
    "memberof": "src/syncher/SyncObject.js~Path",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#reIndexFrom",
    "access": null,
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "new",
    "memberof": "src/syncher/SyncObject.js~Path",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#new",
    "access": null,
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "idx",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "clone",
    "memberof": "src/syncher/SyncObject.js~Path",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#clone",
    "access": null,
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "toString",
    "memberof": "src/syncher/SyncObject.js~Path",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~Path#toString",
    "access": null,
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "class",
    "name": "ArrayIndex",
    "memberof": "src/syncher/SyncObject.js",
    "static": true,
    "longname": "src/syncher/SyncObject.js~ArrayIndex",
    "access": null,
    "export": false,
    "importPath": "service-framework/src/syncher/SyncObject.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 282,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/SyncObject.js~ArrayIndex",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~ArrayIndex#constructor",
    "access": null,
    "description": null,
    "lineNumber": 287,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "idx",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 283,
    "kind": "member",
    "name": "obj",
    "memberof": "src/syncher/SyncObject.js~ArrayIndex",
    "static": false,
    "longname": "src/syncher/SyncObject.js~ArrayIndex#obj",
    "access": null,
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "member",
    "name": "idx",
    "memberof": "src/syncher/SyncObject.js~ArrayIndex",
    "static": false,
    "longname": "src/syncher/SyncObject.js~ArrayIndex#idx",
    "access": null,
    "description": null,
    "lineNumber": 289,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "toString",
    "memberof": "src/syncher/SyncObject.js~ArrayIndex",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~ArrayIndex#toString",
    "access": null,
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "variable",
    "name": "ChangeType",
    "memberof": "src/syncher/SyncObject.js",
    "static": true,
    "longname": "src/syncher/SyncObject.js~ChangeType",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/SyncObject.js",
    "importStyle": "{ChangeType}",
    "description": null,
    "lineNumber": 297,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"UPDATE\": string, \"ADD\": string, \"REMOVE\": string}"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "variable",
    "name": "ObjectType",
    "memberof": "src/syncher/SyncObject.js",
    "static": true,
    "longname": "src/syncher/SyncObject.js~ObjectType",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/SyncObject.js",
    "importStyle": "{ObjectType}",
    "description": null,
    "lineNumber": 298,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{\"OBJECT\": string, \"ARRAY\": string}"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "class",
    "name": "SyncObject",
    "memberof": "src/syncher/SyncObject.js",
    "static": true,
    "longname": "src/syncher/SyncObject.js~SyncObject",
    "access": "private\nMain class that maintains a JSON object, and observes changes in this object, recursively.\nInternal objects and arrays are also observed.",
    "export": true,
    "importPath": "service-framework/src/syncher/SyncObject.js",
    "importStyle": "SyncObject",
    "description": "",
    "lineNumber": 31,
    "interface": false
  },
  {
    "__docId__": 289,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#constructor",
    "access": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "initialData",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 290,
    "kind": "get",
    "name": "data",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#data",
    "access": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "observe",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#observe",
    "access": null,
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "find",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#find",
    "access": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "findBefore",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#findBefore",
    "access": null,
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "_findWithSplit",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#_findWithSplit",
    "access": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "list",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "_fireEvent",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#_fireEvent",
    "access": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "event",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "_isObservable",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#_isObservable",
    "access": null,
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "_internalObserve",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#_internalObserve",
    "access": null,
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      },
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "_onChanges",
    "memberof": "src/syncher/SyncObject.js~SyncObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/SyncObject.js~SyncObject#_onChanges",
    "access": null,
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      },
      {
        "name": "changes",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 299,
    "kind": "file",
    "name": "src/syncher/Syncher.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\nimport { deepClone } from '../utils/utils';\n\nimport DataObjectReporter from './DataObjectReporter';\nimport DataObjectObserver from './DataObjectObserver';\nimport DataProvisional from './DataProvisional';\n\n/**\n* The main class for the syncher package.\n* The Syncher is a singleton class per Hyperty/URL and it is the owner of all created Data Sync Objects according to the Reporter - Observer pattern.\n* Main functionality is to create reporters and to subscribe to existing ones.\n*/\nclass Syncher {\n  /* private\n  _owner: URL\n  _bus: MiniBus\n\n  _subURL: URL\n\n  _reporters: <url: DataObjectReporter>\n  _observers: <url: DataObjectObserver>\n  _provisionals: <url: DataProvisional>\n\n  ----event handlers----\n  _onNotificationHandler: (event) => void\n  _onResume: (event) => void\n  */\n\n  /**\n  * Constructor that should be used by the Hyperty owner\n  * @param {HypertyURL} owner - Hyperty URL owner. An URL allocated by the runtime that uniquely identifies the Hyperty.\n  * @param {MiniBus} bus - An instance of the MiniBus provided in the sandbox. When an object (Reporter or Observed) is created, the SyncherManager will add a listener in the MiniBus to receive/send Messages of that object.\n  * @param {JSON} config - Configuration data. The only required field for now is the runtimeURL.\n  */\n  constructor(owner, bus, config) {\n    let _this = this;\n\n    _this._owner = owner;\n    _this._bus = bus;\n\n    _this._subURL = config.runtimeURL + '/sm';\n    _this._runtimeUrl = config.runtimeURL;\n\n    _this._reporters = {};\n    _this._observers = {};\n    _this._provisionals = {};\n\n    bus.addListener(owner, (msg) => {\n      //ignore msg sent by himself\n      if (msg.from !== owner) {\n        console.info('[Syncher] Syncher-RCV: ', msg, _this);\n        switch (msg.type) {\n          case 'forward': _this._onForward(msg); break;\n          case 'create': _this._onRemoteCreate(msg); break;\n          case 'delete': _this._onRemoteDelete(msg); break;\n        }\n      }\n    });\n  }\n\n  /**\n  * The owner of the Syncher and all created reporters.\n  * @type {HypertyURL}\n  */\n  get owner() { return this._owner; }\n\n  /**\n  * All owned reporters, the ones that were created by a create\n  * @type {Object<URL, DataObjectReporter>}\n  */\n  get reporters() { return this._reporters; }\n\n  /**\n  * All owned observers, the ones that were created by a local subscription\n  * @type {Object<URL, DataObjectObserver>}\n  */\n  get observers() { return this._observers; }\n\n  /**\n  * Request a DataObjectReporter creation. The URL will be be requested by the allocation mechanism.\n  * @param  {SchemaURL} schema - Hyperty Catalogue URL address that can be used to retrieve the JSON-Schema describing the Data Object schema\n  * @param  {HypertyURL[]} observers - List of hyperties that are pre-authorized for subscription\n  * @param  {JSON} initialData - Initial data of the reporter\n  * @param  {boolean} store - (Optional) if true, object will be stored by the runtime\n  * @param  {boolean} p2p - (Optional) if true, data synchronisation stream will use p2p connection as much as possible\n  * @param  {string} name - (Optional) the name of the dataobject\n  * @param  {MessageBodyIdentity} identity - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.\n  * @param  {SyncMetadata} input - (optional) all metadata required to sunc the Data Object.\n  * @return {Promise<DataObjectReporter>} Return Promise to a new Reporter. The reporter can be accepted or rejected by the PEP\n  */\n  create(schema, observers, initialData, store = false, p2p = false, name = 'no name', identity, input) {\n\n    if (!schema) throw Error('[Syncher - Create] - You need specify the data object schema');\n    if (!observers) throw Error('[Syncher - Create] -The observers should be defined');\n\n    let _this = this;\n    let createInput  = Object.assign({}, input);\n\n    createInput.p2p = p2p;\n    createInput.store = store;\n    createInput.schema = schema;\n    createInput.authorise = observers;\n    (initialData) ? createInput.data = deepClone(initialData) : createInput.data = {};\n    createInput.name = name;\n    createInput.reporter = _this._owner;\n    createInput.resume = false;\n    if (input) {\n      createInput.mutual = input.mutual ? input.mutual : true;\n      createInput.name = input.name ? input.name : createInput.name;\n    } else { createInput.mutual = true; }\n\n    if (identity)      { createInput.identity = identity; }\n\n    //Object.assign(createInput, {resume: false});\n\n    console.log('[syncher - create] - create Reporter - createInput: ', createInput);\n\n    return _this._create(createInput);\n  }\n\n  /**\n  * Request a DataObjectReporter creation. The URL will be be requested by the allocation mechanism.\n  * @param  {Object} criteria - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.\n  * @return {Promise<DataObjectReporter>[]} Return a promise with a list of DataObjectReporter to be resumed;\n  */\n  resumeReporters(criteria) {\n    let _this = this;\n    console.log('[syncher - create] - resume Reporter - criteria: ', criteria);\n\n    Object.assign(criteria, {resume: true});\n\n    return _this._resumeCreate(criteria);\n  }\n\n  /**\n  * Request a subscription to an existent reporter object.\n  * @param {SchemaURL} schema - Hyperty Catalogue URL address that can be used to retrieve the JSON-Schema describing the Data Object schema\n  * @param {ObjectURL} objURL - Address of the existent reporter object to be observed\n  * @param {Boolean} [store=false] - Save the subscription on the Syncher Manager for further resume (Default is false)\n  * @param {Boolean} [p2p=false] - Info about if should use p2p connection (Default is false)\n  * @param {Boolean} [mutual=true] - Info about if messages of this object should be encrypted (Default is true)\n  * @param  {MessageBodyIdentity} identity - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.\n  * @return {Promise<DataObjectObserver>} Return Promise to a new observer. It's associated with the reporter.\n  */\n  subscribe(schema, objURL, store = false, p2p = false, mutual = true, identity) {\n    let _this = this;\n    let criteria = {};\n\n    criteria.p2p = p2p;\n    criteria.store = store;\n    criteria.schema = schema;\n\n    criteria.resource = objURL;\n    if (identity)      { criteria.identity = identity; }\n\n    //TODO: For Further Study\n    criteria.mutual = mutual;\n\n    console.log('[syncher - subscribe] - subscribe criteria: ', criteria);\n\n    Object.assign(criteria, {resume: false});\n\n    return _this._subscribe(criteria);\n  }\n\n  /**\n  * Request a subscription to an existent reporter object.\n  * @param {criteria} criteria - Information to discovery the observer object\n  * @return {Promise<DataObjectObserver>} Return Promise to a new observer. It's associated with the reporter.\n  */\n  resumeObservers(criteria) {\n    let _this = this;\n    let _criteria = criteria || {};\n\n    Object.assign(_criteria, {resume: true});\n\n    return _this._resumeSubscribe(_criteria);\n  }\n\n  /**\n  * Request a read action on the reporter object\n  * @param {ObjectURL} objURL - URL of the reporter object to be read\n  * @return {Promise<Object>} Return Promise to last available data of the reporter\n  */\n  read(objURL) {\n    let _this = this;\n\n    //FLOW-OUT: this message will be sent directly to reporter object (maybe there is no listener available, so it will be resolved with MessageBus -> resolve)\n    //will reach the remote object in DataObjectReporter -> _onRead\n    let readMsg = {\n      type: 'read', from: _this._owner, to: objURL\n    };\n\n    return new Promise((resolve, reject) => {\n      _this._bus.postMessage(readMsg, (reply) => {\n        console.log('read-response: ', reply);\n        if (reply.body.code === 200) {\n          resolve(reply.body.value);\n        } else {\n          reject(reply.body.desc);\n        }\n      });\n    });\n  }\n\n  /**\n  * Setup the callback to process create and delete events of remove Reporter objects.\n  * This is releated to the messagens sent by create to the observers Hyperty array.\n  * @param {function(event: MsgEvent)} callback\n  */\n  onNotification(callback) {\n    this._onNotificationHandler = callback;\n  }\n\n  _create(input) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      let reporterInput  = Object.assign({}, input);\n\n      let resume = input.resume;\n\n      reporterInput.created = (new Date).toISOString();\n      reporterInput.runtime = _this._runtimeUrl;\n\n      let requestValue = deepClone(reporterInput);\n\n      delete requestValue.p2p;\n      delete requestValue.store;\n      delete requestValue.observers;\n      delete requestValue.identity;\n\n      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onCreate\n      let requestMsg = {\n        type: 'create', from: _this._owner, to: _this._subURL,\n        body: { resume: resume, value: requestValue  }\n      };\n\n\n      requestMsg.body.schema = reporterInput.schema;\n\n      if (reporterInput.p2p) requestMsg.body.p2p = reporterInput.p2p;\n      if (reporterInput.store) requestMsg.body.store = reporterInput.store;\n      if (reporterInput.identity) requestMsg.body.identity = reporterInput.identity;\n\n      console.log('[syncher._create]: ', reporterInput, requestMsg);\n\n      //request create to the allocation system. Can be rejected by the PolicyEngine.\n      _this._bus.postMessage(requestMsg, (reply) => {\n        console.log('[syncher - create] - create-response: ', reply);\n        if (reply.body.code === 200) {\n          //reporter creation accepted\n          reporterInput.url = reply.body.resource;\n\n          reporterInput.status = 'live';// pch: do we ned this?\n          reporterInput.syncher = _this;\n          reporterInput.childrens = reply.body.childrenResources;\n\n          let newObj = new DataObjectReporter(reporterInput);\n\n          _this._reporters[reporterInput.url] = newObj;\n\n          newObj.inviteObservers(input.authorise);\n\n          resolve(newObj);\n\n        } else {\n          //reporter creation rejected\n          reject(reply.body.desc);\n        }\n      });\n    });\n\n  }\n\n  _resumeCreate(criteria) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n      let resume = criteria.resume;\n\n      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onCreate\n      let requestMsg = {\n        type: 'create', from: _this._owner, to: _this._subURL,\n        body: { resume: resume }\n      };\n\n      console.log('[syncher - create]: ', criteria, requestMsg);\n\n      if (criteria) {\n        requestMsg.body.value = criteria;\n        requestMsg.body.value.reporter = _this._owner;\n      }\n\n      if (criteria.p2p) requestMsg.body.p2p = criteria.p2p;\n      if (criteria.store) requestMsg.body.store = criteria.store;\n      if (criteria.observers) requestMsg.body.authorise = criteria.observers;\n      if (criteria.identity) requestMsg.body.identity = criteria.identity;\n\n      console.log('[syncher._resumeCreate] - resume message: ', requestMsg);\n\n      //request create to the allocation system. Can be rejected by the PolicyEngine.\n      _this._bus.postMessage(requestMsg, (reply) => {\n        console.log('[syncher._resumeCreate] - create-resumed-response: ', reply);\n        if (reply.body.code === 200) {\n\n          let listOfReporters = reply.body.value;\n\n          for (let index in listOfReporters) {\n\n            let dataObject = listOfReporters[index];\n\n            //reporter creation accepted\n\n            dataObject.data = deepClone(dataObject.data) || {};\n\n            if (dataObject.childrenObjects) { dataObject.childrenObjects = deepClone(dataObject.childrenObjects); }\n\n            dataObject.mutual = false;\n            dataObject.resume = true;\n            dataObject.status = 'live';// pch: do we ned this?\n            dataObject.syncher = _this;\n\n            console.log('[syncher._resumeCreate] - create-resumed-dataObjectReporter', dataObject);\n\n            let newObj = new DataObjectReporter(dataObject);\n\n            if (dataObject.childrenObjects) { newObj.resumeChildrens(dataObject.childrenObjects); }\n            _this._reporters[dataObject.url] = newObj;\n\n          }\n\n          resolve(_this._reporters);\n          if (this._onReportersResume) this._onReportersResume(this._reporters);\n\n        } else if (reply.body.code === 404) {\n          resolve({});\n        } else {\n          //reporter creation rejected\n          reject(reply.body.desc);\n        }\n      });\n    });\n  }\n\n  _subscribe(input) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onLocalSubscribe\n      let subscribeMsg = {\n        type: 'subscribe', from: _this._owner, to: _this._subURL,\n        body: {}\n      };\n\n      // Hyperty request to be an Observer\n      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#hyperty-request-to-be-an-observer\n\n      // Resume Subscriptions for the same Hyperty URL\n      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-the-same-hyperty-url\n\n      // Resume Subscriptions for a certain user and data schema independently of the Hyperty URL.\n      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-a-certain-user-and-data-schema-independently-of-the-hyperty-url\n      if (input) {\n        if (input.hasOwnProperty('p2p')) subscribeMsg.body.p2p = input.p2p;\n        if (input.hasOwnProperty('store')) subscribeMsg.body.store = input.store;\n        if (input.hasOwnProperty('schema')) subscribeMsg.body.schema = input.schema;\n        if (input.hasOwnProperty('identity')) subscribeMsg.body.identity = input.identity;\n        if (input.hasOwnProperty('resource')) subscribeMsg.body.resource = input.resource;\n      }\n\n      subscribeMsg.body.resume = input.resume;\n\n      //TODO: For Further Study\n      if (input.hasOwnProperty('mutual')) subscribeMsg.body.mutualAuthentication = input.mutual;\n\n      console.log('[syncher_subscribe] - subscribe message: ', input, subscribeMsg);\n\n      //request subscription\n      //Provisional data is applied to the DataObjectObserver after confirmation. Or discarded if there is no confirmation.\n      //for more info see the DataProvisional class documentation.\n      _this._bus.postMessage(subscribeMsg, (reply) => {\n        console.log('[syncher] - subscribe-response: ', reply);\n\n        let objURL = reply.body.resource;\n\n        let newProvisional = _this._provisionals[objURL];\n        delete _this._provisionals[objURL];\n        if (newProvisional) newProvisional._releaseListeners();\n\n        if (reply.body.code < 200) {\n          console.log('[syncher] - new DataProvisional: ', reply.body.childrenResources, objURL);\n          newProvisional = new DataProvisional(_this._owner, objURL, _this._bus, reply.body.childrenResources);\n          _this._provisionals[objURL] = newProvisional;\n        } else if (reply.body.code === 200) {\n          console.log('[syncher] - new Data Object Observer: ', reply, _this._provisionals);\n\n          let observerInput = reply.body.value;\n\n          observerInput.syncher = _this;\n          observerInput.p2p = input.p2p;\n          observerInput.store = input.store;\n          observerInput.identity = input.identity;\n          observerInput.resume = false;\n\n          // todo: For Further Study\n          observerInput.mutual = input.mutual;\n          observerInput.children = newProvisional.children;\n\n          //TODO: mutualAuthentication For Further Study\n          let newObj = new DataObjectObserver(observerInput);\n          _this._observers[objURL] = newObj;\n\n          resolve(newObj);\n          newProvisional.apply(newObj);\n        } else {\n          reject(reply.body.desc);\n        }\n      });\n    });\n  }\n\n  _resumeSubscribe(criteria) {\n    let _this = this;\n\n    return new Promise((resolve, reject) => {\n\n      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -> _onLocalSubscribe\n      let subscribeMsg = {\n        type: 'subscribe', from: _this._owner, to: _this._subURL,\n        body: {}\n      };\n\n      // Hyperty request to be an Observer\n      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#hyperty-request-to-be-an-observer\n\n      // Resume Subscriptions for the same Hyperty URL\n      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-the-same-hyperty-url\n\n      // Resume Subscriptions for a certain user and data schema independently of the Hyperty URL.\n      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-a-certain-user-and-data-schema-independently-of-the-hyperty-url\n      if (criteria) {\n        if (criteria.hasOwnProperty('p2p')) subscribeMsg.body.p2p = criteria.p2p;\n        if (criteria.hasOwnProperty('store')) subscribeMsg.body.store = criteria.store;\n        if (criteria.hasOwnProperty('schema')) subscribeMsg.body.schema = criteria.schema;\n        if (criteria.hasOwnProperty('identity')) subscribeMsg.body.identity = criteria.identity;\n        if (criteria.hasOwnProperty('resource')) subscribeMsg.body.resource = criteria.url;\n      }\n\n      subscribeMsg.body.resume = criteria.resume;\n\n      //TODO: For Further Study\n      let mutualAuthentication = criteria.mutual;\n      if (criteria.hasOwnProperty('mutual')) subscribeMsg.body.mutualAuthentication = mutualAuthentication;\n\n      console.log('[syncher] - subscribe message: ', criteria, subscribeMsg);\n\n      //request subscription\n      //Provisional data is applied to the DataObjectObserver after confirmation. Or discarded if there is no confirmation.\n      //for more info see the DataProvisional class documentation.\n      _this._bus.postMessage(subscribeMsg, (reply) => {\n        console.log('[syncher] - subscribe-resumed-response: ', reply);\n\n        let objURL = reply.body.resource;\n\n        let newProvisional = _this._provisionals[objURL];\n        delete _this._provisionals[objURL];\n        if (newProvisional) newProvisional._releaseListeners();\n\n        if (reply.body.code < 200) { // todo: check if this is needed for the resume\n\n          console.log('[syncher] - resume new DataProvisional: ', reply, objURL);\n          newProvisional = new DataProvisional(_this._owner, objURL, _this._bus, reply.body.childrenResources);\n          _this._provisionals[objURL] = newProvisional;\n\n        } else if (reply.body.code === 200) {\n\n          let listOfObservers = reply.body.value;\n\n          for (let index in listOfObservers) {\n\n            let dataObject = listOfObservers[index];\n            console.log('[syncher] - Resume Object Observer: ', reply, dataObject, _this._provisionals);\n\n            if (dataObject.childrenObjects) { dataObject.childrenObjects = deepClone(dataObject.childrenObjects); }\n\n            dataObject.data = deepClone(dataObject.data) || {};\n            dataObject.resume = true;\n            dataObject.syncher = _this;\n\n            //TODO: mutualAuthentication For Further Study\n            console.log('[syncher._resumeSubscribe] - create new dataObject: ', dataObject);\n            let newObj = new DataObjectObserver(dataObject);\n\n            //lets sync with Reporter\n            newObj.sync();\n\n            if (dataObject.childrenObjects) { newObj.resumeChildrens(dataObject.childrenObjects); }\n\n            _this._observers[newObj.url] = newObj;\n\n            if (_this._provisionals[newObj.url]) { _this._provisionals[newObj.url].apply(newObj); }\n          }\n\n          resolve(_this._observers);\n\n          if (this._onObserversResume) this._onObserversResume(_this._observers);\n\n        } else if (reply.body.code === 404) {\n          resolve({});\n        } else {\n          reject(reply.body.desc);\n        }\n      });\n    });\n\n  }\n\n  //FLOW-IN: message received from a local runtime ReporterObject -> _onRemoteSubscribe\n  _onForward(msg) {\n    let _this = this;\n\n    let reporter = _this._reporters[msg.body.to];\n    reporter._onForward(msg);\n  }\n\n  //FLOW-IN: message received from a remote Syncher -> create (this is actually an invitation to subscribe)\n  _onRemoteCreate(msg) {\n    let _this = this;\n\n   //remove \"/subscription\" from the URL\n    let resource = msg.from.slice(0, -13);\n\n    let event = {\n      type: msg.type,\n      from: msg.body.source,\n      url: resource,\n      schema: msg.body.schema,\n      value: msg.body.value,\n      identity: msg.body.identity,\n\n      ack: (type) => {\n        let lType = 200;\n        if (type) {\n          lType = type;\n        }\n\n       //send ack response message\n        _this._bus.postMessage({\n          id: msg.id, type: 'response', from: msg.to, to: msg.from,\n          body: { code: lType }\n        });\n      }\n    };\n\n    if (_this._onNotificationHandler) {\n      console.info('[Syncher] NOTIFICATION-EVENT: ', event);\n      _this._onNotificationHandler(event);\n    }\n  }\n\n  //FLOW-IN: message received from a remote DataObjectReporter -> delete\n  _onRemoteDelete(msg) {\n    let _this = this;\n\n   //remove \"/subscription\" from the URL\n    let resource = msg.body.resource;\n\n    let object = _this._observers[resource];\n\n    let unsubscribe = {\n      from: _this.owner,\n      to: _this._subURL,\n      id: msg.id,\n      type: 'unsubscribe',\n      body: { resource: msg.body.resource }\n    };\n\n    _this._bus.postMessage(unsubscribe);\n\n    if (object) {\n      let event = {\n        type: msg.type,\n        url: resource,\n        identity: msg.body.identity,\n\n        ack: (type) => {\n          let lType = 200;\n          if (type) {\n            lType = type;\n          }\n\n         //TODO: any other different options for the release process, like accept but nor release local?\n          if (lType === 200) {\n            object.delete();\n          }\n\n          //send ack response message\n          _this._bus.postMessage({\n            id: msg.id, type: 'response', from: msg.to, to: msg.from,\n            body: { code: lType, source: _this._owner }\n          });\n        }\n      };\n\n      if (_this._onNotificationHandler) {\n        console.log('NOTIFICATION-EVENT: ', event);\n        _this._onNotificationHandler(event);\n      }\n    } else {\n      _this._bus.postMessage({\n        id: msg.id, type: 'response', from: msg.to, to: msg.from,\n        body: { code: 404, source: _this._owner }\n      });\n    }\n  }\n\n  /**\n  * Callback system to trigger the resumed reporters\n  * @param  {Function} callback - function callback which will be invoked\n  * @return {Object<URL, DataObjectReporter>} Return one object with all resumed reporters;\n  */\n  onReportersResume(callback) {\n    this._onReportersResume = callback;\n  }\n\n  /**\n  * Callback system to trigger the resumed observers\n  * @param  {Function} callback - function callback which will be invoked\n  * @return {Object<URL, DataObjectObserver>} Return one object with all resumed observers;\n  */\n  onObserversResume(callback) {\n    this._onObserversResume = callback;\n  }\n\n}\n\nexport default Syncher;\n",
    "static": true,
    "longname": "src/syncher/Syncher.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "class",
    "name": "Syncher",
    "memberof": "src/syncher/Syncher.js",
    "static": true,
    "longname": "src/syncher/Syncher.js~Syncher",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/syncher/Syncher.js",
    "importStyle": "Syncher",
    "description": "The main class for the syncher package.\nThe Syncher is a singleton class per Hyperty/URL and it is the owner of all created Data Sync Objects according to the Reporter - Observer pattern.\nMain functionality is to create reporters and to subscribe to existing ones.",
    "lineNumber": 34,
    "interface": false
  },
  {
    "__docId__": 301,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#constructor",
    "access": null,
    "description": "Constructor that should be used by the Hyperty owner",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "HypertyURL"
        ],
        "spread": false,
        "optional": false,
        "name": "owner",
        "description": "Hyperty URL owner. An URL allocated by the runtime that uniquely identifies the Hyperty."
      },
      {
        "nullable": null,
        "types": [
          "MiniBus"
        ],
        "spread": false,
        "optional": false,
        "name": "bus",
        "description": "An instance of the MiniBus provided in the sandbox. When an object (Reporter or Observed) is created, the SyncherManager will add a listener in the MiniBus to receive/send Messages of that object."
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": "Configuration data. The only required field for now is the runtimeURL."
      }
    ]
  },
  {
    "__docId__": 302,
    "kind": "get",
    "name": "owner",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#owner",
    "access": null,
    "description": "The owner of the Syncher and all created reporters.",
    "lineNumber": 86,
    "type": {
      "nullable": null,
      "types": [
        "HypertyURL"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 303,
    "kind": "get",
    "name": "reporters",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#reporters",
    "access": null,
    "description": "All owned reporters, the ones that were created by a create",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "Object<URL, DataObjectReporter>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 304,
    "kind": "get",
    "name": "observers",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#observers",
    "access": null,
    "description": "All owned observers, the ones that were created by a local subscription",
    "lineNumber": 98,
    "type": {
      "nullable": null,
      "types": [
        "Object<URL, DataObjectObserver>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "create",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#create",
    "access": null,
    "description": "Request a DataObjectReporter creation. The URL will be be requested by the allocation mechanism.",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "SchemaURL"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "Hyperty Catalogue URL address that can be used to retrieve the JSON-Schema describing the Data Object schema"
      },
      {
        "nullable": null,
        "types": [
          "HypertyURL[]"
        ],
        "spread": false,
        "optional": false,
        "name": "observers",
        "description": "List of hyperties that are pre-authorized for subscription"
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "initialData",
        "description": "Initial data of the reporter"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "store",
        "description": "(Optional) if true, object will be stored by the runtime"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "p2p",
        "description": "(Optional) if true, data synchronisation stream will use p2p connection as much as possible"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "(Optional) the name of the dataobject"
      },
      {
        "nullable": null,
        "types": [
          "MessageBodyIdentity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "(optional) identity data to be added to identity the user reporter. To be used for legacy identities."
      },
      {
        "nullable": null,
        "types": [
          "SyncMetadata"
        ],
        "spread": false,
        "optional": false,
        "name": "input",
        "description": "(optional) all metadata required to sunc the Data Object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DataObjectReporter>"
      ],
      "spread": false,
      "description": "Return Promise to a new Reporter. The reporter can be accepted or rejected by the PEP"
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "resumeReporters",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#resumeReporters",
    "access": null,
    "description": "Request a DataObjectReporter creation. The URL will be be requested by the allocation mechanism.",
    "lineNumber": 147,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "criteria",
        "description": "(optional) identity data to be added to identity the user reporter. To be used for legacy identities."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DataObjectReporter>[]"
      ],
      "spread": false,
      "description": "Return a promise with a list of DataObjectReporter to be resumed;"
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "subscribe",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#subscribe",
    "access": null,
    "description": "Request a subscription to an existent reporter object.",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "SchemaURL"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "Hyperty Catalogue URL address that can be used to retrieve the JSON-Schema describing the Data Object schema"
      },
      {
        "nullable": null,
        "types": [
          "ObjectURL"
        ],
        "spread": false,
        "optional": false,
        "name": "objURL",
        "description": "Address of the existent reporter object to be observed"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "store",
        "description": "Save the subscription on the Syncher Manager for further resume (Default is false)"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "p2p",
        "description": "Info about if should use p2p connection (Default is false)"
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "mutual",
        "description": "Info about if messages of this object should be encrypted (Default is true)"
      },
      {
        "nullable": null,
        "types": [
          "MessageBodyIdentity"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "(optional) identity data to be added to identity the user reporter. To be used for legacy identities."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DataObjectObserver>"
      ],
      "spread": false,
      "description": "Return Promise to a new observer. It's associated with the reporter."
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "resumeObservers",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#resumeObservers",
    "access": null,
    "description": "Request a subscription to an existent reporter object.",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "criteria"
        ],
        "spread": false,
        "optional": false,
        "name": "criteria",
        "description": "Information to discovery the observer object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<DataObjectObserver>"
      ],
      "spread": false,
      "description": "Return Promise to a new observer. It's associated with the reporter."
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "read",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#read",
    "access": null,
    "description": "Request a read action on the reporter object",
    "lineNumber": 206,
    "params": [
      {
        "nullable": null,
        "types": [
          "ObjectURL"
        ],
        "spread": false,
        "optional": false,
        "name": "objURL",
        "description": "URL of the reporter object to be read"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": "Return Promise to last available data of the reporter"
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "onNotification",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#onNotification",
    "access": null,
    "description": "Setup the callback to process create and delete events of remove Reporter objects.\nThis is releated to the messagens sent by create to the observers Hyperty array.",
    "lineNumber": 232,
    "params": [
      {
        "nullable": null,
        "types": [
          "function(event: MsgEvent)"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 311,
    "kind": "member",
    "name": "_onNotificationHandler",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_onNotificationHandler",
    "access": null,
    "description": null,
    "lineNumber": 233,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "_create",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_create",
    "access": null,
    "description": null,
    "lineNumber": 236,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "_resumeCreate",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_resumeCreate",
    "access": null,
    "description": null,
    "lineNumber": 298,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "method",
    "name": "_subscribe",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_subscribe",
    "access": null,
    "description": null,
    "lineNumber": 368,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "_resumeSubscribe",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_resumeSubscribe",
    "access": null,
    "description": null,
    "lineNumber": 446,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "criteria",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "_onForward",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_onForward",
    "access": null,
    "description": null,
    "lineNumber": 543,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "_onRemoteCreate",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_onRemoteCreate",
    "access": null,
    "description": null,
    "lineNumber": 551,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "_onRemoteDelete",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_onRemoteDelete",
    "access": null,
    "description": null,
    "lineNumber": 586,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "onReportersResume",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#onReportersResume",
    "access": null,
    "description": "Callback system to trigger the resumed reporters",
    "lineNumber": 646,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "function callback which will be invoked"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object<URL, DataObjectReporter>"
      ],
      "spread": false,
      "description": "Return one object with all resumed reporters;"
    }
  },
  {
    "__docId__": 320,
    "kind": "member",
    "name": "_onReportersResume",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_onReportersResume",
    "access": null,
    "description": null,
    "lineNumber": 647,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "onObserversResume",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#onObserversResume",
    "access": null,
    "description": "Callback system to trigger the resumed observers",
    "lineNumber": 655,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "function callback which will be invoked"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object<URL, DataObjectObserver>"
      ],
      "spread": false,
      "description": "Return one object with all resumed observers;"
    }
  },
  {
    "__docId__": 322,
    "kind": "member",
    "name": "_onObserversResume",
    "memberof": "src/syncher/Syncher.js~Syncher",
    "static": false,
    "longname": "src/syncher/Syncher.js~Syncher#_onObserversResume",
    "access": null,
    "description": null,
    "lineNumber": 656,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "file",
    "name": "src/utils/EventEmitter.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\n/**\n * EventEmitter\n * All classes which extends this, can have addEventListener and trigger events;\n */\nclass EventEmitter {\n\n  /**\n   * addEventListener listen for an eventType\n   * @param  {string}         eventType - listening for this type of event\n   * @param  {Function}       cb        - callback function will be executed when the event it is invoked\n   */\n  addEventListener(eventType, cb) {\n    let _this = this;\n    _this[eventType] = cb;\n  }\n\n  /**\n   * Invoke the eventType\n   * @param  {string} eventType - event will be invoked\n   * @param  {object} params - parameters will be passed to the addEventListener\n   */\n  trigger(eventType, params) {\n    let _this = this;\n\n    if (_this[eventType]) {\n      _this[eventType](params);\n    }\n  }\n\n}\n\nexport default EventEmitter;\n",
    "static": true,
    "longname": "src/utils/EventEmitter.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 324,
    "kind": "class",
    "name": "EventEmitter",
    "memberof": "src/utils/EventEmitter.js",
    "static": true,
    "longname": "src/utils/EventEmitter.js~EventEmitter",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/EventEmitter.js",
    "importStyle": "EventEmitter",
    "description": "EventEmitter\nAll classes which extends this, can have addEventListener and trigger events;",
    "lineNumber": 28,
    "interface": false
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/utils/EventEmitter.js~EventEmitter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/EventEmitter.js~EventEmitter#addEventListener",
    "access": null,
    "description": "addEventListener listen for an eventType",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventType",
        "description": "listening for this type of event"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "cb",
        "description": "callback function will be executed when the event it is invoked"
      }
    ]
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "trigger",
    "memberof": "src/utils/EventEmitter.js~EventEmitter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/EventEmitter.js~EventEmitter#trigger",
    "access": null,
    "description": "Invoke the eventType",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventType",
        "description": "event will be invoked"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "parameters will be passed to the addEventListener"
      }
    ]
  },
  {
    "__docId__": 327,
    "kind": "file",
    "name": "src/utils/WatchingYou.js",
    "content": "import 'proxy-observe';\n\nclass WatchingYou {\n\n  constructor() {\n    this._watching = {};\n    this._observers = [];\n  }\n\n  watch(key, object, deep = false) {\n    if (deep) {\n      this._watching[key] = Object.deepObserve(object, (changes) => {\n        changes.every((change) => {\n          this._fireEvent(key, change);\n        });\n      });\n    } else {\n      this._watching[key] = Object.observe(object, (changes) => {\n        changes.every((change) => {\n          this._fireEvent(key, change);\n        });\n      });\n    }\n    return this._watching[key];\n  }\n\n  observe(key, callback) {\n    this._observers.push({key: key, callback: callback});\n  }\n\n  _fireEvent(key, change) {\n\n    this._observers.filter((observe) => {\n      return observe.key === key;\n    }).forEach((observe) => {\n      observe.callback(change);\n    });\n\n  }\n\n}\n\nexport default WatchingYou;\n\n/*let watchChanges = new WatchChanges();\nlet p2pRequesterStub = watchChanges.watch('p2p', {}, true);\nlet stub = watchChanges.watch('stub', {});\n\nwatchChanges.observe('p2p', (change) => {\n  console.log('p2pRequesterStub: ' + change.name + ' - ' + JSON.stringify(change.newValue));\n});\n\nwatchChanges.observe('p2p', (change) => {\n  console.log('p2pRequesterStub: ' + change.name + ' - ' + JSON.stringify(change.newValue));\n});\n\nwatchChanges.observe('stub', (change) => {\n  console.log('stub ' + change.name);\n});\n\np2pRequesterStub.a = {};\nstub.b = {name: 'vitor'};\np2pRequesterStub.a.name = 'Hello';\nstub.b = {name: 'vitor'};\np2pRequesterStub.a.age = '32';\np2pRequesterStub.a.name = 'World';*/\n",
    "static": true,
    "longname": "src/utils/WatchingYou.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 328,
    "kind": "class",
    "name": "WatchingYou",
    "memberof": "src/utils/WatchingYou.js",
    "static": true,
    "longname": "src/utils/WatchingYou.js~WatchingYou",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/WatchingYou.js",
    "importStyle": "WatchingYou",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 329,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/utils/WatchingYou.js~WatchingYou",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/WatchingYou.js~WatchingYou#constructor",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": []
  },
  {
    "__docId__": 330,
    "kind": "member",
    "name": "_watching",
    "memberof": "src/utils/WatchingYou.js~WatchingYou",
    "static": false,
    "longname": "src/utils/WatchingYou.js~WatchingYou#_watching",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "member",
    "name": "_observers",
    "memberof": "src/utils/WatchingYou.js~WatchingYou",
    "static": false,
    "longname": "src/utils/WatchingYou.js~WatchingYou#_observers",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "watch",
    "memberof": "src/utils/WatchingYou.js~WatchingYou",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/WatchingYou.js~WatchingYou#watch",
    "access": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      },
      {
        "name": "deep",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "observe",
    "memberof": "src/utils/WatchingYou.js~WatchingYou",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/WatchingYou.js~WatchingYou#observe",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "_fireEvent",
    "memberof": "src/utils/WatchingYou.js~WatchingYou",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/utils/WatchingYou.js~WatchingYou#_fireEvent",
    "access": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "change",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 335,
    "kind": "file",
    "name": "src/utils/utils.js",
    "content": "/**\n* Copyright 2016 PT Inovação e Sistemas SA\n* Copyright 2016 INESC-ID\n* Copyright 2016 QUOBIS NETWORKS SL\n* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V\n* Copyright 2016 ORANGE SA\n* Copyright 2016 Deutsche Telekom AG\n* Copyright 2016 Apizee\n* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n/**\n * Support module with some functions will be useful\n * @module utils\n */\n\n/**\n * @typedef divideURL\n * @type Object\n * @property {string} type The type of URL\n * @property {string} domain The domain of URL\n * @property {string} identity The identity of URL\n */\n\n/**\n * Divide an url in type, domain and identity\n * @param  {URL.URL} url - url address\n * @return {divideURL} the result of divideURL\n */\nexport function divideURL(url) {\n\n  if (!url) throw Error('URL is needed to split');\n\n\tfunction recurse(value) {\n\t\tconst regex = /([a-zA-Z-]*)(:\\/\\/(?:\\.)?|:)([-a-zA-Z0-9@:%._\\+~#=]{2,256})([-a-zA-Z0-9@:%._\\+~#=\\/]*)/gi;\n    const subst = '$1,$3,$4';\n\t  let parts = value.replace(regex, subst).split(',');\n\t\treturn parts;\n\t}\n\n\tlet parts = recurse(url);\n\n  // If the url has no scheme\n  if (parts[0] === url && !parts[0].includes('@')) {\n\n    let result = {\n      type: \"\",\n      domain: url,\n      identity: \"\"\n    };\n\n    console.error('[DivideURL] DivideURL don\\'t support url without scheme. Please review your url address', url);\n\n    return result;\n  }\n\n\t// check if the url has the scheme and includes an @\n\tif (parts[0] === url && parts[0].includes('@')) {\n\t\tlet scheme = parts[0] === url ? 'smtp' : parts[0];\n\t\tparts = recurse(scheme + '://' + parts[0]);\n\t}\n\n\t// if the domain includes an @, divide it to domain and identity respectively\n\tif (parts[1].includes('@')) {\n\t\tparts[2] = parts[0] + '://' + parts[1];\n\t\tparts[1] = parts[1].substr(parts[1].indexOf('@') + 1)\n    } \t/*else if (parts[2].includes('/')) {\n    parts[2] = parts[2].substr(parts[2].lastIndexOf('/')+1);\n  }*/\n\n  let result = {\n    type: parts[0],\n    domain: parts[1],\n    identity: parts[2]\n  };\n\n  return result;\n}\n\nexport function divideEmail(email) {\n  let indexOfAt = email.indexOf('@');\n\n  let result = {\n    username: email.substring(0, indexOfAt),\n    domain: email.substring(indexOfAt + 1, email.length)\n  };\n\n  return result;\n}\n\n/**\n * Check if an Object is empty\n * @param  {Object} object Object to be checked\n * @return {Boolean}       status of Object, empty or not (true|false);\n */\nexport function emptyObject(object) {\n  return Object.keys(object).length > 0 ? false : true;\n}\n\n/**\n * Make a COPY of the original data\n * @param  {Object}  obj - object to be cloned\n * @return {Object}\n */\nexport function deepClone(obj) {\n  //TODO: simple but inefficient JSON deep clone...\n  if (obj) return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n * Obtains the user URL that corresponds to a given email\n * @param  {string} userEmail The user email\n * @return {URL.URL} userURL The user URL\n */\nexport function getUserURLFromEmail(userEmail) {\n  let indexOfAt = userEmail.indexOf('@');\n  return 'user://' + userEmail.substring(indexOfAt + 1, userEmail.length) + '/' + userEmail.substring(0, indexOfAt);\n}\n\n/**\n * Obtains the user email that corresponds to a given URL\n * @param  {URL.URL} userURL The user URL\n * @return {string} userEmail The user email\n */\nexport function getUserEmailFromURL(userURL) {\n  let url = divideURL(userURL);\n  return url.identity.replace('/', '') + '@' + url.domain; // identity field has '/exampleID' instead of 'exampleID'\n}\n\n\n/**\n * Check if the user identifier is already in the URL format, if not, convert to URL format\n * @param  {string}   identifier  user identifier\n * @return {string}   userURL    the user URL\n */\nexport function convertToUserURL(identifier) {\n\n  // check if the identifier is already in the url format\n  if (identifier.substring(0, 7) === 'user://') {\n    let dividedURL = divideURL(identifier);\n\n    //check if the url is well formated\n    if (dividedURL.domain && dividedURL.identity) {\n      return identifier;\n    } else {\n      throw 'userURL with wrong format';\n    }\n\n  //if not, convert the user email to URL format\n  } else {\n    return getUserURLFromEmail(identifier);\n  }\n}\n\nexport function checkAttribute(path) {\n\n  let regex = /((([a-zA-Z]+):\\/\\/([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})\\/[a-zA-Z0-9\\.]+@[a-zA-Z0-9]+(\\-)?[a-zA-Z0-9]+(\\.)?[a-zA-Z0-9]{2,10}?\\.[a-zA-Z]{2,10})(.+(?=.identity))?/gm;\n\n  let list = [];\n  let final = [];\n  let test = path.match(regex);\n\n  if (test == null) {\n    final = path.split('.');\n  } else {\n    let m;\n    while ((m = regex.exec(path)) !== null) {\n      // This is necessary to avoid infinite loops with zero-width matches\n      if (m.index === regex.lastIndex) {\n        regex.lastIndex++;\n      }\n\n      // The result can be accessed through the `m`-variable.\n      m.forEach((match, groupIndex) => {\n        if (groupIndex === 0) {\n          list.push(match);\n        }\n      });\n    }\n    let result;\n    list.forEach((url) => {\n      result = path.replace(url, '*+*');\n\n      final = result.split('.').map((item) => {\n        if (item === '*+*') { return url; }\n        return item;\n      });\n\n    });\n  }\n\n  console.log('[ServiceFramework.Utils.checkAttribute]', final);\n  return final;\n}\n\nexport function parseAttributes(path) {\n  let regex = /([0-9a-zA-Z][-\\w]*):\\/\\//g;\n\n  let string3 = 'identity';\n\n  if (!path.includes('://')) {\n    return (path.split('.'));\n  } else {\n    let string1 = path.split(regex)[0];\n\n    let array1 = string1.split('.');\n\n    let string2 = path.replace(string1, '');\n\n    if (path.includes(string3)) {\n\n      let array2 = string2.split(string3 + '.');\n\n      console.log('array2 ' + array2);\n\n      string2 = array2[0].slice('.', -1);\n\n      array2 = array2[1].split('.');\n\n      array1.push(string2, string3);\n\n      array1 = array1.concat(array2);\n\n    } else {\n      array1.push(string2);\n\n    }\n\n    return (array1.filter(Boolean));\n\n  }\n}\n",
    "static": true,
    "longname": "src/utils/utils.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "typedef",
    "name": "divideURL",
    "memberof": "src/utils/utils.js",
    "static": true,
    "longname": "src/utils/utils.js~divideURL",
    "access": null,
    "description": "",
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type of URL"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "The domain of URL"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identity",
        "description": "The identity of URL"
      }
    ],
    "type": {
      "types": [
        "*"
      ],
      "optional": false,
      "name": "divideURL"
    }
  },
  {
    "__docId__": 337,
    "kind": "function",
    "name": "divideURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~divideURL",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{divideURL}",
    "description": "Divide an url in type, domain and identity",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "url address"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "divideURL"
      ],
      "spread": false,
      "description": "the result of divideURL"
    }
  },
  {
    "__docId__": 338,
    "kind": "function",
    "name": "divideEmail",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~divideEmail",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{divideEmail}",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "email",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "function",
    "name": "emptyObject",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~emptyObject",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{emptyObject}",
    "description": "Check if an Object is empty",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "Object to be checked"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": "status of Object, empty or not (true|false);"
    }
  },
  {
    "__docId__": 340,
    "kind": "function",
    "name": "deepClone",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~deepClone",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{deepClone}",
    "description": "Make a COPY of the original data",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": "object to be cloned"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 341,
    "kind": "function",
    "name": "getUserURLFromEmail",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~getUserURLFromEmail",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{getUserURLFromEmail}",
    "description": "Obtains the user URL that corresponds to a given email",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userEmail",
        "description": "The user email"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "URL.URL"
      ],
      "spread": false,
      "description": "userURL The user URL"
    }
  },
  {
    "__docId__": 342,
    "kind": "function",
    "name": "getUserEmailFromURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~getUserEmailFromURL",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{getUserEmailFromURL}",
    "description": "Obtains the user email that corresponds to a given URL",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "URL.URL"
        ],
        "spread": false,
        "optional": false,
        "name": "userURL",
        "description": "The user URL"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "userEmail The user email"
    }
  },
  {
    "__docId__": 343,
    "kind": "function",
    "name": "convertToUserURL",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~convertToUserURL",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{convertToUserURL}",
    "description": "Check if the user identifier is already in the URL format, if not, convert to URL format",
    "lineNumber": 147,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "user identifier"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "userURL    the user URL"
    }
  },
  {
    "__docId__": 344,
    "kind": "function",
    "name": "checkAttribute",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~checkAttribute",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{checkAttribute}",
    "description": null,
    "lineNumber": 166,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "function",
    "name": "parseAttributes",
    "memberof": "src/utils/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils/utils.js~parseAttributes",
    "access": null,
    "export": true,
    "importPath": "service-framework/src/utils/utils.js",
    "importStyle": "{parseAttributes}",
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "unknown": [
      {
        "tagName": "@_undocument",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "path",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 348,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 349,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 350,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 351,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 352,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 353,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 354,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 355,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 356,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 357,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 358,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 359,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 360,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 361,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 362,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 363,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 364,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 365,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 366,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 367,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 368,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 369,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 370,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 371,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 372,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 373,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 374,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 375,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 376,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 377,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 378,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 379,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 380,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 381,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 382,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 383,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 384,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 385,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 386,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 387,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 388,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 389,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 390,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 391,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 392,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 393,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "static": true,
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "lineNumber": 193,
    "builtinExternal": true
  },
  {
    "__docId__": 395,
    "kind": "external",
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 396,
    "kind": "external",
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 397,
    "kind": "external",
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 398,
    "kind": "external",
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 399,
    "kind": "external",
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 400,
    "kind": "external",
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 401,
    "kind": "external",
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 402,
    "kind": "external",
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "static": true,
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "lineNumber": 34,
    "builtinExternal": true
  },
  {
    "__docId__": 403,
    "kind": "testFile",
    "name": "test/CatalogueDataObjectFactory.spec.js",
    "content": "import CatalogueDataObjectFactory from \"../src/catalogue-factory/CatalogueDataObjectFactory\";\nimport RuntimeConstraint from \"../src/catalogue-factory/RuntimeConstraint\";\nimport {CatalogueObjectType, DataObjectSourceLanguage} from \"../src/catalogue-factory/CatalogueDataObject\";\nimport {DataUrlScheme} from \"../src/catalogue-factory/DataObjectSchema\";\nimport {HypertyResourceType} from \"../src/catalogue-factory/HypertyDescriptor\";\nimport {\n    RuntimeType,\n    RuntimeHypertyCapability,\n    RuntimeProtocolCapability\n} from \"../src/catalogue-factory/HypertyRuntimeDescriptor.js\";\nimport chai from \"chai\";\nimport chaiAsPromised from \"chai-as-promised\";\n\nlet expect = chai.expect;\nchai.use(chaiAsPromised);\n\n//Testing the CatalogueDataObject-Factory\ndescribe('CatalogueDataObjectFactory', function () {\n\n    let catalogueDataObjectFactory;\n\n    describe('constructor()', function () {\n\n        it('should create a CatalogueDataObject-Factory object without error', function () {\n            catalogueDataObjectFactory = new CatalogueDataObjectFactory();\n        });\n\n    });\n    describe('createHypertyDescriptorObject()', function () {\n\n        let hypertyDescriptor;\n\n        it('should generate HypertyDescriptor', function () {\n            hypertyDescriptor = catalogueDataObjectFactory.createHypertyDescriptorObject(\n                \"525f4671-ebd8-4b35-b062-5a126bf44628\", \"1.0\", \"My awesome Hyperty\", \"Description of Hyperty\",\n                DataObjectSourceLanguage.JAVASCRIPT_ECMA6, \"https://example.org/my-awesome-hyperty/source\",\n                [HypertyResourceType.av, HypertyResourceType.chat], {});\n            expect(hypertyDescriptor).not.to.be.empty;\n        });\n\n        it('should be of type HYPERTY', function () {\n            expect(hypertyDescriptor.type).to.eql(CatalogueObjectType.HYPERTY);\n        });\n\n        it('testing getters/setters (name, type, messageSchema)', function () {\n            let name = \"My amazing Hyperty\";\n            let messageSchema = \"test\";\n            let type = CatalogueObjectType.HYPERTY;\n\n            hypertyDescriptor.name = name;\n            hypertyDescriptor.type = type;\n            hypertyDescriptor.messageSchema = messageSchema;\n\n            expect(hypertyDescriptor.name).to.eql(name);\n            expect(hypertyDescriptor.type).to.eql(type);\n            expect(hypertyDescriptor.messageSchema).to.eql(messageSchema);\n        });\n\n        it('should have valid GUID', function () {\n            let guid = hypertyDescriptor.guid;\n            expect(guidCheck(guid)).to.be.true;\n        });\n    });\n\n    describe('createProtoStubDescriptorObject()', function () {\n        let protocolStubDescriptor;\n\n        it('should generate ProtocolStubDescriptor', function () {\n            protocolStubDescriptor = catalogueDataObjectFactory.createProtoStubDescriptorObject(\n                \"3339515e-e457-4fe0-b780-68263ca216db\", \"1.1\", \"My awesome Hyperty 2\", \"Description of Hyperty 2\",\n                DataObjectSourceLanguage.JAVASCRIPT_ECMA6, \"https://example.org/my-awesome-hyperty-2/source\", {}, {},\n                new RuntimeConstraint());\n            expect(protocolStubDescriptor).not.to.be.empty;\n        });\n\n        it('should be of type PROTOSTUB', function () {\n            expect(protocolStubDescriptor.type).to.eql(CatalogueObjectType.PROTOSTUB);\n        });\n\n        it('should have valid GUID', function () {\n            let guid = protocolStubDescriptor.guid;\n            expect(guidCheck(guid)).to.be.true;\n        })\n    });\n\n    describe('createHypertyInterceptorObject()', function () {\n        let hypertyInterceptorDescriptor;\n\n        it('should generate HypertyInterceptorDescriptor', function () {\n            hypertyInterceptorDescriptor = catalogueDataObjectFactory.createHypertyInterceptorDescriptorObject(\n                \"5dc08572-56e5-4ad1-99c8-79c49578a5b0\", \"1.0\", \"My awesome Hyperty 3\", \"Description of Hyperty 2\",\n                DataObjectSourceLanguage.PYTHON, \"https://example.com/my-awesome-hyperty-3/source\", {},\n                []);\n            expect(hypertyInterceptorDescriptor).not.to.be.empty;\n        });\n\n        it('should be of type HYPERTY_INTERCEPTOR', function () {\n            expect(hypertyInterceptorDescriptor.type).to.eql(CatalogueObjectType.HYPERTY_INTERCEPTOR);\n        });\n\n        it('should have valid GUID', function () {\n            let guid = hypertyInterceptorDescriptor.guid;\n            expect(guidCheck(guid)).to.be.true;\n        });\n    });\n\n    describe('createSourcePackage()', function () {\n        let sourcePackage;\n\n        it('should generate SourcePackage', function () {\n            sourcePackage = catalogueDataObjectFactory.createSourcePackage(\"MyClassName\", {});\n            expect(sourcePackage).not.to.be.empty;\n        });\n    });\n\n    describe('createCatalogueDataObject()', function () {\n\n        let catalogueDataObject;\n\n        it('should generate CatalogueDataObject of type HypertyDescriptor', function () {\n            catalogueDataObject = catalogueDataObjectFactory.createCatalogueDataObject(\n                \"df7c7237-03e4-4547-89ca-c0c8b8d88f63\", CatalogueObjectType.HYPERTY, \"2.5.1\", \"My awesome Hyperty 4\",\n                \"Description of Hyperty 4\", DataObjectSourceLanguage.JAVASCRIPT_ECMA6,\n                \"https://example.org/my-awesome-hyperty/source\");\n            expect(catalogueDataObject).not.to.be.empty;\n        });\n\n        it('should be of type HYPERTY', function () {\n            expect(catalogueDataObject.type).to.eql(CatalogueObjectType.HYPERTY);\n        });\n\n        it('should have valid GUID', function () {\n            let guid = catalogueDataObject.guid;\n            expect(guidCheck(guid)).to.be.true;\n        });\n    });\n\n    describe('createHypertyRuntimeDescriptorObject()', function () {\n        let hypertyRuntimeDescriptor;\n\n        it('should generate HypertyRuntimeDescriptor', function () {\n            hypertyRuntimeDescriptor = catalogueDataObjectFactory.createHypertyRuntimeDescriptorObject(\n                \"b36392c3-73d4-4a63-942b-4a9c2c663eea\", \"0.4.4\", \"My awesome Hyperty 5\", \"Description of Hyperty 5\",\n                DataObjectSourceLanguage.JAVASCRIPT_ECMA6, \"https://example.org/my-awesome-hyperty-5/source\",\n                RuntimeType.BROWSER, new RuntimeHypertyCapability(true, true, true, false, false),\n                new RuntimeProtocolCapability(true, true, true, true, false, true));\n            expect(hypertyRuntimeDescriptor).not.to.be.empty;\n        });\n\n        it('should be of type HYPERTY_RUNTIME', function () {\n            expect(hypertyRuntimeDescriptor.type).to.eql(CatalogueObjectType.HYPERTY_RUNTIME);\n        });\n\n        it('should have valid GUID', function () {\n            let guid = hypertyRuntimeDescriptor.guid;\n            expect(guidCheck(guid)).to.be.true;\n        });\n    });\n\n    describe('createHypertyDataObjectSchema()', function () {\n        let dataObjectSchema;\n\n        it('should generate HypertyDataObjectSchema', function () {\n            dataObjectSchema = catalogueDataObjectFactory.createHypertyDataObjectSchema(\n                \"b36392c3-73d4-4a63-942b-4a9c2c663eea\", \"1.2.1\", \"My awesome Schema\",\n                \"Description of Schema\",\n                DataObjectSourceLanguage.JAVASCRIPT_ECMA6, \"https://example.org/my-awesome-schema/source\",\n                \"accessControlPolicyString\", DataUrlScheme.COMM\n            );\n            expect(dataObjectSchema).not.to.be.empty;\n        });\n\n\n        it('should be of type DATA_SCHEMA', function () {\n            expect(dataObjectSchema.type).to.eql(CatalogueObjectType.HYPERTY_DATA_OBJECT);\n        });\n\n        it('should have valid GUID', function () {\n            let guid = dataObjectSchema.guid;\n            expect(guidCheck(guid)).to.be.true;\n        });\n    });\n\n\n    function guidCheck(guid) {\n        if (typeof guid === \"undefined\") return false;\n        else {\n            //GUID should match standard RFC4122\n            let match = guid.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i);\n            return match !== null && match.length === 1;\n        }\n    }\n});\n\n",
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 404,
    "kind": "testDescribe",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/CatalogueDataObjectFactory.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "access": null,
    "description": "CatalogueDataObjectFactory",
    "lineNumber": 18
  },
  {
    "__docId__": 405,
    "kind": "testDescribe",
    "name": "describe1",
    "testId": 1,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe1",
    "access": null,
    "description": "constructor()",
    "lineNumber": 22
  },
  {
    "__docId__": 406,
    "kind": "testIt",
    "name": "it2",
    "testId": 2,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe1.it2",
    "access": null,
    "description": "should create a CatalogueDataObject-Factory object without error",
    "lineNumber": 24
  },
  {
    "__docId__": 407,
    "kind": "testDescribe",
    "name": "describe3",
    "testId": 3,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3",
    "access": null,
    "description": "createHypertyDescriptorObject()",
    "lineNumber": 29
  },
  {
    "__docId__": 408,
    "kind": "testIt",
    "name": "it4",
    "testId": 4,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3.it4",
    "access": null,
    "description": "should generate HypertyDescriptor",
    "lineNumber": 33
  },
  {
    "__docId__": 409,
    "kind": "testIt",
    "name": "it5",
    "testId": 5,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3.it5",
    "access": null,
    "description": "should be of type HYPERTY",
    "lineNumber": 41
  },
  {
    "__docId__": 410,
    "kind": "testIt",
    "name": "it6",
    "testId": 6,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3.it6",
    "access": null,
    "description": "testing getters/setters (name, type, messageSchema)",
    "lineNumber": 45
  },
  {
    "__docId__": 411,
    "kind": "testIt",
    "name": "it7",
    "testId": 7,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe3.it7",
    "access": null,
    "description": "should have valid GUID",
    "lineNumber": 59
  },
  {
    "__docId__": 412,
    "kind": "testDescribe",
    "name": "describe8",
    "testId": 8,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8",
    "access": null,
    "description": "createProtoStubDescriptorObject()",
    "lineNumber": 65
  },
  {
    "__docId__": 413,
    "kind": "testIt",
    "name": "it9",
    "testId": 9,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8.it9",
    "access": null,
    "description": "should generate ProtocolStubDescriptor",
    "lineNumber": 68
  },
  {
    "__docId__": 414,
    "kind": "testIt",
    "name": "it10",
    "testId": 10,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8.it10",
    "access": null,
    "description": "should be of type PROTOSTUB",
    "lineNumber": 76
  },
  {
    "__docId__": 415,
    "kind": "testIt",
    "name": "it11",
    "testId": 11,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe8.it11",
    "access": null,
    "description": "should have valid GUID",
    "lineNumber": 80
  },
  {
    "__docId__": 416,
    "kind": "testDescribe",
    "name": "describe12",
    "testId": 12,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12",
    "access": null,
    "description": "createHypertyInterceptorObject()",
    "lineNumber": 86
  },
  {
    "__docId__": 417,
    "kind": "testIt",
    "name": "it13",
    "testId": 13,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12.it13",
    "access": null,
    "description": "should generate HypertyInterceptorDescriptor",
    "lineNumber": 89
  },
  {
    "__docId__": 418,
    "kind": "testIt",
    "name": "it14",
    "testId": 14,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12.it14",
    "access": null,
    "description": "should be of type HYPERTY_INTERCEPTOR",
    "lineNumber": 97
  },
  {
    "__docId__": 419,
    "kind": "testIt",
    "name": "it15",
    "testId": 15,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe12.it15",
    "access": null,
    "description": "should have valid GUID",
    "lineNumber": 101
  },
  {
    "__docId__": 420,
    "kind": "testDescribe",
    "name": "describe16",
    "testId": 16,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe16",
    "access": null,
    "description": "createSourcePackage()",
    "lineNumber": 107
  },
  {
    "__docId__": 421,
    "kind": "testIt",
    "name": "it17",
    "testId": 17,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe16",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe16.it17",
    "access": null,
    "description": "should generate SourcePackage",
    "lineNumber": 110
  },
  {
    "__docId__": 422,
    "kind": "testDescribe",
    "name": "describe18",
    "testId": 18,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18",
    "access": null,
    "description": "createCatalogueDataObject()",
    "lineNumber": 116
  },
  {
    "__docId__": 423,
    "kind": "testIt",
    "name": "it19",
    "testId": 19,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18.it19",
    "access": null,
    "description": "should generate CatalogueDataObject of type HypertyDescriptor",
    "lineNumber": 120
  },
  {
    "__docId__": 424,
    "kind": "testIt",
    "name": "it20",
    "testId": 20,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18.it20",
    "access": null,
    "description": "should be of type HYPERTY",
    "lineNumber": 128
  },
  {
    "__docId__": 425,
    "kind": "testIt",
    "name": "it21",
    "testId": 21,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe18.it21",
    "access": null,
    "description": "should have valid GUID",
    "lineNumber": 132
  },
  {
    "__docId__": 426,
    "kind": "testDescribe",
    "name": "describe22",
    "testId": 22,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22",
    "access": null,
    "description": "createHypertyRuntimeDescriptorObject()",
    "lineNumber": 138
  },
  {
    "__docId__": 427,
    "kind": "testIt",
    "name": "it23",
    "testId": 23,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22.it23",
    "access": null,
    "description": "should generate HypertyRuntimeDescriptor",
    "lineNumber": 141
  },
  {
    "__docId__": 428,
    "kind": "testIt",
    "name": "it24",
    "testId": 24,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22.it24",
    "access": null,
    "description": "should be of type HYPERTY_RUNTIME",
    "lineNumber": 150
  },
  {
    "__docId__": 429,
    "kind": "testIt",
    "name": "it25",
    "testId": 25,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe22.it25",
    "access": null,
    "description": "should have valid GUID",
    "lineNumber": 154
  },
  {
    "__docId__": 430,
    "kind": "testDescribe",
    "name": "describe26",
    "testId": 26,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26",
    "access": null,
    "description": "createHypertyDataObjectSchema()",
    "lineNumber": 160
  },
  {
    "__docId__": 431,
    "kind": "testIt",
    "name": "it27",
    "testId": 27,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26.it27",
    "access": null,
    "description": "should generate HypertyDataObjectSchema",
    "lineNumber": 163
  },
  {
    "__docId__": 432,
    "kind": "testIt",
    "name": "it28",
    "testId": 28,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26.it28",
    "access": null,
    "description": "should be of type DATA_SCHEMA",
    "lineNumber": 174
  },
  {
    "__docId__": 433,
    "kind": "testIt",
    "name": "it29",
    "testId": 29,
    "memberof": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26",
    "testDepth": 2,
    "static": true,
    "longname": "test/CatalogueDataObjectFactory.spec.js~describe0.describe26.it29",
    "access": null,
    "description": "should have valid GUID",
    "lineNumber": 178
  },
  {
    "__docId__": 434,
    "kind": "testFile",
    "name": "test/Discovery.spec.js",
    "content": "import HypertyDiscovery from '../src/discovery/Discovery';\n\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\n\nlet expect = chai.expect;\nchai.use(chaiAsPromised);\n\ndescribe('Discovery', function() {\n  let domain = 'ist.pt';\n  let runtimeURL = 'runtimeURL';\n  let expectedHypertyMessage = {'hyperty://ist.pt/1':\n                  {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                   lastModified: '\"2016-03-03T13:32:06Z\"',\n                   dataSchemes: ['comm'],\n                   resources:   ['chat']}\n  };\n  let expectedDataObjectMessage = {'comm://ist.pt/1':\n                  {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                   url: 'comm://ist.pt/1',\n                   name: 'mychat',\n                   lastModified: '\"2016-03-03T13:32:06Z\"',\n                   dataSchemes: ['comm'],\n                   resources:   ['chat']}\n  };\n\n  let messageBus = {\n    postMessage: (msg, replyCallback) => {\n\n      if (msg.body.resource === 'user://gmail.com/openidtest10') { //deprecated\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: 'domain://registry.ist.pt/',\n          body: {resource: 'user://gmail.com/openidtest10'}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://gmail.com/openidtest10',\n            value: {'hyperty://ist.pt/1':\n                        {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"'}}}\n        });\n      } else if (msg.body.resource === 'user://specific.com/openidtest10') { //deprecated\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: 'domain://registry.specific.com/',\n          body: {resource: 'user://specific.com/openidtest10'}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://specific.com/openidtest10',\n            value: {'hyperty://specific.com/1':\n                        {descriptor: 'hyperty-catalogue://specific.com/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"'}}}\n        });\n      } else if (msg.body.resource === 'user://gmail.com/openidtest20') { //deprecated\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: 'domain://registry.ist.pt/',\n          body: {resource: 'user://gmail.com/openidtest20', criteria: {resources: ['chat'], dataSchemes: ['comm']}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://gmail.com/openidtest20',\n            value: {'hyperty://ist.pt/1':\n                        {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/hyperty/userprofile/openidtest20') { //discoverHypertiesPerUserProfileData\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/hyperty/userprofile/openidtest20', criteria: {resources: ['chat'], dataSchemes: ['comm']}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'hyperty://ist.pt/1':\n                        {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/dataObject/userprofile/openidtest20') { //discoverDataObjectsPerUserProfileData\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/dataObject/userprofile/openidtest20', criteria: {resources: ['chat'], dataSchemes: ['comm']}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'comm://ist.pt/1':\n                      {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                       url: 'comm://ist.pt/1',\n                       name: 'mychat',\n                       lastModified: '\"2016-03-03T13:32:06Z\"',\n                       dataSchemes: ['comm'],\n                       resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/hyperty/guid/user-guid://3vGnMSSVVhJL7soMC9tSj6DyIxWUNrzj3BNBcbUyceo') { //discoverHypertiesPerGUID\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/hyperty/guid/user-guid://3vGnMSSVVhJL7soMC9tSj6DyIxWUNrzj3BNBcbUyceo', criteria: {resources: ['chat'], dataSchemes: ['comm']}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'hyperty://ist.pt/1':\n                        {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/dataObject/guid/user-guid://3vGnMSSVVhJL7soMC9tSj6DyIxWUNrzj3BNBcbUyceo') { //discoverDataObjectsPerGUID\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/dataObject/guid/user-guid://3vGnMSSVVhJL7soMC9tSj6DyIxWUNrzj3BNBcbUyceo', criteria: {resources: ['chat'], dataSchemes: ['comm']}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'comm://ist.pt/1':\n                        {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                         url: 'comm://ist.pt/1',\n                         name: 'mychat',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/hyperty/user/openidtest20@gmail.com') { //discoverHyperties\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/hyperty/user/openidtest20@gmail.com', criteria: {resources: ['chat'], dataSchemes: ['comm'], domain: domain}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'hyperty://ist.pt/1':\n                        {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/dataObject/user/openidtest20@gmail.com') { //discoverDataObjects\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/dataObject/user/openidtest20@gmail.com', criteria: {resources: ['chat'], dataSchemes: ['comm'], domain: domain}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'comm://ist.pt/1':\n                        {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                         url: 'comm://ist.pt/1',\n                         name: 'mychat',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/hyperty/url/ist.pt/1') { //discoverHypertyPerURL\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/hyperty/url/ist.pt/1', criteria: { domain: domain}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'hyperty://ist.pt/1':\n                        {descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/dataObject/url/ist.pt/1') { //discoverDataObjectPerURL\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/dataObject/url/ist.pt/1', criteria: { domain: domain}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'comm://ist.pt/1':\n                        {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                         url: 'comm://ist.pt/1',\n                         name: 'mychat',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/dataObject/name/myChat') { //discoverDataObjectsPerName\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/dataObject/name/myChat', criteria: {resources: ['chat'], dataSchemes: ['comm'], domain: domain}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'comm://ist.pt/1':\n                        {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                         url: 'comm://ist.pt/1',\n                         name: 'mychat',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      } else if (msg.body.resource === '/dataObject/reporter/hyperty://ist.pt/1') { //discoverDataObjectsPerReporter\n        expect(msg).to.eql({\n          type: 'read', from: domain, to: runtimeURL + \"/discovery/\",\n          body: {resource: '/dataObject/reporter/hyperty://ist.pt/1', criteria: {resources: ['chat'], dataSchemes: ['comm'], domain: domain}}\n        });\n        replyCallback({\n          id: 1, type: 'response', to: msg.from, from: msg.to, body: {code: 200,\n            assertedIdentity: 'user://google.com/openidtest20@gmail.com',\n            value: {'comm://ist.pt/1':\n                        {schema: 'hyperty-catalogue://catalogue.hybroker.rethink.ptinovacao.pt/.well-known/dataschema/Communication',\n                         url: 'comm://ist.pt/1',\n                         name: 'mychat',\n                         lastModified: '\"2016-03-03T13:32:06Z\"',\n                         dataSchemes: ['comm'],\n                         resources:   ['chat']}}}\n        });\n      }\n    }\n  };\n\n  let hypertyDiscovery = new HypertyDiscovery(domain, runtimeURL, messageBus);\n\n  describe('constructor()', function() {\n    it('should create a HypertyDiscovery object without error', function() {\n      expect(hypertyDiscovery.discoveryURL).to.be.equal(domain);\n    });\n  });\n  //deprecated\n  describe('discoverHypertyPerUser()', function() {\n    it('should return a Promise with an Identity using the default domain', function(done) {\n\n      let expectedMessage = {id: 'openidtest10@gmail.com',\n                            descriptor: 'hyperty-catalogue://ist.pt/.well-known/hyperty/HelloHyperty',\n                            hypertyURL: 'hyperty://ist.pt/1'};\n\n        expect(hypertyDiscovery.discoverHypertyPerUser('openidtest10@gmail.com').then(function(response) {\n        console.log('Response->', response);\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedMessage).and.notify(done);\n\n    });\n\n    it('should return a Promise with an Identity using a given domain', function(done) {\n\n      let expectedMessage = {id: 'openidtest10@specific.com',\n                            descriptor: 'hyperty-catalogue://specific.com/.well-known/hyperty/HelloHyperty',\n                            hypertyURL: 'hyperty://specific.com/1'};\n\n      expect(hypertyDiscovery.discoverHypertyPerUser('openidtest10@specific.com', 'specific.com').then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedMessage).and.notify(done);\n    });\n  });\n  //deprecated\n  describe('discoverHyperty()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverHyperty('user://gmail.com/openidtest20', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedHypertyMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverHypertiesPerUserProfileData()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverHypertiesPerUserProfileData('openidtest20', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedHypertyMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverDataObjectsPerUserProfileData()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverDataObjectsPerUserProfileData('openidtest20', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedDataObjectMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverHypertiesPerGUID()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverHypertiesPerGUID('user-guid://3vGnMSSVVhJL7soMC9tSj6DyIxWUNrzj3BNBcbUyceo', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedHypertyMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverDataObjectsPerGUID()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverDataObjectsPerGUID('user-guid://3vGnMSSVVhJL7soMC9tSj6DyIxWUNrzj3BNBcbUyceo', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedDataObjectMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverHyperties()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverHyperties('openidtest20@gmail.com', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedHypertyMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverDataObjects()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverDataObjects('openidtest20@gmail.com', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedDataObjectMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverHypertyPerURL()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverHypertyPerURL('ist.pt/1').then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedHypertyMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverDataObjectPerURL()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverDataObjectPerURL('ist.pt/1').then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedDataObjectMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverDataObjectsPerName()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverDataObjectsPerName('myChat', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedDataObjectMessage).and.notify(done);\n    });\n  });\n\n  describe('discoverDataObjectsPerReporter()', function() {\n    it('should conclude the advanced search without error', function(done) {\n\n      expect(hypertyDiscovery.discoverDataObjectsPerReporter('hyperty://ist.pt/1', ['comm'], ['chat']).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedDataObjectMessage).and.notify(done);\n    });\n  });\n\n});\n",
    "static": true,
    "longname": "test/Discovery.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 435,
    "kind": "testDescribe",
    "name": "describe30",
    "testId": 30,
    "memberof": "test/Discovery.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30",
    "access": null,
    "description": "Discovery",
    "lineNumber": 9
  },
  {
    "__docId__": 436,
    "kind": "testDescribe",
    "name": "describe31",
    "testId": 31,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe31",
    "access": null,
    "description": "constructor()",
    "lineNumber": 226
  },
  {
    "__docId__": 437,
    "kind": "testIt",
    "name": "it32",
    "testId": 32,
    "memberof": "test/Discovery.spec.js~describe30.describe31",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe31.it32",
    "access": null,
    "description": "should create a HypertyDiscovery object without error",
    "lineNumber": 227
  },
  {
    "__docId__": 438,
    "kind": "testDescribe",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe33",
    "access": null,
    "description": "discoverHypertyPerUser()",
    "lineNumber": 232
  },
  {
    "__docId__": 439,
    "kind": "testIt",
    "name": "it34",
    "testId": 34,
    "memberof": "test/Discovery.spec.js~describe30.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe33.it34",
    "access": null,
    "description": "should return a Promise with an Identity using the default domain",
    "lineNumber": 233
  },
  {
    "__docId__": 440,
    "kind": "testIt",
    "name": "it35",
    "testId": 35,
    "memberof": "test/Discovery.spec.js~describe30.describe33",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe33.it35",
    "access": null,
    "description": "should return a Promise with an Identity using a given domain",
    "lineNumber": 246
  },
  {
    "__docId__": 441,
    "kind": "testDescribe",
    "name": "describe36",
    "testId": 36,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe36",
    "access": null,
    "description": "discoverHyperty()",
    "lineNumber": 258
  },
  {
    "__docId__": 442,
    "kind": "testIt",
    "name": "it37",
    "testId": 37,
    "memberof": "test/Discovery.spec.js~describe30.describe36",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe36.it37",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 259
  },
  {
    "__docId__": 443,
    "kind": "testDescribe",
    "name": "describe38",
    "testId": 38,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe38",
    "access": null,
    "description": "discoverHypertiesPerUserProfileData()",
    "lineNumber": 267
  },
  {
    "__docId__": 444,
    "kind": "testIt",
    "name": "it39",
    "testId": 39,
    "memberof": "test/Discovery.spec.js~describe30.describe38",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe38.it39",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 268
  },
  {
    "__docId__": 445,
    "kind": "testDescribe",
    "name": "describe40",
    "testId": 40,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe40",
    "access": null,
    "description": "discoverDataObjectsPerUserProfileData()",
    "lineNumber": 276
  },
  {
    "__docId__": 446,
    "kind": "testIt",
    "name": "it41",
    "testId": 41,
    "memberof": "test/Discovery.spec.js~describe30.describe40",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe40.it41",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 277
  },
  {
    "__docId__": 447,
    "kind": "testDescribe",
    "name": "describe42",
    "testId": 42,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe42",
    "access": null,
    "description": "discoverHypertiesPerGUID()",
    "lineNumber": 285
  },
  {
    "__docId__": 448,
    "kind": "testIt",
    "name": "it43",
    "testId": 43,
    "memberof": "test/Discovery.spec.js~describe30.describe42",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe42.it43",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 286
  },
  {
    "__docId__": 449,
    "kind": "testDescribe",
    "name": "describe44",
    "testId": 44,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe44",
    "access": null,
    "description": "discoverDataObjectsPerGUID()",
    "lineNumber": 294
  },
  {
    "__docId__": 450,
    "kind": "testIt",
    "name": "it45",
    "testId": 45,
    "memberof": "test/Discovery.spec.js~describe30.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe44.it45",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 295
  },
  {
    "__docId__": 451,
    "kind": "testDescribe",
    "name": "describe46",
    "testId": 46,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe46",
    "access": null,
    "description": "discoverHyperties()",
    "lineNumber": 303
  },
  {
    "__docId__": 452,
    "kind": "testIt",
    "name": "it47",
    "testId": 47,
    "memberof": "test/Discovery.spec.js~describe30.describe46",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe46.it47",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 304
  },
  {
    "__docId__": 453,
    "kind": "testDescribe",
    "name": "describe48",
    "testId": 48,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe48",
    "access": null,
    "description": "discoverDataObjects()",
    "lineNumber": 312
  },
  {
    "__docId__": 454,
    "kind": "testIt",
    "name": "it49",
    "testId": 49,
    "memberof": "test/Discovery.spec.js~describe30.describe48",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe48.it49",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 313
  },
  {
    "__docId__": 455,
    "kind": "testDescribe",
    "name": "describe50",
    "testId": 50,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe50",
    "access": null,
    "description": "discoverHypertyPerURL()",
    "lineNumber": 321
  },
  {
    "__docId__": 456,
    "kind": "testIt",
    "name": "it51",
    "testId": 51,
    "memberof": "test/Discovery.spec.js~describe30.describe50",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe50.it51",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 322
  },
  {
    "__docId__": 457,
    "kind": "testDescribe",
    "name": "describe52",
    "testId": 52,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe52",
    "access": null,
    "description": "discoverDataObjectPerURL()",
    "lineNumber": 330
  },
  {
    "__docId__": 458,
    "kind": "testIt",
    "name": "it53",
    "testId": 53,
    "memberof": "test/Discovery.spec.js~describe30.describe52",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe52.it53",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 331
  },
  {
    "__docId__": 459,
    "kind": "testDescribe",
    "name": "describe54",
    "testId": 54,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe54",
    "access": null,
    "description": "discoverDataObjectsPerName()",
    "lineNumber": 339
  },
  {
    "__docId__": 460,
    "kind": "testIt",
    "name": "it55",
    "testId": 55,
    "memberof": "test/Discovery.spec.js~describe30.describe54",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe54.it55",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 340
  },
  {
    "__docId__": 461,
    "kind": "testDescribe",
    "name": "describe56",
    "testId": 56,
    "memberof": "test/Discovery.spec.js~describe30",
    "testDepth": 1,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe56",
    "access": null,
    "description": "discoverDataObjectsPerReporter()",
    "lineNumber": 348
  },
  {
    "__docId__": 462,
    "kind": "testIt",
    "name": "it57",
    "testId": 57,
    "memberof": "test/Discovery.spec.js~describe30.describe56",
    "testDepth": 2,
    "static": true,
    "longname": "test/Discovery.spec.js~describe30.describe56.it57",
    "access": null,
    "description": "should conclude the advanced search without error",
    "lineNumber": 349
  },
  {
    "__docId__": 463,
    "kind": "testFile",
    "name": "test/IdentityFactory.spec.js",
    "content": "import MessageBodyIdentity from '../src/identity/MessageBodyIdentity.js';\nimport UserProfile from '../src/identity/UserProfile.js';\n\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\n\nlet expect = chai.expect;\nchai.use(chaiAsPromised);\n\n//Testing the Message factory\ndescribe('IdentityFactory', function() {\n  let identity;\n\n  describe('constructor()', function() {\n    it('should create an Identity object without error', function(done) {\n\n      let username = 'alice';\n      let userURL = 'slack://alice@slacl.com';\n      let avatar = 'http://i.imgur.com/gVtNW22.png';\n      let cn = 'alice@slack.com';\n      let locale = 'pt';\n      let idp = 'idp.com';\n      let assertion = 'yrtt6trassertionexamplerga5tgarg';\n      identity = new MessageBodyIdentity(username, userURL, avatar, cn, locale, idp, assertion);\n      done();\n    });\n  });\n});\n",
    "static": true,
    "longname": "test/IdentityFactory.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 464,
    "kind": "testDescribe",
    "name": "describe58",
    "testId": 58,
    "memberof": "test/IdentityFactory.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/IdentityFactory.spec.js~describe58",
    "access": null,
    "description": "IdentityFactory",
    "lineNumber": 11
  },
  {
    "__docId__": 465,
    "kind": "testDescribe",
    "name": "describe59",
    "testId": 59,
    "memberof": "test/IdentityFactory.spec.js~describe58",
    "testDepth": 1,
    "static": true,
    "longname": "test/IdentityFactory.spec.js~describe58.describe59",
    "access": null,
    "description": "constructor()",
    "lineNumber": 14
  },
  {
    "__docId__": 466,
    "kind": "testIt",
    "name": "it60",
    "testId": 60,
    "memberof": "test/IdentityFactory.spec.js~describe58.describe59",
    "testDepth": 2,
    "static": true,
    "longname": "test/IdentityFactory.spec.js~describe58.describe59.it60",
    "access": null,
    "description": "should create an Identity object without error",
    "lineNumber": 15
  },
  {
    "__docId__": 467,
    "kind": "testFile",
    "name": "test/IdentityManager.spec.js",
    "content": "import IdentityManager from '../src/identityManager/IdentityManager';\n\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\n\nlet expect = chai.expect;\nchai.use(chaiAsPromised);\n\ndescribe('IdentityManager', function() {\n  let hypertyURL = 'hyperty://localhost/526e9670-593f-4641-8b63-98fa49f933a1';\n  let runtimeURL = 'runtime://localhost/1051';\n  let msgBus = {\n    postMessage: (msg, replyCallback) => {\n\n      expect(msg).to.eql({\n        type: 'read', from: hypertyURL, to: runtimeURL + '/registry/',\n        body: { resource: '.', criteria: hypertyURL}\n      });\n\n      replyCallback({\n        type: 'read', from: runtimeURL + '/registry/', to: hypertyURL,\n        body: { code: 200, resource: {cn: 'test OpenID', userURL: 'user://gmail.com/openidtest10', username: 'openidtest10@gmail.com', avatar: 'avatarURL'}}\n      });\n    }\n  };\n\n  let identityManager = new IdentityManager(hypertyURL, runtimeURL, msgBus);\n  let expectedValue = {cn: 'test OpenID', userURL: 'user://gmail.com/openidtest10', username: 'openidtest10@gmail.com', avatar: 'avatarURL'};\n\n  describe('constructor()', function() {\n    it('should create a identityManager object without error', function() {\n      expect(identityManager.runtimeURL).to.be.equal(runtimeURL);\n    });\n  });\n\n  describe('discoverUserRegistered()', function() {\n    it('should return a Promise with the identity associated', function(done) {\n\n      expect(identityManager.discoverUserRegistered().then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedValue).and.notify(done);\n    });\n\n    it('should return a Promise with the identity associated (with optional hyperty field)', function(done) {\n\n      expect(identityManager.discoverUserRegistered('.', hypertyURL).then(function(response) {\n        return response;\n      })).to.be.fulfilled.and.eventually.eql(expectedValue).and.notify(done);\n    });\n\n  });\n\n});\n",
    "static": true,
    "longname": "test/IdentityManager.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 468,
    "kind": "testDescribe",
    "name": "describe61",
    "testId": 61,
    "memberof": "test/IdentityManager.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/IdentityManager.spec.js~describe61",
    "access": null,
    "description": "IdentityManager",
    "lineNumber": 9
  },
  {
    "__docId__": 469,
    "kind": "testDescribe",
    "name": "describe62",
    "testId": 62,
    "memberof": "test/IdentityManager.spec.js~describe61",
    "testDepth": 1,
    "static": true,
    "longname": "test/IdentityManager.spec.js~describe61.describe62",
    "access": null,
    "description": "constructor()",
    "lineNumber": 30
  },
  {
    "__docId__": 470,
    "kind": "testIt",
    "name": "it63",
    "testId": 63,
    "memberof": "test/IdentityManager.spec.js~describe61.describe62",
    "testDepth": 2,
    "static": true,
    "longname": "test/IdentityManager.spec.js~describe61.describe62.it63",
    "access": null,
    "description": "should create a identityManager object without error",
    "lineNumber": 31
  },
  {
    "__docId__": 471,
    "kind": "testDescribe",
    "name": "describe64",
    "testId": 64,
    "memberof": "test/IdentityManager.spec.js~describe61",
    "testDepth": 1,
    "static": true,
    "longname": "test/IdentityManager.spec.js~describe61.describe64",
    "access": null,
    "description": "discoverUserRegistered()",
    "lineNumber": 36
  },
  {
    "__docId__": 472,
    "kind": "testIt",
    "name": "it65",
    "testId": 65,
    "memberof": "test/IdentityManager.spec.js~describe61.describe64",
    "testDepth": 2,
    "static": true,
    "longname": "test/IdentityManager.spec.js~describe61.describe64.it65",
    "access": null,
    "description": "should return a Promise with the identity associated",
    "lineNumber": 37
  },
  {
    "__docId__": 473,
    "kind": "testIt",
    "name": "it66",
    "testId": 66,
    "memberof": "test/IdentityManager.spec.js~describe61.describe64",
    "testDepth": 2,
    "static": true,
    "longname": "test/IdentityManager.spec.js~describe61.describe64.it66",
    "access": null,
    "description": "should return a Promise with the identity associated (with optional hyperty field)",
    "lineNumber": 44
  },
  {
    "__docId__": 474,
    "kind": "testFile",
    "name": "test/JsonSchemaValidation.spec.js",
    "content": "\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\nimport chaiJsonSchema from 'chai-json-schema';\nimport tv4 from \"tv4\";\n//import chai.tv4 from \"chai.tv4\";\n\nlet expect = chai.expect;\nlet assert = chai.assert;\nlet should = chai.should();\n// let tv4 = chai.tv4();\n\n\nchai.use(chaiAsPromised);\nchai.use(chaiJsonSchema);\n\n//Testing the Message factory the chai\nlet goodApple = {\n    skin: \"thin\",\n    colors: [\"red\", \"green\", \"yellow\"],\n    taste: 10\n};\nlet badApple = {\n    colors: [\"brown\"],\n    taste: 0,\n    worms: 2\n};\nlet fruitSchema = {\n    \"title\": \"fresh fruit schema v1\",\n    \"type\": \"object\",\n    \"required\": [\"skin\", \"colors\", \"taste\"],\n    \"properties\": {\n        \"colors\": {\n            \"type\": \"array\",\n            \"minItems\": 1,\n            \"uniqueItems\": true,\n            \"items\": {\n                \"type\": \"string\"\n            }\n        },\n        \"skin\": {\n            \"type\": \"string\"\n        },\n        \"taste\": {\n            \"type\": \"number\",\n            \"minimum\": 5\n        }\n    }\n};\n\n\ndescribe('schema validation of good Apple', () => {\n    describe('good Apple should be good', () => {\n        it('should return false instead of true', () => {\n            //bdd style\n            expect(goodApple).to.be.jsonSchema(fruitSchema);\n            expect(badApple).to.not.be.jsonSchema(fruitSchema);\n\n            //tdd style\n            assert.jsonSchema(goodApple, fruitSchema);\n            assert.notJsonSchema(badApple, fruitSchema);\n\n            goodApple.should.be.jsonSchema(fruitSchema);\n            badApple.should.not.be.jsonSchema(fruitSchema);\n        });\n    });\n});\n\ndescribe('adding new schema', () => {\n    it('should add a new schema', ()=>{\n        //tv4.addSchema(uri, schema);\n\n        let list = chai.tv4.getMissingUris();\n        let uris = chai.tv4.getMissingUris(/^https?:/);\n        let urisSchema = chai.tv4.getSchemaUris(/example.com/);\n\n        let schema = chai.tv4.getSchema('http://example.com/item');\n        console.log('This is the schema', schema);\n\n    });\n});\n",
    "static": true,
    "longname": "test/JsonSchemaValidation.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 475,
    "kind": "testDescribe",
    "name": "describe67",
    "testId": 67,
    "memberof": "test/JsonSchemaValidation.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/JsonSchemaValidation.spec.js~describe67",
    "access": null,
    "description": "schema validation of good Apple",
    "lineNumber": 52
  },
  {
    "__docId__": 476,
    "kind": "testDescribe",
    "name": "describe68",
    "testId": 68,
    "memberof": "test/JsonSchemaValidation.spec.js~describe67",
    "testDepth": 1,
    "static": true,
    "longname": "test/JsonSchemaValidation.spec.js~describe67.describe68",
    "access": null,
    "description": "good Apple should be good",
    "lineNumber": 53
  },
  {
    "__docId__": 477,
    "kind": "testIt",
    "name": "it69",
    "testId": 69,
    "memberof": "test/JsonSchemaValidation.spec.js~describe67.describe68",
    "testDepth": 2,
    "static": true,
    "longname": "test/JsonSchemaValidation.spec.js~describe67.describe68.it69",
    "access": null,
    "description": "should return false instead of true",
    "lineNumber": 54
  },
  {
    "__docId__": 478,
    "kind": "testDescribe",
    "name": "describe70",
    "testId": 70,
    "memberof": "test/JsonSchemaValidation.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/JsonSchemaValidation.spec.js~describe70",
    "access": null,
    "description": "adding new schema",
    "lineNumber": 69
  },
  {
    "__docId__": 479,
    "kind": "testIt",
    "name": "it71",
    "testId": 71,
    "memberof": "test/JsonSchemaValidation.spec.js~describe70",
    "testDepth": 1,
    "static": true,
    "longname": "test/JsonSchemaValidation.spec.js~describe70.it71",
    "access": null,
    "description": "should add a new schema",
    "lineNumber": 70
  },
  {
    "__docId__": 480,
    "kind": "testFile",
    "name": "test/MessageFactory.spec.js",
    "content": "import MessageFactory from '../src/message-factory/MessageFactory.js';\nimport {MessageType} from '../src/message-factory/Message.js';\nimport {RESPONSE_CODE, REASON_PHRASE} from '../src/message-factory/MessageBody.js';\n\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\n\nimport msgSchema from '../schemas/json-schema/core/Message.json'\n\nlet expect = chai.expect;\nchai.use(chaiAsPromised);\n\n//Testing the Message factory\ndescribe('MessageFactory', function () {\n    let message;\n    let messageFactory;\n\n    describe('constructor()', function () {\n        it('should create a Message Factory object without error', function (done) {\n            messageFactory = new MessageFactory();\n            done();\n        });\n    });\n\n    describe('createCreateMessageRequest()', function () {\n        it('should be a Message of Type CREATE', function (done) {\n            //(from, to, value, policy)\n            message = messageFactory.createCreateMessageRequest(\"hyperty-runtime-esn://domain.com/12345\",\n                [\"hyperty-runtime-imei://domain.com/12345\", \"hyperty-runtime-imei://domain.com/678910\"],\n                {\"audio\": 'PCMU-Codec'}, \"policyURL\");\n\n            //console.log('Create Message', JSON.stringify(message));\n            expect(message).to.not.be.empty;\n            expect(message.type).to.eql(MessageType.CREATE);\n            expect(message.validate(msgSchema)).to.be.ok;\n            done();\n        });\n    });\n\n    describe('createForwardMessageRequest()', function () {\n\n        it('should create a new Forward Message Request with a message payload', function (done) {\n\n            //from, to, message\n            let forwardMessage = messageFactory.createForwardMessageRequest(\n                \"hyperty-runtime-esn://fromdomain.com/12345\", [\"hyperty-runtime-imei://todomain.com/12345\"],\n                message);\n\n            //console.log('Forward Message Request', JSON.stringify(forwardMessage));\n            expect(forwardMessage).to.not.be.empty;\n            expect(forwardMessage.type).to.eql(MessageType.FORWARD);\n            expect(forwardMessage.validate(msgSchema)).to.be.ok;\n            done();\n        });\n    });\n\n    describe('createDeleteMessageRequest()', function () {\n        it('should be a Message of Type DELETE', function (done) {\n            //createDeleteMessageRequest(from, to, resource, attribute) ;\n            let message = messageFactory.createDeleteMessageRequest(\"hyperty-runtime-esn://domain.com/12345\",\n                [\"hyperty-runtime-imei://domain.com/123456\"], \"hyperty-runtime-uuid://domain.com/myResource\",\n                \"audio\");\n\n            //console.log('Delete Message', JSON.stringify(message));\n            expect(message).to.not.be.empty;\n            expect(message.type).to.eql(MessageType.DELETE);\n            expect(message.validate(msgSchema)).to.be.ok;\n\n            done();\n        });\n    });\n\n\n    describe('createUpdateMessageRequest()', function () {\n        it('should be a Message of Type UPDATE', function (done) {\n            //createUpdateMessageRequest(from, to, value, resource, attribute)\n            let message = messageFactory.createUpdateMessageRequest(\"hyperty-esn://domain.com/12345\",\n                [\"hyperty-imei://domain.com/123456\"], \"audio-only\", \"hyperty-runtime-uuid://domain.com/myResource\",\n                \"audio\");\n\n            //console.log('Update Message', JSON.stringify(message));\n            expect(message).to.not.be.empty;\n            expect(message.type).to.eql(MessageType.UPDATE);\n            expect(message.validate(msgSchema)).to.be.ok;\n\n            done();\n        });\n    });\n\n    describe('createReadMessageRequest()', function () {\n        it('should be a Message of Type READ', function (done) {\n            //createReadMessageRequest(from, to, resource, attribute);\n            let readMessage = messageFactory.createReadMessageRequest(\"hyperty-esn://domain.com/12345\",\n                [\"hyperty-imei://domain.com/123456\"], \"hyperty-runtime-uuid://domain.com/myResource\",\n                \"audio\");\n\n            //console.log('Update Message', JSON.stringify(readMessage));\n            expect(readMessage).to.not.be.empty;\n            expect(readMessage.type).to.eql(MessageType.READ);\n            expect(readMessage.validate(msgSchema)).to.be.ok;\n\n            done();\n        });\n    });\n\n    describe('createSubscribeMessageRequest()', function () {\n        it('should be a Message of Type SUBSCRIBE', function (done) {\n            //createSubscribeMessageRequest(from, to, resource);\n            let subscribeMessage = messageFactory.createSubscribeMessageRequest(\"hyperty-esn://domain.com/12345\",\n                [\"hyperty-imei://domain.com/123456\"], \"hyperty-runtime-uuid://domain.com/myResource-sub\");\n\n            //console.log('UNSUBSCRIBE Message', JSON.stringify(subscribeMessage));\n            expect(subscribeMessage).to.not.be.empty;\n            expect(subscribeMessage.type).to.eql(MessageType.SUBSCRIBE);\n            expect(subscribeMessage.validate(msgSchema)).to.be.ok;\n\n            done();\n        });\n    });\n\n    describe('createUnSubscribeMessageRequest()', function () {\n        it('should be a Message of Type SUBSCRIBE', function (done) {\n            //createSubscribeMessageRequest(from, to, resource);\n            let unSubscribeMessage = messageFactory.createUnsubscribeMessageRequest(\"hyperty-esn://domain.com/12345\",\n                [\"hyperty-imei://domain.com/123456\"], \"hyperty-runtime-uuid://domain.com/myResource-unsub\");\n\n            //console.log('SUBSCRIBE Message', JSON.stringify(unSubscribeMessage));\n            expect(unSubscribeMessage).to.not.be.empty;\n            expect(unSubscribeMessage.type).to.eql(MessageType.UNSUBSCRIBE);\n            expect(unSubscribeMessage.validate(msgSchema)).to.be.ok;\n\n            done();\n        });\n    });\n\n    describe('assertIdentity()', function () {\n        it('should add asserted identity to the given message', function (done) {\n            //assertIdentity(token, identity)\n            message.assertIdentity(\"token\", \"alicem@frauhofer.fokus.de\");\n            //console.log('asserted Identity Message', JSON.stringify(message));\n            expect(message.body.assertedIdentity).to.eql(\"alicem@frauhofer.fokus.de\");\n            done();\n        });\n    });\n\n    describe('addAccessToken()', function () {\n        it('should add asserted identity to the given message', function (done) {\n            //addAccessToken(token)\n            message.addAccessToken(\"7z94rif97z39gfi9v33893z3\");\n            //console.log('Updated Message', JSON.stringify(updatedMessage));\n            expect(message.body.accessToken).to.eql(\"7z94rif97z39gfi9v33893z3\");\n            done();\n        });\n    });\n\n    describe('addIdToken()', function () {\n        it('should add asserted identity to the given message', function (done) {\n            //addIdToken(token)\n            message.addIdToken(\"3jwwjhw89whbhuf9z439zhfih94z\");\n            //console.log('Updated Message', JSON.stringify(message));\n            expect(message.body.idToken).to.eql(\"3jwwjhw89whbhuf9z439zhfih94z\");\n            done();\n        });\n    });\n\n    describe('createExecuteMessageRequest()', function () {\n\n        it('should create a new Execute Message Request', function (done) {\n\n            //from, to, method, params\n            let executeMessage = messageFactory.createExecuteMessageRequest(\n                \"hyperty-runtime-esn://fromdomain.com/12345\", \"[hyperty-runtime-imei://todomain.com/12345]\",\n                \"read\", ['Param1', 'Param2']);\n\n            //console.log('Execute Message Request', JSON.stringify(executeMessage));\n            expect(executeMessage).to.not.be.empty;\n            expect(executeMessage.type).to.eql(MessageType.EXECUTE);\n            done();\n        });\n    });\n\n    describe('createMessageResponse()', function () {\n        it('should be a Response Message of Type RESPONSE', function (done) {\n            //message, code, value, source\n            let response = messageFactory.createMessageResponse(message, RESPONSE_CODE[200], REASON_PHRASE[200]);\n            //console.log(\"response code:\"+RESPONSE_CODE[200]+ \"reason phrase: \"+REASON_PHRASE[200]);\n            //console.log('Response Message', JSON.stringify(response));\n            expect(response).to.not.be.empty;\n            expect(response.type).to.eql(MessageType.RESPONSE);\n            done();\n        });\n\n    });\n});\n\n",
    "static": true,
    "longname": "test/MessageFactory.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 481,
    "kind": "testDescribe",
    "name": "describe72",
    "testId": 72,
    "memberof": "test/MessageFactory.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72",
    "access": null,
    "description": "MessageFactory",
    "lineNumber": 14
  },
  {
    "__docId__": 482,
    "kind": "testDescribe",
    "name": "describe73",
    "testId": 73,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe73",
    "access": null,
    "description": "constructor()",
    "lineNumber": 18
  },
  {
    "__docId__": 483,
    "kind": "testIt",
    "name": "it74",
    "testId": 74,
    "memberof": "test/MessageFactory.spec.js~describe72.describe73",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe73.it74",
    "access": null,
    "description": "should create a Message Factory object without error",
    "lineNumber": 19
  },
  {
    "__docId__": 484,
    "kind": "testDescribe",
    "name": "describe75",
    "testId": 75,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe75",
    "access": null,
    "description": "createCreateMessageRequest()",
    "lineNumber": 25
  },
  {
    "__docId__": 485,
    "kind": "testIt",
    "name": "it76",
    "testId": 76,
    "memberof": "test/MessageFactory.spec.js~describe72.describe75",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe75.it76",
    "access": null,
    "description": "should be a Message of Type CREATE",
    "lineNumber": 26
  },
  {
    "__docId__": 486,
    "kind": "testDescribe",
    "name": "describe77",
    "testId": 77,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe77",
    "access": null,
    "description": "createForwardMessageRequest()",
    "lineNumber": 40
  },
  {
    "__docId__": 487,
    "kind": "testIt",
    "name": "it78",
    "testId": 78,
    "memberof": "test/MessageFactory.spec.js~describe72.describe77",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe77.it78",
    "access": null,
    "description": "should create a new Forward Message Request with a message payload",
    "lineNumber": 42
  },
  {
    "__docId__": 488,
    "kind": "testDescribe",
    "name": "describe79",
    "testId": 79,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe79",
    "access": null,
    "description": "createDeleteMessageRequest()",
    "lineNumber": 57
  },
  {
    "__docId__": 489,
    "kind": "testIt",
    "name": "it80",
    "testId": 80,
    "memberof": "test/MessageFactory.spec.js~describe72.describe79",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe79.it80",
    "access": null,
    "description": "should be a Message of Type DELETE",
    "lineNumber": 58
  },
  {
    "__docId__": 490,
    "kind": "testDescribe",
    "name": "describe81",
    "testId": 81,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe81",
    "access": null,
    "description": "createUpdateMessageRequest()",
    "lineNumber": 74
  },
  {
    "__docId__": 491,
    "kind": "testIt",
    "name": "it82",
    "testId": 82,
    "memberof": "test/MessageFactory.spec.js~describe72.describe81",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe81.it82",
    "access": null,
    "description": "should be a Message of Type UPDATE",
    "lineNumber": 75
  },
  {
    "__docId__": 492,
    "kind": "testDescribe",
    "name": "describe83",
    "testId": 83,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe83",
    "access": null,
    "description": "createReadMessageRequest()",
    "lineNumber": 90
  },
  {
    "__docId__": 493,
    "kind": "testIt",
    "name": "it84",
    "testId": 84,
    "memberof": "test/MessageFactory.spec.js~describe72.describe83",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe83.it84",
    "access": null,
    "description": "should be a Message of Type READ",
    "lineNumber": 91
  },
  {
    "__docId__": 494,
    "kind": "testDescribe",
    "name": "describe85",
    "testId": 85,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe85",
    "access": null,
    "description": "createSubscribeMessageRequest()",
    "lineNumber": 106
  },
  {
    "__docId__": 495,
    "kind": "testIt",
    "name": "it86",
    "testId": 86,
    "memberof": "test/MessageFactory.spec.js~describe72.describe85",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe85.it86",
    "access": null,
    "description": "should be a Message of Type SUBSCRIBE",
    "lineNumber": 107
  },
  {
    "__docId__": 496,
    "kind": "testDescribe",
    "name": "describe87",
    "testId": 87,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe87",
    "access": null,
    "description": "createUnSubscribeMessageRequest()",
    "lineNumber": 121
  },
  {
    "__docId__": 497,
    "kind": "testIt",
    "name": "it88",
    "testId": 88,
    "memberof": "test/MessageFactory.spec.js~describe72.describe87",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe87.it88",
    "access": null,
    "description": "should be a Message of Type SUBSCRIBE",
    "lineNumber": 122
  },
  {
    "__docId__": 498,
    "kind": "testDescribe",
    "name": "describe89",
    "testId": 89,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe89",
    "access": null,
    "description": "assertIdentity()",
    "lineNumber": 136
  },
  {
    "__docId__": 499,
    "kind": "testIt",
    "name": "it90",
    "testId": 90,
    "memberof": "test/MessageFactory.spec.js~describe72.describe89",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe89.it90",
    "access": null,
    "description": "should add asserted identity to the given message",
    "lineNumber": 137
  },
  {
    "__docId__": 500,
    "kind": "testDescribe",
    "name": "describe91",
    "testId": 91,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe91",
    "access": null,
    "description": "addAccessToken()",
    "lineNumber": 146
  },
  {
    "__docId__": 501,
    "kind": "testIt",
    "name": "it92",
    "testId": 92,
    "memberof": "test/MessageFactory.spec.js~describe72.describe91",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe91.it92",
    "access": null,
    "description": "should add asserted identity to the given message",
    "lineNumber": 147
  },
  {
    "__docId__": 502,
    "kind": "testDescribe",
    "name": "describe93",
    "testId": 93,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe93",
    "access": null,
    "description": "addIdToken()",
    "lineNumber": 156
  },
  {
    "__docId__": 503,
    "kind": "testIt",
    "name": "it94",
    "testId": 94,
    "memberof": "test/MessageFactory.spec.js~describe72.describe93",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe93.it94",
    "access": null,
    "description": "should add asserted identity to the given message",
    "lineNumber": 157
  },
  {
    "__docId__": 504,
    "kind": "testDescribe",
    "name": "describe95",
    "testId": 95,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe95",
    "access": null,
    "description": "createExecuteMessageRequest()",
    "lineNumber": 166
  },
  {
    "__docId__": 505,
    "kind": "testIt",
    "name": "it96",
    "testId": 96,
    "memberof": "test/MessageFactory.spec.js~describe72.describe95",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe95.it96",
    "access": null,
    "description": "should create a new Execute Message Request",
    "lineNumber": 168
  },
  {
    "__docId__": 506,
    "kind": "testDescribe",
    "name": "describe97",
    "testId": 97,
    "memberof": "test/MessageFactory.spec.js~describe72",
    "testDepth": 1,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe97",
    "access": null,
    "description": "createMessageResponse()",
    "lineNumber": 182
  },
  {
    "__docId__": 507,
    "kind": "testIt",
    "name": "it98",
    "testId": 98,
    "memberof": "test/MessageFactory.spec.js~describe72.describe97",
    "testDepth": 2,
    "static": true,
    "longname": "test/MessageFactory.spec.js~describe72.describe97.it98",
    "access": null,
    "description": "should be a Response Message of Type RESPONSE",
    "lineNumber": 183
  },
  {
    "__docId__": 508,
    "kind": "testFile",
    "name": "test/RuntimeCapabilities.spec.js",
    "content": "import chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\nimport sinonChai from 'sinon-chai';\n\nimport Dexie from 'dexie';\n\nimport StorageManager from '../src/storage-manager/StorageManager';\nimport RuntimeCapabilities from '../src/runtime-capabilities/RuntimeCapabilities';\n\nchai.use(sinonChai);\nchai.use(chaiAsPromised);\nchai.config.truncateThreshold = 0;\n\nlet expect = chai.expect;\n\n// Testing Runtime Capabilities\ndescribe('Runtime Runtime Capabilities', () => {\n\n  let getEnvironment;\n  let getMediaDevices;\n  let storageManager;\n  let runtimeCapabilities;\n\n  before(() => {\n\n    const db = new Dexie('cache');\n    const storeName = 'objects';\n    storageManager = new StorageManager(db, storeName);\n\n    runtimeCapabilities = new RuntimeCapabilities();\n\n    sinon.stub(runtimeCapabilities, 'getRuntimeCapabilities', () => {\n      return new Promise((resolve, reject) => {\n\n        Promise.all([getEnvironment(), getMediaDevices()]).then((result) => {\n          let capabilities = {};\n          result.forEach((capability) => {\n            Object.assign(capabilities, capability);\n          });\n          storageManager.set('capabilities', '1', capabilities);\n          expect(capabilities).to.contain.any.keys('browser', 'node');\n          resolve(capabilities);\n        }).catch((error) => {\n          reject(error);\n        });\n\n      });\n    });\n\n    sinon.stub(runtimeCapabilities, 'isAvailable', (capability) => {\n      return new Promise((resolve) => {\n\n        storageManager.get('capabilities').then((capabilities) => {\n\n          console.log('Capability ' + capability + ' is available? ', capabilities.hasOwnProperty(capability) && capabilities[capability]);\n          if (capabilities.hasOwnProperty(capability) && capabilities[capability]) {\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        });\n\n      });\n    });\n\n    sinon.stub(runtimeCapabilities, 'update', () => {\n      return new Promise((resolve, reject) => {\n        runtimeCapabilities.getRuntimeCapabilities().then(resolve).catch(reject);\n      });\n    });\n\n    getEnvironment = () => {\n\n      return {\n        browser: !!(navigator),\n        node: !(navigator)\n      };\n    };\n\n    getMediaDevices = () => {\n      return new Promise((resolve) => {\n\n        let capability = {};\n\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n          console.log('enumerateDevices() not supported.');\n          resolve(capability);\n          return;\n        }\n\n        // List cameras and microphones.\n        navigator.mediaDevices.enumerateDevices()\n        .then((devices) => {\n          devices.forEach((device) => {\n            // console.log(device.kind, device.label, device.deviceId);\n            if (device.kind === 'audioinput' && device.deviceId === 'default') {\n              capability.mic = true;\n            }\n\n            if (device.kind === 'videoinput') {\n              capability.camera = true;\n            }\n          });\n          resolve(capability);\n        })\n        .catch((err) => {\n          resolve(capability);\n          console.log(err.name + ': ' + err.message);\n        });\n      });\n    };\n\n  });\n\n  after(() => {\n    runtimeCapabilities.getRuntimeCapabilities.restore();\n    runtimeCapabilities.isAvailable.restore();\n    runtimeCapabilities.update.restore();\n  });\n\n  it('should return a promise with RuntimeCapabilities and save on storageManager', (done) => {\n\n    expect(runtimeCapabilities.getRuntimeCapabilities()).to.be.fulfilled\n    .and.to.be.instanceof(Promise)\n    .and.notify(done);\n\n  });\n\n  it('should return if a capability was available', (done) => {\n\n    // let capabilities = [\n    //   'browser', 'node', 'windowSandbox',\n    //   'mic', 'camera', 'sensor', 'webrtc',\n    //   'ortc', 'http', 'https', 'ws',\n    //   'wss', 'coap', 'datachannel'];\n\n    expect(runtimeCapabilities.isAvailable('node'))\n    .to.be.fulfilled\n    .and.to.be.instanceof(Promise)\n    .and.to.eventually.equal(false);\n\n    expect(runtimeCapabilities.isAvailable('sensor'))\n    .to.be.fulfilled\n    .and.to.be.instanceof(Promise)\n    .and.to.eventually.equal(false);\n\n    expect(runtimeCapabilities.isAvailable('browser'))\n    .to.be.fulfilled\n    .and.to.be.instanceof(Promise)\n    .and.to.eventually.equal(true)\n    .and.notify(done);\n\n  });\n\n  it('should update the previous capabilites', (done) => {\n    expect(runtimeCapabilities.update())\n    .to.be.fulfilled\n    .and.notify(done);\n  });\n\n});\n",
    "static": true,
    "longname": "test/RuntimeCapabilities.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 509,
    "kind": "testDescribe",
    "name": "describe99",
    "testId": 99,
    "memberof": "test/RuntimeCapabilities.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/RuntimeCapabilities.spec.js~describe99",
    "access": null,
    "description": "Runtime Runtime Capabilities",
    "lineNumber": 17
  },
  {
    "__docId__": 510,
    "kind": "testIt",
    "name": "it100",
    "testId": 100,
    "memberof": "test/RuntimeCapabilities.spec.js~describe99",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCapabilities.spec.js~describe99.it100",
    "access": null,
    "description": "should return a promise with RuntimeCapabilities and save on storageManager",
    "lineNumber": 121
  },
  {
    "__docId__": 511,
    "kind": "testIt",
    "name": "it101",
    "testId": 101,
    "memberof": "test/RuntimeCapabilities.spec.js~describe99",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCapabilities.spec.js~describe99.it101",
    "access": null,
    "description": "should return if a capability was available",
    "lineNumber": 129
  },
  {
    "__docId__": 512,
    "kind": "testIt",
    "name": "it102",
    "testId": 102,
    "memberof": "test/RuntimeCapabilities.spec.js~describe99",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCapabilities.spec.js~describe99.it102",
    "access": null,
    "description": "should update the previous capabilites",
    "lineNumber": 155
  },
  {
    "__docId__": 513,
    "kind": "testFile",
    "name": "test/RuntimeCatalogue.spec.js",
    "content": "import chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\nimport sinonChai from 'sinon-chai';\n\nlet expect = chai.expect;\n\nchai.config.truncateThreshold = 0;\nchai.use(chaiAsPromised);\nchai.use(sinonChai);\n\nimport {RuntimeCatalogue} from '../src/RuntimeCatalogue';\nimport RuntimeFactory from './resources/RuntimeFactory';\n\nimport HypertyDescriptor from '../src/catalogue-factory/HypertyDescriptor';\nimport ProtocolStubDescriptor from '../src/catalogue-factory/ProtocolStubDescriptor';\nimport HypertyRuntimeDescriptor from '../src/catalogue-factory/HypertyRuntimeDescriptor';\nimport DataObjectSchema from '../src/catalogue-factory/DataObjectSchema';\nimport SourcePackage from '../src/catalogue-factory/SourcePackage';\n\nimport {divideURL} from '../src/utils/utils';\n\n/**\n * PLEASE NOTE:\n * This test requires locally running Catalogue Broker and Catalogue Database,\n * using the default catalogue_objects folder.\n *\n * Start the Catalogue Broker with:\n *      sudo java -jar catalogue_broker/target/rethink-catalogue-broker-*-jar-with-dependencies.jar -http 80\n *\n * Start the Catalogue Database with:\n *      java -jar catalogue_database/target/rethink-catalogue-database-*-jar-with-dependencies.jar -usehttp\n */\n\n// Testing RuntimeCatalogue\ndescribe('Runtime Catalogue', function () {\n    let domain = 'localhost';\n    let hypertyName = \"FirstHyperty\";\n    let protostubName = \"FirstProtostub\";\n    let runtimeName = \"FirstRuntime\";\n    let schemaName = \"FirstDataSchema\";\n    let idpproxyName = \"FirstProxy\";\n\n    let runtimeFactory = new RuntimeFactory();\n\n    let runtimeCatalogue = new RuntimeCatalogue(runtimeFactory);\n    runtimeCatalogue.runtimeURL = domain;\n    let tempHypertyDescriptor;\n\n    it('should get hyperty descriptor', function (done) {\n        let hypertyDescriptorURL = 'hyperty-catalogue://' + domain + '/.well-known/hyperty/' + hypertyName;\n        expect(runtimeCatalogue.getHypertyDescriptor(hypertyDescriptorURL).then((hypertyDescriptor) => {\n            //console.info(\"getHypertyDescriptor returned:\", JSON.stringify(hypertyDescriptor, null, 2));\n            tempHypertyDescriptor = hypertyDescriptor;\n            return hypertyDescriptor;\n        })).to.eventually.be.instanceof(HypertyDescriptor).and.notify(done);\n    });\n\n    it('should get sourcePackage', function (done) {\n        expect(runtimeCatalogue.getSourcePackageFromURL(tempHypertyDescriptor.sourcePackageURL).then((sourcePackage) => {\n            //console.info(\"getSourcePackageFromURL returned:\", JSON.stringify(sourcePackage, null, 2));\n            return sourcePackage;\n        })).to.eventually.be.instanceof(SourcePackage).and.notify(done);\n    });\n\n\n    it('should get hyperty source code', function (done) {\n        expect(runtimeCatalogue.getSourceCodeFromDescriptor(tempHypertyDescriptor).then((sourceCode) => {\n            //console.info(\"getSourceCodeFromDescriptor returned:\", sourceCode);\n            return sourceCode;\n        })).to.be.fulfilled.and.notify(done);\n\n    });\n\n    it('should get protostub descriptor', function (done) {\n        let protostubURL = 'hyperty-catalogue://' + domain + '/.well-known/protocolstub/' + protostubName;\n        expect(runtimeCatalogue.getStubDescriptor(protostubURL).then((protostub) => {\n            //console.info(\"getStubDescriptor returned:\", JSON.stringify(protostub, null, 2));\n            return protostub;\n        })).to.eventually.be.instanceof(ProtocolStubDescriptor).and.notify(done);\n    });\n\n    it('should get runtime descriptor', function (done) {\n        let runtimeURL = 'hyperty-catalogue://' + domain + '/.well-known/runtime/' + runtimeName;\n        expect(runtimeCatalogue.getRuntimeDescriptor(runtimeURL).then((runtime) => {\n            //console.info(\"getRuntimeDescriptor returned:\", JSON.stringify(runtime, null, 2));\n            return runtime;\n        })).to.eventually.be.instanceof(HypertyRuntimeDescriptor).and.notify(done);\n    });\n\n    it('should get dataschema descriptor', function (done) {\n        let schemaURL = 'hyperty-catalogue://' + domain + '/.well-known/dataschema/' + schemaName;\n        expect(runtimeCatalogue.getDataSchemaDescriptor(schemaURL).then((schemaDescriptor) => {\n            //console.info(\"getDataSchemaDescriptor returned:\", JSON.stringify(schemaDescriptor, null, 2));\n            return schemaDescriptor;\n        })).to.eventually.be.instanceof(DataObjectSchema).and.notify(done);\n    });\n\n    it('should get idpproxy descriptor', function (done) {\n        let protostubURL = 'hyperty-catalogue://' + domain + '/.well-known/idp-proxy/' + idpproxyName;\n        expect(runtimeCatalogue.getIdpProxyDescriptor(protostubURL).then((proxyDescriptor) => {\n            //console.info(\"getIdpProxyDescriptor returned:\", JSON.stringify(proxyDescriptor, null, 2));\n            return proxyDescriptor;\n        })).to.eventually.be.instanceof(ProtocolStubDescriptor).and.notify(done);\n    });\n\n    it('should NOT get hyperty', function (done) {\n        let hypertyDescriptorURL = 'someInvalidURL';\n        expect(runtimeCatalogue.getHypertyDescriptor(hypertyDescriptorURL).then((hypertyDescriptor) => {\n            //console.info(\"getHypertyDescriptor returned:\", JSON.stringify(hypertyDescriptor, null, 2));\n            tempHypertyDescriptor = hypertyDescriptor;\n            return hypertyDescriptor;\n        })).to.be.rejected.and.notify(done);\n    });\n\n});\n",
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 514,
    "kind": "testDescribe",
    "name": "describe103",
    "testId": 103,
    "memberof": "test/RuntimeCatalogue.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103",
    "access": null,
    "description": "Runtime Catalogue",
    "lineNumber": 35
  },
  {
    "__docId__": 515,
    "kind": "testIt",
    "name": "it104",
    "testId": 104,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it104",
    "access": null,
    "description": "should get hyperty descriptor",
    "lineNumber": 49
  },
  {
    "__docId__": 516,
    "kind": "testIt",
    "name": "it105",
    "testId": 105,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it105",
    "access": null,
    "description": "should get sourcePackage",
    "lineNumber": 58
  },
  {
    "__docId__": 517,
    "kind": "testIt",
    "name": "it106",
    "testId": 106,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it106",
    "access": null,
    "description": "should get hyperty source code",
    "lineNumber": 66
  },
  {
    "__docId__": 518,
    "kind": "testIt",
    "name": "it107",
    "testId": 107,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it107",
    "access": null,
    "description": "should get protostub descriptor",
    "lineNumber": 74
  },
  {
    "__docId__": 519,
    "kind": "testIt",
    "name": "it108",
    "testId": 108,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it108",
    "access": null,
    "description": "should get runtime descriptor",
    "lineNumber": 82
  },
  {
    "__docId__": 520,
    "kind": "testIt",
    "name": "it109",
    "testId": 109,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it109",
    "access": null,
    "description": "should get dataschema descriptor",
    "lineNumber": 90
  },
  {
    "__docId__": 521,
    "kind": "testIt",
    "name": "it110",
    "testId": 110,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it110",
    "access": null,
    "description": "should get idpproxy descriptor",
    "lineNumber": 98
  },
  {
    "__docId__": 522,
    "kind": "testIt",
    "name": "it111",
    "testId": 111,
    "memberof": "test/RuntimeCatalogue.spec.js~describe103",
    "testDepth": 1,
    "static": true,
    "longname": "test/RuntimeCatalogue.spec.js~describe103.it111",
    "access": null,
    "description": "should NOT get hyperty",
    "lineNumber": 106
  },
  {
    "__docId__": 523,
    "kind": "testFile",
    "name": "test/StorageManager.spec.js",
    "content": "import chai from 'chai'\nimport Dexie from 'dexie'\nimport storageManager from '../src/storage-manager/StorageManager'\n\nlet expect = chai.expect\nlet storage\ndescribe('StorageManager', function(){\n\tbeforeEach(() => {\n\t\tconst db = new Dexie('cache')\n\t\tconst storeName = 'objects'\n\n\t\tstorage = new storageManager(db, storeName)\n\t})\n\n\tdescribe('set', function(){\n\n\t\tit('should set the value for a given key-version tuple', function(done){\n\t\t\tstorage.set('key', 'v1.0.0', {})\n\t\t\t\t.then( key => {\n\t\t\t\t\texpect(key).to.be.eql('key')\n\t\t\t\t\tdone()\n\t\t\t\t})\n\t\t})\n\n\t\tit('should replace the value for a given key-version tuple if it exists', function(done){\n\t\t\tstorage.set('key', 'v1.0.0', {})\n\t\t\t\t.then(() => storage.set('key', 'v1.0.0', {name: 'test'}))\n\t\t\t\t.then(() => storage.get('key'))\n\t\t\t\t.then( object => {\n\t\t\t\t\texpect(object).to.be.eql({name:'test'})\n\t\t\t\t\tdone()\n\t\t\t\t})\n\t\t})\n\t})\n\n\tdescribe('get', function(){\n\t\tit('should get the value for a given key', function(done){\n\t\t\tstorage.set('key', 'v1.0.0', {name:'test'})\n\t\t\t\t.then(() => {\n\t\t\t\t\tstorage.get('key')\n\t\t\t\t\t\t.then( object => {\n\t\t\t\t\t\t\texpect(object).to.be.eql({name:'test'})\n\t\t\t\t\t\t\tdone()\n\t\t\t\t\t\t})\n\n\t\t\t\t})\n\t\t})\n\n\t\tit('should return undefined if no object with the given key exists', function(done){\n\t\t\tstorage.get('key123')\n\t\t\t\t.then( object => {\n\t\t\t\t\texpect(object).to.be.undefined\n\t\t\t\t\tdone()\n\t\t\t\t})\n\t\t})\n\t})\n\n\tdescribe('getVersion', function(){\n\t\tit('should get the value version for a given key', function(done){\n\t\t\tstorage.set('key', 'v1.0.0', {})\n\t\t\t\t.then(() => {\n\t\t\t\t\tstorage.getVersion('key')\n\t\t\t\t\t\t.then(version => {\n\t\t\t\t\t\t\texpect(version).to.be.eql('v1.0.0')\n\t\t\t\t\t\t\tdone()\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t})\n\n\t\tit('should get undefined if no object with the given key exists', function(done){\n\t\t\tstorage.getVersion('key123')\n\t\t\t\t.then(version => {\n\t\t\t\t\texpect(version).to.be.undefined\n\t\t\t\t\tdone()\n\t\t\t\t})\n\t\t})\n\t})\n\n\tdescribe('delete', function(){\n\t\tit('should remove a value from StorageManager for a given key', function(done){\n\t\t\tstorage.set('key', 'v1.0.0', {})\n\t\t\t\t.then(() => {\n\t\t\t\t\tstorage.delete('key')\n\t\t\t\t\t\t.then(affected_records => {\n\t\t\t\t\t\t\texpect(affected_records).to.be.eql(1)\n\t\t\t\t\t\t\tdone()\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t})\n\n\t\tit('shouldnt remove a value from StorageManager if the given key doesnt exist', function(done){\n\t\t\tstorage.delete('key321')\n\t\t\t\t.then(affected_records => {\n\t\t\t\t\texpect(affected_records).to.be.eql(0)\n\t\t\t\t\tdone()\n\t\t\t\t})\n\t\t})\n\t})\n})\n",
    "static": true,
    "longname": "test/StorageManager.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 524,
    "kind": "testDescribe",
    "name": "describe112",
    "testId": 112,
    "memberof": "test/StorageManager.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112",
    "access": null,
    "description": "StorageManager",
    "lineNumber": 7
  },
  {
    "__docId__": 525,
    "kind": "testDescribe",
    "name": "describe113",
    "testId": 113,
    "memberof": "test/StorageManager.spec.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe113",
    "access": null,
    "description": "set",
    "lineNumber": 15
  },
  {
    "__docId__": 526,
    "kind": "testIt",
    "name": "it114",
    "testId": 114,
    "memberof": "test/StorageManager.spec.js~describe112.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe113.it114",
    "access": null,
    "description": "should set the value for a given key-version tuple",
    "lineNumber": 17
  },
  {
    "__docId__": 527,
    "kind": "testIt",
    "name": "it115",
    "testId": 115,
    "memberof": "test/StorageManager.spec.js~describe112.describe113",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe113.it115",
    "access": null,
    "description": "should replace the value for a given key-version tuple if it exists",
    "lineNumber": 25
  },
  {
    "__docId__": 528,
    "kind": "testDescribe",
    "name": "describe116",
    "testId": 116,
    "memberof": "test/StorageManager.spec.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe116",
    "access": null,
    "description": "get",
    "lineNumber": 36
  },
  {
    "__docId__": 529,
    "kind": "testIt",
    "name": "it117",
    "testId": 117,
    "memberof": "test/StorageManager.spec.js~describe112.describe116",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe116.it117",
    "access": null,
    "description": "should get the value for a given key",
    "lineNumber": 37
  },
  {
    "__docId__": 530,
    "kind": "testIt",
    "name": "it118",
    "testId": 118,
    "memberof": "test/StorageManager.spec.js~describe112.describe116",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe116.it118",
    "access": null,
    "description": "should return undefined if no object with the given key exists",
    "lineNumber": 49
  },
  {
    "__docId__": 531,
    "kind": "testDescribe",
    "name": "describe119",
    "testId": 119,
    "memberof": "test/StorageManager.spec.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe119",
    "access": null,
    "description": "getVersion",
    "lineNumber": 58
  },
  {
    "__docId__": 532,
    "kind": "testIt",
    "name": "it120",
    "testId": 120,
    "memberof": "test/StorageManager.spec.js~describe112.describe119",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe119.it120",
    "access": null,
    "description": "should get the value version for a given key",
    "lineNumber": 59
  },
  {
    "__docId__": 533,
    "kind": "testIt",
    "name": "it121",
    "testId": 121,
    "memberof": "test/StorageManager.spec.js~describe112.describe119",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe119.it121",
    "access": null,
    "description": "should get undefined if no object with the given key exists",
    "lineNumber": 70
  },
  {
    "__docId__": 534,
    "kind": "testDescribe",
    "name": "describe122",
    "testId": 122,
    "memberof": "test/StorageManager.spec.js~describe112",
    "testDepth": 1,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe122",
    "access": null,
    "description": "delete",
    "lineNumber": 79
  },
  {
    "__docId__": 535,
    "kind": "testIt",
    "name": "it123",
    "testId": 123,
    "memberof": "test/StorageManager.spec.js~describe112.describe122",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe122.it123",
    "access": null,
    "description": "should remove a value from StorageManager for a given key",
    "lineNumber": 80
  },
  {
    "__docId__": 536,
    "kind": "testIt",
    "name": "it124",
    "testId": 124,
    "memberof": "test/StorageManager.spec.js~describe112.describe122",
    "testDepth": 2,
    "static": true,
    "longname": "test/StorageManager.spec.js~describe112.describe122.it124",
    "access": null,
    "description": "shouldnt remove a value from StorageManager if the given key doesnt exist",
    "lineNumber": 91
  },
  {
    "__docId__": 537,
    "kind": "testFile",
    "name": "test/Sync.spec.js",
    "content": "import chai from 'chai';\n\nimport 'proxy-observe';\nimport SyncObject from '../src/syncher/ProxyObject';\n\nchai.config.showDiff = true;\nchai.config.truncateThreshold = 0;\n\nlet expect = chai.expect;\n\ndescribe('The Object.Observer and Array.Observer', () => {\n\n  it('should use SyncObject', () => {\n\n    let initialData = {};\n    let syncObj = new SyncObject(initialData);\n\n    let data = syncObj.data;\n\n    //apply changes...\n    data['1'] = { name: 'Micael', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'xpto'}};\n    expect(data['1']).to.have.all.keys({name: 'Micael', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'xpto'}});\n\n    data['2'] = { name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' } };\n    expect(data['2']).to.have.all.keys({name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' }});\n\n    data['1'].name = 'Vitor Silva';\n    expect(data['1']).to.deep.equal({ name: 'Vitor Silva', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'xpto'}});\n\n    data['1'].birthdate = new Date(1982, 1, 28);\n    expect(data['1']).to.deep.equal({name: 'Vitor Silva', birthdate: new Date(1982, 1, 28), email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'xpto'}});\n\n    data['2'].obj1.name = 'XPTO NEW';\n    expect(data['2']).to.deep.equal({name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'XPTO NEW' }});\n\n    data['1'].obj1.name = 'Vitor Silva';\n    expect(data['1']).to.deep.equal({name: 'Vitor Silva', birthdate: new Date(1982, 1, 28), email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'Vitor Silva'}});\n\n    data['1'].arr = [1, 0, { x: 10, y: 20 }];\n    expect(data['1']).to.deep.equal({name: 'Vitor Silva', birthdate: new Date(1982, 1, 28), email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'Vitor Silva'}, arr: [1, 0, { x: 10, y: 20 }]});\n\n    data['1'].arr[1] = 2;\n    expect(data['1'].arr[1]).to.deep.equal(2);\n\n    delete data['2'];\n    expect(data['2']).to.be.an('undefined');\n\n  });\n\n  it('should use SyncObject observe', (done) => {\n\n    let initialData = {};\n    let syncObj = new SyncObject(initialData);\n    let seq = 0;\n\n    syncObj.observe((event) => {\n      seq++;\n\n      console.log('seq ' + seq + ' | ' + ' - ' + JSON.stringify(event));\n\n      if (seq === 1) {\n        expect(event).to.deep.equal({cType: 'add', oType: 'object', field: '1', data: {name: 'Micael', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'xpto'}, arr: []}});\n      }\n\n      if (seq === 2) {\n        expect(event).to.deep.equal({cType: 'add', oType: 'object', field: '2', data: {name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' }}});\n      }\n\n      if (seq === 3) {\n        expect(event).to.deep.equal({cType: 'update', oType: 'object', field: '1.name', data: 'Vitor Silva'});\n      }\n\n      if (seq === 4) {\n        expect(event).to.deep.equal({cType: 'update', oType: 'object', field: '1.arr', data: [1, 0, { x: 10, y: 20 }]});\n      }\n\n      if (seq === 5) {\n        expect(event).to.deep.equal({cType: 'update', oType: 'array', field: '1.arr.1', data: 2});\n        done();\n      }\n\n    });\n\n    let data = syncObj.data;\n\n    //apply changes...\n    data['1'] = {name: 'Micael', birthdate: '28-02-1981', email: 'micael-xxx@gmail.com', phone: 911000000, obj1: {name: 'xpto'}, arr: []};\n    data['2'] = {name: 'Luis Duarte', birthdate: '02-12-1991', email: 'luis-xxx@gmail.com', phone: 910000000, obj1: { name: 'xpto' }};\n    data['1'].name = 'Vitor Silva';\n    data['1'].arr = [1, 0, { x: 10, y: 20 }];\n    data['1'].arr[1] = 2;\n  });\n\n});\n",
    "static": true,
    "longname": "test/Sync.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 538,
    "kind": "testDescribe",
    "name": "describe125",
    "testId": 125,
    "memberof": "test/Sync.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/Sync.spec.js~describe125",
    "access": null,
    "description": "The Object.Observer and Array.Observer",
    "lineNumber": 11
  },
  {
    "__docId__": 539,
    "kind": "testIt",
    "name": "it126",
    "testId": 126,
    "memberof": "test/Sync.spec.js~describe125",
    "testDepth": 1,
    "static": true,
    "longname": "test/Sync.spec.js~describe125.it126",
    "access": null,
    "description": "should use SyncObject",
    "lineNumber": 13
  },
  {
    "__docId__": 540,
    "kind": "testIt",
    "name": "it127",
    "testId": 127,
    "memberof": "test/Sync.spec.js~describe125",
    "testDepth": 1,
    "static": true,
    "longname": "test/Sync.spec.js~describe125.it127",
    "access": null,
    "description": "should use SyncObject observe",
    "lineNumber": 50
  },
  {
    "__docId__": 541,
    "kind": "testFile",
    "name": "test/addressFactoryTest.js",
    "content": "\"use strict\";\n/*global describe */\n/*global it */\n/*\nconst assert = require(\"assert\");\nconst fs = require(\"fs\");\nconst URL = require(\"../lib/url\").createURLConstructor();\n\nfunction testAll(testurl) {\n    return function () {\n\tlet url;\n\n\ttry {\n\t    url = new URL(testurl.input, testurl.base);\n\t    assert.equal(url.protocol , testurl.output.protocol, \"\\n\\tGiven: *\" + url.protocol  +\"* \\n\\tTesturl.output.protocol: *\"+testurl.output.protocol+\"*\");\n\t    assert.equal(url.origin , testurl.output.origin, \"\\n\\tGiven: \" + url.origin  +   \" \\n\\tTesturl.Output.origin: \"+testurl.output.origin);\n\t    assert.equal(url.hostname , testurl.output.hostname, \"\\n\\tGiven: \" + url.hostname  +   \" \\n\\tTesturl.Output.hostname: \"+testurl.output.hostname);\n\t    assert.equal(url.host , testurl.output.host, \"\\n\\tGiven: \" + url.host  +   \" \\n\\tTesturl.Output.host: \"+testurl.output.host);\n\t    assert.equal(url.port , testurl.output.port, \"\\n\\tGiven: \" + url.port  +   \" \\n\\tTesturl.Output.port: \"+testurl.output.port);\n\t    assert.equal(url.path , testurl.output.path, \"\\n\\tGiven: \" + url.path  +   \" \\n\\tTesturl.Output.path: \"+testurl.output.path);\n\t    assert.equal(url.search , testurl.output.search, \"\\n\\tGiven: \" + url.search  +   \" \\n\\tTesturl.Output.search: \"+testurl.output.search);\n\t    assert.equal(url.hash , testurl.output.hash, \"\\n\\tGiven: \" + url.hash  +   \" \\n\\tTesturl.Output.hash: \"+testurl.output.hash);\n\t    assert.equal(url.href , testurl.output.href, \"\\n\\tGiven: \" + url.href  +   \" \\n\\tTesturl.Output.href: \"+testurl.output.href);\n\n\n\t} catch (e) {\n\t    if (e instanceof TypeError && expected.error === TypeError) {\n\t    } else {\n\t\tthrow e;\n\t    }\n\t}\n\t\n    }\n}\n\nfunction testOrigin(expected) {\n    return function () {\n\tlet url;\n\n\ttry {\n\t    url = new URL(expected.input, expected.base);\n\n\t    assert.equal(url.origin, expected.origin, \"\\n\\tGiven: \" + url.origin  +   \" \\n\\tExpected: \"+expected.origin);\n\t} catch (e) {\n\t    if (e instanceof TypeError && expected.error === TypeError) {\n\t    } else {\n\t\tthrow e;\n\t    }\n\t}\n\n    };\n}\n\n\nfunction testURL(expected) {\n  return function () {\n      let url;\n      try {\n\t  url = new URL(expected.input, expected.base);\n\t  console.warn(\"Protocol: \" + url.protocol)\n\t  console.warn(\"Origin: \" + url.origin)\n\t  console.warn(\"Hostname: \" + url.hostname)\n\t  console.warn(\"Host: \" + url.host)\n\t  console.warn(\"Port: \" + url.port)\n\t  console.warn(\"Path: \" + url.path)\n\t  console.warn(\"Search: \" + url.search)\n\t  console.warn(\"Hash: \" + url.hash)\n\t  console.warn(\"Href: \" + url.href)\t  \n\n      } catch (e) {\n\t  if (e instanceof TypeError && expected.protocol === \":\") {\n\t      console.error(\"TypeError...\");\n              return;\n\t  }\n\t  throw e;\n      }\n\n      console.warn(\"parsing...\");\n      if (expected.protocol === \":\" && url.protocol !== \":\") {\n\t  assert.fail(url.href, \"\", \"Expected URL to fail parsing, got \" + url.href);\n      }\n  };\n}\n\ndescribe(\"Full tests:\", function () {\n    let urls = []\n    let url = {}\n\n    url={\n\tinput:\"hyperty-runtime-esn://domain.com/12345\",\n\toutput: {\n\t    protocol: \"hyperty-runtime-esn:\",\n\t    origin: \"hyperty-runtime-esn://domain.com\",\n\t    hostname: \"domain.com\",\n\t    host: \"domain.com\",\n\t    port: \"\",\n\t    path: undefined,\n\t    search: \"\", \n\t    hash:\"\", \n\t    href: \"hyperty-runtime-esn://domain.com/12345\"\n\t}\n    }\n\n    urls.push(url)\n\n    url={\n    \tinput:\"hyperty-runtime-esn://domain.com/12345#textafterhash\",\n    \toutput: {\n\t    protocol: \"hyperty-runtime-esn:\",\n\t    origin: \"hyperty-runtime-esn://domain.com\",\n\t    hostname: \"domain.com\",\n\t    host: \"domain.com\",\n\t    port: \"\",\n\t    path: undefined,\n\t    search: \"\", \n\t    hash:\"#textafterhash\", \n\t    href: \"hyperty-runtime-esn://domain.com/12345#textafterhash\"\n    \t}\n    }\n    urls.push(url)\n\n    url={\n    \tinput:\"hyperty-runtime-esn://domain.com/12345?a=1&b=2&c=3\",\n    \toutput: {\n\t    protocol: \"hyperty-runtime-esn:\",\n\t    origin: \"hyperty-runtime-esn://domain.com\",\n\t    hostname: \"domain.com\",\n\t    host: \"domain.com\",\n\t    port: \"\",\n\t    path: undefined,\n\t    search: \"?a=1&b=2&c=3\", \n\t    hash:\"\", \n\t    href: \"hyperty-runtime-esn://domain.com/12345?a=1&b=2&c=3\"\n    \t}\n    }\n    urls.push(url)\n\n    // url={\n    // \tinput:\"hyperty-runtime-esn://domain.com/12345#hash?a=1&b=2&c=3\",\n    // \toutput: {\n    // \t    protocol: \"hyperty-runtime-esn:\",\n    // \t    origin: \"hyperty-runtime-esn://domain.com\",\n    // \t    hostname: \"domain.com\",\n    // \t    host: \"domain.com\",\n    // \t    port: \"\",\n    // \t    path: undefined,\n    // \t    search: \"?a=1&b=2&c=3\", \n    // \t    hash:\"\", \n    // \t    href: \"hyperty-runtime-esn://domain.com/12345\"\n    // \t}\n    // }\n    // urls.push(url)\n\n\n    for (let i=0; i<urls.length; i++) {\n\tit(urls[i].input+\": \", testAll(urls[i]))\n    }\n\n})\n\n\n\ndescribe(\"Tests to check 'origin':\", function () {\n    let urls = []\n    urls.push({input:\"blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f\", origin:\"https://whatwg.org:443\"})\n\n    // special scheme without port\n    urls.push({input:\"wss://rethink.org/\", origin:\"wss://rethink.org\"})\n\n    // special scheme with default port\n    urls.push({input:\"wss://rethink.org:443/\", origin:\"wss://rethink.org\"})\n\n    // special scheme without port\n    urls.push({input:\"ws://rethink.org/\", origin:\"ws://rethink.org\"})\n\n    // special scheme with different port\n    urls.push({input:\"wss://rethink.org:2345\", origin:\"wss://rethink.org:2345\"})\n\n    // special scheme with different port\n    urls.push({input:\"ws://rethink.org:1000\", origin:\"ws://rethink.org:1000\"})\n\n    // special scheme with same port as default one\n    urls.push({input:\"wss://rethink.org:443\", origin:\"wss://rethink.org\"})\n\n    urls.push({input:\"newschema://rethink.org\", origin:\"null\"})\n\n    urls.push({input:\"wss://rethink.org#section\", origin:\"wss://rethink.org\"})\n\n    urls.push({input:\"wss://rethink.org/section1/section2\", origin:\"wss://rethink.org\"})\n\n    urls.push({input:\"wss://something\", origin:\"wss://something\"})\n    urls.push({input:\"wss://a.b.c.d.e\", origin:\"wss://a.b.c.d.e\"})\n\n    // Invalid URLs\n    urls.push({input:\"wss://\", error:TypeError})\n    urls.push({input:\"://rethink.org\", error:TypeError})\n    urls.push({input:\"<some garbage>\", error:TypeError})\n\n    // Valid URLs with IPv4\n    urls.push({input:\"wss://127.0.0.1\", origin:\"wss://127.0.0.1\"})\n\n    // Invalid URLs with IPs v4\n    urls.push({input:\"wss://127.0.0.300\", error:TypeError})\n    urls.push({input:\"wss://127.0.0\", error:TypeError})\n    urls.push({input:\"wss://127.0.0.1.2\", error:TypeError})\n    urls.push({input:\"wss://ABCD:EF01:2345:6789:ABCD:EF01:2345:6789\", error:TypeError})\n\n    // reThink URLs\n    urls.push({input:\"user://twitter.com/pchainho\", origin:\"user://twitter.com\"})\n    urls.push({input:\"user://cm-lisboa.pt/campo-grande-28-building\", origin:\"user://cm-lisboa.pt\"})\n    urls.push({input:\"ctxt://myhouse/energy\", origin:\"ctxt://myhouse\"})\n    urls.push({input:\"comm://telekom.de/sdruesdow-20150802006\", origin:\"comm://telekom.de\"})\n\n    // reThink URls: hypertity runtime\n    urls.push({input:\"hyperty-runtime://domain.com/12345\", origin:\"hyperty-runtime://domain.com\"})\n    urls.push({input:\"hyperty-runtime-uuid://domain.com/12345\", origin:\"hyperty-runtime-uuid://domain.com\"})\n    urls.push({input:\"hyperty-runtime-dev-os://domain.com/12345\", origin:\"hyperty-runtime-dev-os://domain.com\"})\n    urls.push({input:\"hyperty-runtime-imei://domain.com/12345\", origin:\"hyperty-runtime-imei://domain.com\"})\n    urls.push({input:\"hyperty-runtime-esn://domain.com/12345\", origin:\"hyperty-runtime-esn://domain.com\"})\n    urls.push({input:\"hyperty-runtime-meid://domain.com/12345\", origin:\"hyperty-runtime-meid://domain.com\"})\n    urls.push({input:\"hyperty-runtime-doesnotexist://domain.com/12345\", origin:\"\"})\n    urls.push({input:\"hyperty://meo.pt/123456\", origin:\"hyperty://meo.pt/123456\"})\n\n    for (let i=0; i<urls.length; i++) {\n\tit(urls[i].input+\": \", testOrigin(urls[i]))\n    }\n}\n\n)\n\n// describe(\"Hosts\", function () {\n//     let url = {}\n//     url.input=\"newprotocol://www.google.es\";\n//     url.expected={}\n//     url.expected.protocol=\"newprotocol:\"\n//     it(\"Testing: \", testURL(url))\n\n//     url.input=\"newprotocol://www.google.es#section\";\n//     url.expected={}\n//     url.expected.protocol=\"newprotocol:\"\n//     it(\"Testing: \", testURL(url))\n\n//     url.input=\"newprotocol://google.es#section\";\n//     url.expected={}\n//     url.expected.protocol=\"newprotocol:\"\n//     it(\"Testing: \", testURL(url))\n\n//     url.input=\"newprotocol://google#section\";\n//     url.expected={}\n//     url.expected.protocol=\"newprotocol:\"\n//     it(\"Testing: \", testURL(url))\n    \n// });\n*/",
    "static": true,
    "longname": "test/addressFactoryTest.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 542,
    "kind": "testFile",
    "name": "test/utils.spec.js",
    "content": "// Unit test modules\nimport chai from 'chai';\nimport chaiAsPromised from 'chai-as-promised';\nimport sinonChai from 'sinon-chai';\n\n// internal modules to be tested\nimport {divideURL, convertToUserURL} from '../src/utils/utils';\n\nlet expect = chai.expect;\n\nchai.config.showDiff = true;\nchai.config.truncateThreshold = 0;\n\nchai.use(chaiAsPromised);\nchai.use(sinonChai);\n\n/**\n * this is test for Utils.\n * @test {utils}\n */\ndescribe('Utils Module', function() {\n\n  it('should divide an url in 3 parts (type, domain, identity)', function() {\n\n    // http://localhost:9090/test\n    // hyperty://localhost:9090/test\n    // http://sp1.sp/test-testes\n    // hyperty-catalogue://sp1.sp/HelloHyperty\n    // runtime://sp1.sp/8456/sm\n    // domain://msg-node.sp1.sp/hyperty-address-allocation\n    // hyperty-runtime://sp1.sp\n\n    let url = 'runtime://sp.sp/8456/sm';\n    expect(divideURL(url)).to.deep.equal({'type' : 'runtime','domain': 'sp.sp', 'identity': '/8456/sm'});\n\n    url = 'domain://msg-node.sp1.sp/hyperty-address-allocation';\n    expect(divideURL(url)).to.deep.equal({'type' : 'domain','domain': 'msg-node.sp1.sp', 'identity': '/hyperty-address-allocation'});\n\n    url = 'hyperty://sp1.sp/HelloHyperty';\n    expect(divideURL(url)).to.deep.equal({'type' : 'hyperty','domain': 'sp1.sp', 'identity': '/HelloHyperty'});\n\n    url = 'hyperty://localhost:9090/test';\n    expect(divideURL(url)).to.deep.equal({'type' : 'hyperty','domain': 'localhost:9090', 'identity': '/test'});\n\n    url = 'runtime://sp1.sp';\n    expect(divideURL(url)).to.deep.equal({'type' : 'runtime','domain': 'sp1.sp', 'identity': ''});\n\n    url = 'http://localhost:9090/test';\n    expect(divideURL(url)).to.deep.equal({'type' : 'http','domain': 'localhost:9090', 'identity': '/test'});\n\n    url = 'https://localhost:9090/secure-test';\n    expect(divideURL(url)).to.deep.equal({'type' : 'https','domain': 'localhost:9090', 'identity': '/secure-test'});\n  });\n\n  it('should convert a user identity to userURL', function() {\n\n    let userIdentity = 'openidtest10@gmail.com';\n    expect(convertToUserURL(userIdentity)).to.deep.equal('user://gmail.com/openidtest10');\n\n    userIdentity = 'user://gmail.com/openidtest10';\n    expect(convertToUserURL(userIdentity)).to.deep.equal('user://gmail.com/openidtest10');\n  });\n});\n",
    "static": true,
    "longname": "test/utils.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 543,
    "kind": "testDescribe",
    "name": "describe128",
    "testId": 128,
    "memberof": "test/utils.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/utils.spec.js~describe128",
    "access": null,
    "description": "this is test for Utils.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@test",
        "tagValue": "{utils}"
      }
    ],
    "testTargets": [
      "utils"
    ]
  },
  {
    "__docId__": 544,
    "kind": "testIt",
    "name": "it129",
    "testId": 129,
    "memberof": "test/utils.spec.js~describe128",
    "testDepth": 1,
    "static": true,
    "longname": "test/utils.spec.js~describe128.it129",
    "access": null,
    "description": "should divide an url in 3 parts (type, domain, identity)",
    "lineNumber": 23
  },
  {
    "__docId__": 545,
    "kind": "testIt",
    "name": "it130",
    "testId": 130,
    "memberof": "test/utils.spec.js~describe128",
    "testDepth": 1,
    "static": true,
    "longname": "test/utils.spec.js~describe128.it130",
    "access": null,
    "description": "should convert a user identity to userURL",
    "lineNumber": 55
  }
]