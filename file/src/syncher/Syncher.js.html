<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/syncher/Syncher.js | Service Framework API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">bus</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/Bus.js~Bus.html">Bus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/MessageBus.js~MessageBus.html">MessageBus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/MiniBus.js~MiniBus.html">MiniBus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bus/Pipeline.js~Pipeline.html">Pipeline</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">discovery</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/discovery/Discovery.js~Discovery.html">Discovery</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">identity</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/Crypto.js~Crypto.html">Crypto</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/GuiFake.js~GuiFake.html">GuiFake</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/Identity.js~Identity.html">Identity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/IdentityModule.js~IdentityModule.html">IdentityModule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/identity/OpenIdLib.js~OpenIdLib.html">OpenIdLib</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">syncher</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObject.js~DataObject.html">DataObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObjectChild.js~DataObjectChild.html">DataObjectChild</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObjectObserver.js~DataObjectObserver.html">DataObjectObserver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObjectReporter.js~DataObjectReporter.html">DataObjectReporter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/Syncher.js~Syncher.html">Syncher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ChangeType">ChangeType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ObjectType">ObjectType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ChangeType">ChangeType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ObjectType">ObjectType</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/EventEmitter.js~EventEmitter.html">EventEmitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/WatchingYou.js~WatchingYou.html">WatchingYou</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-checkAttribute">checkAttribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convertToUserURL">convertToUserURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deepClone">deepClone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-divideEmail">divideEmail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-divideURL">divideURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-emptyObject">emptyObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getUserEmailFromURL">getUserEmailFromURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getUserURLFromEmail">getUserURLFromEmail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseAttributes">parseAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-divideURL">divideURL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/syncher/Syncher.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
* Copyright 2016 PT Inova&#xE7;&#xE3;o e Sistemas SA
* Copyright 2016 INESC-ID
* Copyright 2016 QUOBIS NETWORKS SL
* Copyright 2016 FRAUNHOFER-GESELLSCHAFT ZUR FOERDERUNG DER ANGEWANDTEN FORSCHUNG E.V
* Copyright 2016 ORANGE SA
* Copyright 2016 Deutsche Telekom AG
* Copyright 2016 Apizee
* Copyright 2016 TECHNISCHE UNIVERSITAT BERLIN
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/
import { deepClone } from &apos;../utils/utils&apos;;

import DataObjectReporter from &apos;./DataObjectReporter&apos;;
import DataObjectObserver from &apos;./DataObjectObserver&apos;;
import DataProvisional from &apos;./DataProvisional&apos;;

/**
* The main class for the syncher package.
* The Syncher is a singleton class per Hyperty/URL and it is the owner of all created Data Sync Objects according to the Reporter - Observer pattern.
* Main functionality is to create reporters and to subscribe to existing ones.
*/
class Syncher {
  /* private
  _owner: URL
  _bus: MiniBus

  _subURL: URL

  _reporters: &lt;url: DataObjectReporter&gt;
  _observers: &lt;url: DataObjectObserver&gt;
  _provisionals: &lt;url: DataProvisional&gt;

  ----event handlers----
  _onNotificationHandler: (event) =&gt; void
  _onResume: (event) =&gt; void
  */

  /**
  * Constructor that should be used by the Hyperty owner
  * @param {HypertyURL} owner - Hyperty URL owner. An URL allocated by the runtime that uniquely identifies the Hyperty.
  * @param {MiniBus} bus - An instance of the MiniBus provided in the sandbox. When an object (Reporter or Observed) is created, the SyncherManager will add a listener in the MiniBus to receive/send Messages of that object.
  * @param {JSON} config - Configuration data. The only required field for now is the runtimeURL.
  */
  constructor(owner, bus, config) {
    let _this = this;

    _this._owner = owner;
    _this._bus = bus;

    _this._subURL = config.runtimeURL + &apos;/sm&apos;;
    _this._runtimeUrl = config.runtimeURL;

    _this._reporters = {};
    _this._observers = {};
    _this._provisionals = {};

    bus.addListener(owner, (msg) =&gt; {
      //ignore msg sent by himself
      if (msg.from !== owner) {
        console.info(&apos;[Syncher] Syncher-RCV: &apos;, msg, _this);
        switch (msg.type) {
          case &apos;forward&apos;: _this._onForward(msg); break;
          case &apos;create&apos;: _this._onRemoteCreate(msg); break;
          case &apos;delete&apos;: _this._onRemoteDelete(msg); break;
        }
      }
    });
  }

  /**
  * The owner of the Syncher and all created reporters.
  * @type {HypertyURL}
  */
  get owner() { return this._owner; }

  /**
  * All owned reporters, the ones that were created by a create
  * @type {Object&lt;URL, DataObjectReporter&gt;}
  */
  get reporters() { return this._reporters; }

  /**
  * All owned observers, the ones that were created by a local subscription
  * @type {Object&lt;URL, DataObjectObserver&gt;}
  */
  get observers() { return this._observers; }

  /**
  * Request a DataObjectReporter creation. The URL will be be requested by the allocation mechanism.
  * @param  {SchemaURL} schema - Hyperty Catalogue URL address that can be used to retrieve the JSON-Schema describing the Data Object schema
  * @param  {HypertyURL[]} observers - List of hyperties that are pre-authorized for subscription
  * @param  {JSON} initialData - Initial data of the reporter
  * @param  {boolean} store - (Optional) if true, object will be stored by the runtime
  * @param  {boolean} p2p - (Optional) if true, data synchronisation stream will use p2p connection as much as possible
  * @param  {string} name - (Optional) the name of the dataobject
  * @param  {MessageBodyIdentity} identity - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.
  * @param  {SyncMetadata} input - (optional) all metadata required to sunc the Data Object.
  * @return {Promise&lt;DataObjectReporter&gt;} Return Promise to a new Reporter. The reporter can be accepted or rejected by the PEP
  */
  create(schema, observers, initialData, store = false, p2p = false, name = &apos;no name&apos;, identity, input) {

    if (!schema) throw Error(&apos;[Syncher - Create] - You need specify the data object schema&apos;);
    if (!observers) throw Error(&apos;[Syncher - Create] -The observers should be defined&apos;);

    let _this = this;
    let createInput  = Object.assign({}, input);

    createInput.p2p = p2p;
    createInput.store = store;
    createInput.schema = schema;
    createInput.authorise = observers;
    (initialData) ? createInput.data = deepClone(initialData) : createInput.data = {};
    createInput.name = name;
    createInput.reporter = _this._owner;
    createInput.resume = false;
    if (input) {
      createInput.mutual = input.mutual ? input.mutual : true;
      createInput.name = input.name ? input.name : createInput.name;
    } else { createInput.mutual = true; }

    if (identity)      { createInput.identity = identity; }

    //Object.assign(createInput, {resume: false});

    console.log(&apos;[syncher - create] - create Reporter - createInput: &apos;, createInput);

    return _this._create(createInput);
  }

  /**
  * Request a DataObjectReporter creation. The URL will be be requested by the allocation mechanism.
  * @param  {Object} criteria - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.
  * @return {Promise&lt;DataObjectReporter&gt;[]} Return a promise with a list of DataObjectReporter to be resumed;
  */
  resumeReporters(criteria) {
    let _this = this;
    console.log(&apos;[syncher - create] - resume Reporter - criteria: &apos;, criteria);

    Object.assign(criteria, {resume: true});

    return _this._resumeCreate(criteria);
  }

  /**
  * Request a subscription to an existent reporter object.
  * @param {SchemaURL} schema - Hyperty Catalogue URL address that can be used to retrieve the JSON-Schema describing the Data Object schema
  * @param {ObjectURL} objURL - Address of the existent reporter object to be observed
  * @param {Boolean} [store=false] - Save the subscription on the Syncher Manager for further resume (Default is false)
  * @param {Boolean} [p2p=false] - Info about if should use p2p connection (Default is false)
  * @param {Boolean} [mutual=true] - Info about if messages of this object should be encrypted (Default is true)
  * @param  {MessageBodyIdentity} identity - (optional) identity data to be added to identity the user reporter. To be used for legacy identities.
  * @return {Promise&lt;DataObjectObserver&gt;} Return Promise to a new observer. It&apos;s associated with the reporter.
  */
  subscribe(schema, objURL, store = false, p2p = false, mutual = true, identity) {
    let _this = this;
    let criteria = {};

    criteria.p2p = p2p;
    criteria.store = store;
    criteria.schema = schema;

    criteria.resource = objURL;
    if (identity)      { criteria.identity = identity; }

    //TODO: For Further Study
    criteria.mutual = mutual;

    console.log(&apos;[syncher - subscribe] - subscribe criteria: &apos;, criteria);

    Object.assign(criteria, {resume: false});

    return _this._subscribe(criteria);
  }

  /**
  * Request a subscription to an existent reporter object.
  * @param {criteria} criteria - Information to discovery the observer object
  * @return {Promise&lt;DataObjectObserver&gt;} Return Promise to a new observer. It&apos;s associated with the reporter.
  */
  resumeObservers(criteria) {
    let _this = this;
    let _criteria = criteria || {};

    Object.assign(_criteria, {resume: true});

    return _this._resumeSubscribe(_criteria);
  }

  /**
  * Request a read action on the reporter object
  * @param {ObjectURL} objURL - URL of the reporter object to be read
  * @return {Promise&lt;Object&gt;} Return Promise to last available data of the reporter
  */
  read(objURL) {
    let _this = this;

    //FLOW-OUT: this message will be sent directly to reporter object (maybe there is no listener available, so it will be resolved with MessageBus -&gt; resolve)
    //will reach the remote object in DataObjectReporter -&gt; _onRead
    let readMsg = {
      type: &apos;read&apos;, from: _this._owner, to: objURL
    };

    return new Promise((resolve, reject) =&gt; {
      _this._bus.postMessage(readMsg, (reply) =&gt; {
        console.log(&apos;read-response: &apos;, reply);
        if (reply.body.code === 200) {
          resolve(reply.body.value);
        } else {
          reject(reply.body.desc);
        }
      });
    });
  }

  /**
  * Setup the callback to process create and delete events of remove Reporter objects.
  * This is releated to the messagens sent by create to the observers Hyperty array.
  * @param {function(event: MsgEvent)} callback
  */
  onNotification(callback) {
    this._onNotificationHandler = callback;
  }

  _create(input) {
    let _this = this;

    return new Promise((resolve, reject) =&gt; {

      let reporterInput  = Object.assign({}, input);

      let resume = input.resume;

      reporterInput.created = (new Date).toISOString();
      reporterInput.runtime = _this._runtimeUrl;

      let requestValue = deepClone(reporterInput);

      delete requestValue.p2p;
      delete requestValue.store;
      delete requestValue.observers;
      delete requestValue.identity;

      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -&gt; _onCreate
      let requestMsg = {
        type: &apos;create&apos;, from: _this._owner, to: _this._subURL,
        body: { resume: resume, value: requestValue  }
      };


      requestMsg.body.schema = reporterInput.schema;

      if (reporterInput.p2p) requestMsg.body.p2p = reporterInput.p2p;
      if (reporterInput.store) requestMsg.body.store = reporterInput.store;
      if (reporterInput.identity) requestMsg.body.identity = reporterInput.identity;

      console.log(&apos;[syncher._create]: &apos;, reporterInput, requestMsg);

      //request create to the allocation system. Can be rejected by the PolicyEngine.
      _this._bus.postMessage(requestMsg, (reply) =&gt; {
        console.log(&apos;[syncher - create] - create-response: &apos;, reply);
        if (reply.body.code === 200) {
          //reporter creation accepted
          reporterInput.url = reply.body.resource;

          reporterInput.status = &apos;live&apos;;// pch: do we ned this?
          reporterInput.syncher = _this;
          reporterInput.childrens = reply.body.childrenResources;

          let newObj = new DataObjectReporter(reporterInput);

          _this._reporters[reporterInput.url] = newObj;

          newObj.inviteObservers(input.authorise);

          resolve(newObj);

        } else {
          //reporter creation rejected
          reject(reply.body.desc);
        }
      });
    });

  }

  _resumeCreate(criteria) {
    let _this = this;

    return new Promise((resolve, reject) =&gt; {
      let resume = criteria.resume;

      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -&gt; _onCreate
      let requestMsg = {
        type: &apos;create&apos;, from: _this._owner, to: _this._subURL,
        body: { resume: resume }
      };

      console.log(&apos;[syncher - create]: &apos;, criteria, requestMsg);

      if (criteria) {
        requestMsg.body.value = criteria;
        requestMsg.body.value.reporter = _this._owner;
      }

      if (criteria.p2p) requestMsg.body.p2p = criteria.p2p;
      if (criteria.store) requestMsg.body.store = criteria.store;
      if (criteria.observers) requestMsg.body.authorise = criteria.observers;
      if (criteria.identity) requestMsg.body.identity = criteria.identity;

      console.log(&apos;[syncher._resumeCreate] - resume message: &apos;, requestMsg);

      //request create to the allocation system. Can be rejected by the PolicyEngine.
      _this._bus.postMessage(requestMsg, (reply) =&gt; {
        console.log(&apos;[syncher._resumeCreate] - create-resumed-response: &apos;, reply);
        if (reply.body.code === 200) {

          let listOfReporters = reply.body.value;

          for (let index in listOfReporters) {

            let dataObject = listOfReporters[index];

            //reporter creation accepted

            dataObject.data = deepClone(dataObject.data) || {};

            if (dataObject.childrenObjects) { dataObject.childrenObjects = deepClone(dataObject.childrenObjects); }

            dataObject.mutual = false;
            dataObject.resume = true;
            dataObject.status = &apos;live&apos;;// pch: do we ned this?
            dataObject.syncher = _this;

            console.log(&apos;[syncher._resumeCreate] - create-resumed-dataObjectReporter&apos;, dataObject);

            let newObj = new DataObjectReporter(dataObject);

            if (dataObject.childrenObjects) { newObj.resumeChildrens(dataObject.childrenObjects); }
            _this._reporters[dataObject.url] = newObj;

          }

          resolve(_this._reporters);
          if (this._onReportersResume) this._onReportersResume(this._reporters);

        } else if (reply.body.code === 404) {
          resolve({});
        } else {
          //reporter creation rejected
          reject(reply.body.desc);
        }
      });
    });
  }

  _subscribe(input) {
    let _this = this;

    return new Promise((resolve, reject) =&gt; {

      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -&gt; _onLocalSubscribe
      let subscribeMsg = {
        type: &apos;subscribe&apos;, from: _this._owner, to: _this._subURL,
        body: {}
      };

      // Hyperty request to be an Observer
      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#hyperty-request-to-be-an-observer

      // Resume Subscriptions for the same Hyperty URL
      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-the-same-hyperty-url

      // Resume Subscriptions for a certain user and data schema independently of the Hyperty URL.
      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-a-certain-user-and-data-schema-independently-of-the-hyperty-url
      if (input) {
        if (input.hasOwnProperty(&apos;p2p&apos;)) subscribeMsg.body.p2p = input.p2p;
        if (input.hasOwnProperty(&apos;store&apos;)) subscribeMsg.body.store = input.store;
        if (input.hasOwnProperty(&apos;schema&apos;)) subscribeMsg.body.schema = input.schema;
        if (input.hasOwnProperty(&apos;identity&apos;)) subscribeMsg.body.identity = input.identity;
        if (input.hasOwnProperty(&apos;resource&apos;)) subscribeMsg.body.resource = input.resource;
      }

      subscribeMsg.body.resume = input.resume;

      //TODO: For Further Study
      if (input.hasOwnProperty(&apos;mutual&apos;)) subscribeMsg.body.mutualAuthentication = input.mutual;

      console.log(&apos;[syncher_subscribe] - subscribe message: &apos;, input, subscribeMsg);

      //request subscription
      //Provisional data is applied to the DataObjectObserver after confirmation. Or discarded if there is no confirmation.
      //for more info see the DataProvisional class documentation.
      _this._bus.postMessage(subscribeMsg, (reply) =&gt; {
        console.log(&apos;[syncher] - subscribe-response: &apos;, reply);

        let objURL = reply.body.resource;

        let newProvisional = _this._provisionals[objURL];
        delete _this._provisionals[objURL];
        if (newProvisional) newProvisional._releaseListeners();

        if (reply.body.code &lt; 200) {
          console.log(&apos;[syncher] - new DataProvisional: &apos;, reply.body.childrenResources, objURL);
          newProvisional = new DataProvisional(_this._owner, objURL, _this._bus, reply.body.childrenResources);
          _this._provisionals[objURL] = newProvisional;
        } else if (reply.body.code === 200) {
          console.log(&apos;[syncher] - new Data Object Observer: &apos;, reply, _this._provisionals);

          let observerInput = reply.body.value;

          observerInput.syncher = _this;
          observerInput.p2p = input.p2p;
          observerInput.store = input.store;
          observerInput.identity = input.identity;
          observerInput.resume = false;

          // todo: For Further Study
          observerInput.mutual = input.mutual;
          observerInput.children = newProvisional.children;

          //TODO: mutualAuthentication For Further Study
          let newObj = new DataObjectObserver(observerInput);
          _this._observers[objURL] = newObj;

          resolve(newObj);
          newProvisional.apply(newObj);
        } else {
          reject(reply.body.desc);
        }
      });
    });
  }

  _resumeSubscribe(criteria) {
    let _this = this;

    return new Promise((resolve, reject) =&gt; {

      //FLOW-OUT: this message will be sent to the runtime instance of SyncherManager -&gt; _onLocalSubscribe
      let subscribeMsg = {
        type: &apos;subscribe&apos;, from: _this._owner, to: _this._subURL,
        body: {}
      };

      // Hyperty request to be an Observer
      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#hyperty-request-to-be-an-observer

      // Resume Subscriptions for the same Hyperty URL
      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-the-same-hyperty-url

      // Resume Subscriptions for a certain user and data schema independently of the Hyperty URL.
      // https://github.com/reTHINK-project/specs/blob/master/messages/data-sync-messages.md#resume-subscriptions-for-a-certain-user-and-data-schema-independently-of-the-hyperty-url
      if (criteria) {
        if (criteria.hasOwnProperty(&apos;p2p&apos;)) subscribeMsg.body.p2p = criteria.p2p;
        if (criteria.hasOwnProperty(&apos;store&apos;)) subscribeMsg.body.store = criteria.store;
        if (criteria.hasOwnProperty(&apos;schema&apos;)) subscribeMsg.body.schema = criteria.schema;
        if (criteria.hasOwnProperty(&apos;identity&apos;)) subscribeMsg.body.identity = criteria.identity;
        if (criteria.hasOwnProperty(&apos;resource&apos;)) subscribeMsg.body.resource = criteria.url;
      }

      subscribeMsg.body.resume = criteria.resume;

      //TODO: For Further Study
      let mutualAuthentication = criteria.mutual;
      if (criteria.hasOwnProperty(&apos;mutual&apos;)) subscribeMsg.body.mutualAuthentication = mutualAuthentication;

      console.log(&apos;[syncher] - subscribe message: &apos;, criteria, subscribeMsg);

      //request subscription
      //Provisional data is applied to the DataObjectObserver after confirmation. Or discarded if there is no confirmation.
      //for more info see the DataProvisional class documentation.
      _this._bus.postMessage(subscribeMsg, (reply) =&gt; {
        console.log(&apos;[syncher] - subscribe-resumed-response: &apos;, reply);

        let objURL = reply.body.resource;

        let newProvisional = _this._provisionals[objURL];
        delete _this._provisionals[objURL];
        if (newProvisional) newProvisional._releaseListeners();

        if (reply.body.code &lt; 200) { // todo: check if this is needed for the resume

          console.log(&apos;[syncher] - resume new DataProvisional: &apos;, reply, objURL);
          newProvisional = new DataProvisional(_this._owner, objURL, _this._bus, reply.body.childrenResources);
          _this._provisionals[objURL] = newProvisional;

        } else if (reply.body.code === 200) {

          let listOfObservers = reply.body.value;

          for (let index in listOfObservers) {

            let dataObject = listOfObservers[index];
            console.log(&apos;[syncher] - Resume Object Observer: &apos;, reply, dataObject, _this._provisionals);

            if (dataObject.childrenObjects) { dataObject.childrenObjects = deepClone(dataObject.childrenObjects); }

            dataObject.data = deepClone(dataObject.data) || {};
            dataObject.resume = true;
            dataObject.syncher = _this;

            //TODO: mutualAuthentication For Further Study
            console.log(&apos;[syncher._resumeSubscribe] - create new dataObject: &apos;, dataObject);
            let newObj = new DataObjectObserver(dataObject);

            //lets sync with Reporter
            newObj.sync();

            if (dataObject.childrenObjects) { newObj.resumeChildrens(dataObject.childrenObjects); }

            _this._observers[newObj.url] = newObj;

            if (_this._provisionals[newObj.url]) { _this._provisionals[newObj.url].apply(newObj); }
          }

          resolve(_this._observers);

          if (this._onObserversResume) this._onObserversResume(_this._observers);

        } else if (reply.body.code === 404) {
          resolve({});
        } else {
          reject(reply.body.desc);
        }
      });
    });

  }

  //FLOW-IN: message received from a local runtime ReporterObject -&gt; _onRemoteSubscribe
  _onForward(msg) {
    let _this = this;

    let reporter = _this._reporters[msg.body.to];
    reporter._onForward(msg);
  }

  //FLOW-IN: message received from a remote Syncher -&gt; create (this is actually an invitation to subscribe)
  _onRemoteCreate(msg) {
    let _this = this;

   //remove &quot;/subscription&quot; from the URL
    let resource = msg.from.slice(0, -13);

    let event = {
      type: msg.type,
      from: msg.body.source,
      url: resource,
      schema: msg.body.schema,
      value: msg.body.value,
      identity: msg.body.identity,

      ack: (type) =&gt; {
        let lType = 200;
        if (type) {
          lType = type;
        }

       //send ack response message
        _this._bus.postMessage({
          id: msg.id, type: &apos;response&apos;, from: msg.to, to: msg.from,
          body: { code: lType }
        });
      }
    };

    if (_this._onNotificationHandler) {
      console.info(&apos;[Syncher] NOTIFICATION-EVENT: &apos;, event);
      _this._onNotificationHandler(event);
    }
  }

  //FLOW-IN: message received from a remote DataObjectReporter -&gt; delete
  _onRemoteDelete(msg) {
    let _this = this;

   //remove &quot;/subscription&quot; from the URL
    let resource = msg.body.resource;

    let object = _this._observers[resource];

    let unsubscribe = {
      from: _this.owner,
      to: _this._subURL,
      id: msg.id,
      type: &apos;unsubscribe&apos;,
      body: { resource: msg.body.resource }
    };

    _this._bus.postMessage(unsubscribe);

    if (object) {
      let event = {
        type: msg.type,
        url: resource,
        identity: msg.body.identity,

        ack: (type) =&gt; {
          let lType = 200;
          if (type) {
            lType = type;
          }

         //TODO: any other different options for the release process, like accept but nor release local?
          if (lType === 200) {
            object.delete();
          }

          //send ack response message
          _this._bus.postMessage({
            id: msg.id, type: &apos;response&apos;, from: msg.to, to: msg.from,
            body: { code: lType, source: _this._owner }
          });
        }
      };

      if (_this._onNotificationHandler) {
        console.log(&apos;NOTIFICATION-EVENT: &apos;, event);
        _this._onNotificationHandler(event);
      }
    } else {
      _this._bus.postMessage({
        id: msg.id, type: &apos;response&apos;, from: msg.to, to: msg.from,
        body: { code: 404, source: _this._owner }
      });
    }
  }

  /**
  * Callback system to trigger the resumed reporters
  * @param  {Function} callback - function callback which will be invoked
  * @return {Object&lt;URL, DataObjectReporter&gt;} Return one object with all resumed reporters;
  */
  onReportersResume(callback) {
    this._onReportersResume = callback;
  }

  /**
  * Callback system to trigger the resumed observers
  * @param  {Function} callback - function callback which will be invoked
  * @return {Object&lt;URL, DataObjectObserver&gt;} Return one object with all resumed observers;
  */
  onObserversResume(callback) {
    this._onObserversResume = callback;
  }

}

export default Syncher;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
