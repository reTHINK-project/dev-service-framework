<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/address-factory/url.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="git+ssh://git@github.com/reTHINK-project/core-framework.git">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">catalogue-factory</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/CatalogueDataObject.js~CatalogueDataObject.html">CatalogueDataObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/CatalogueDataObjectFactory.js~CatalogueDataObjectFactory.html">CatalogueDataObjectFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~CommunicationDataObjectSchema.html">CommunicationDataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~ConnectionDataObjectSchema.html">ConnectionDataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~ContextDataObjectSchema.html">ContextDataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~DataObjectSchema.html">DataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~HypertyDataObjectSchema.html">HypertyDataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~IdentifyDataObjectSchema.html">IdentifyDataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/DataObjectSchema.js~MessageDataObjectSchema.html">MessageDataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/HypertyDescriptor.js~HypertyDescriptor.html">HypertyDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/HypertyRuntimeDescriptor.js~HypertyRuntimeDescriptor.html">HypertyRuntimeDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/PolicyEnforcerDescriptor.js~PolicyEnforcerDescriptor.html">PolicyEnforcerDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/ProtocolStubDescriptor.js~ProtocolStubDescriptor.html">ProtocolStubDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/RuntimeConstraint.js~RuntimeConstraint.html">RuntimeConstraint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/catalogue-factory/SourcePackage.js~SourcePackage.html">SourcePackage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CatalogueObjectType">CatalogueObjectType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataObjectSourceLanguage">DataObjectSourceLanguage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-catalogueDataObject">catalogueDataObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-catalogueDataObjectFactory">catalogueDataObjectFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataObjectSchema">dataObjectSchema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HypertyType">HypertyType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RuntimeHypertyCapabilityType">RuntimeHypertyCapabilityType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-hypertyDescriptor">hypertyDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RuntimeHypertyCapabilityType">RuntimeHypertyCapabilityType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RuntimeProtocolCapabilityType">RuntimeProtocolCapabilityType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RuntimeType">RuntimeType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-hypertyRuntimeDescriptor">hypertyRuntimeDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-policyEnforcerDescriptor">policyEnforcerDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-protocolStubDescriptor">protocolStubDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-runtimeConstraint">runtimeConstraint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sourcePackage">sourcePackage</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">hyperty</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/hyperty/Connection.js~Connection.html">Connection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/hyperty/ConnectionController.js~ConnectionController.html">ConnectionController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/hyperty/OwnerPeer.js~OwnerPeer.html">OwnerPeer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/hyperty/Peer.js~Peer.html">Peer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-activate">activate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-connection">connection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-connectionController">connectionController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ownerPeer">ownerPeer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-peer">peer</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">hyperty-discovery</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/hyperty-discovery/HypertyDiscovery.js~HypertyDiscovery.html">HypertyDiscovery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-hypertyDiscovery">hypertyDiscovery</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">message-factory</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~CreateMessageBody.html">CreateMessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~DeleteMessageBody.html">DeleteMessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~ForwardMessageBody.html">ForwardMessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~MessageBody.html">MessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~ReadMessageBody.html">ReadMessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~ResponseMessageBody.html">ResponseMessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageBody.js~UpdateMessageBody.html">UpdateMessageBody</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageFactory.js~IdGenerator.html">IdGenerator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/message-factory/MessageFactory.js~MessageFactory.html">MessageFactory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Enum">Enum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MessageType">MessageType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-REASON_PHRASE">REASON_PHRASE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RESPONSE_CODE">RESPONSE_CODE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-messageFactory">messageFactory</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">reTHINKObject</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/reTHINKObject/RethinkObject.js~RethinkObject.html">RethinkObject</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">syncher</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObject.js~DataObject.html">DataObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObjectChild.js~DataObjectChild.html">DataObjectChild</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObjectObserver.js~DataObjectObserver.html">DataObjectObserver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/DataObjectReporter.js~DataObjectReporter.html">DataObjectReporter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/syncher/Syncher.js~Syncher.html">Syncher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataObject">dataObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataObjectChild">dataObjectChild</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataObjectObserver">dataObjectObserver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataObjectReporter">dataObjectReporter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataProvisional">dataProvisional</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ChangeType">ChangeType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ObjectType">ObjectType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-syncObject">syncObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-syncher">syncher</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/EventEmitter.js~EventEmitter.html">EventEmitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deepClone">deepClone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-divideURL">divideURL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-eventEmitter">eventEmitter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-divideURL">divideURL</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/address-factory/url.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;
const punycode = require(&quot;punycode&quot;);

const tr46 = require(&quot;tr46&quot;);

/* jshint unused: false */

function p(char) {
  return char.codePointAt(0);
}

const specialSchemas = {
    &quot;ftp&quot;: 21,
    &quot;file&quot;: null,
    &quot;gopher&quot;: 70,
    &quot;http&quot;: 80,
    &quot;https&quot;: 443,
    &quot;ws&quot;: 80,
    &quot;wss&quot;: 443,
    // reThink specific schemas
    &quot;user&quot;: null,
    &quot;ctxt&quot;: null,
    &quot;acct&quot;: null,
    &quot;user-uuid&quot;: null,
    &quot;domain&quot;: null,
    &quot;hyperty&quot;: null,
    &quot;hyperty-catalogue&quot;: null,
    &quot;hyperty-runtime&quot;: null,
    &quot;hyperty-runtime-uuid&quot;: null,
    &quot;hyperty-runtime-dev-os&quot;: null,
    &quot;hyperty-runtime-imei&quot;: null,
    &quot;hyperty-runtime-esn&quot;: null,
    &quot;hyperty-runtime-meid&quot;: null,
    &quot;comm&quot;: null
};

const localSchemas = [
  &quot;about&quot;,
  &quot;blob&quot;,
  &quot;data&quot;,
  &quot;filesystem&quot;
];

const bufferReplacement = {
  &quot;%2e&quot;: &quot;.&quot;,
  &quot;.%2e&quot;: &quot;..&quot;,
  &quot;%2e.&quot;: &quot;..&quot;,
  &quot;%2e%2e&quot;: &quot;..&quot;
};

const failure = Symbol(&quot;failure&quot;);

const STATES = {
  SCHEME_START: 1,
  SCHEME: 2,
  NO_SCHEME: 3,
  RELATIVE: 4,
  SPECIAL_RELATIVE_OR_AUTHORITY: 5,
  SPECIAL_AUTHORITY_SLASHES: 6,
  NON_RELATIVE_PATH: 7,
  QUERY: 8,
  FRAGMENT: 9,
  SPECIAL_AUTHORITY_IGNORE_SLASHES: 10,
  RELATIVE_SLASH: 11,
  PATH: 12,
  FILE_HOST: 13,
  AUTHORITY: 14,
  HOST: 15,
  PATH_START: 16,
  HOST_NAME: 17,
  PORT: 18,
  FILE: 19,
  FILE_SLASH: 20,
  PATH_OR_AUTHORITY: 21
};

function countSymbols(str) {
  return punycode.ucs2.decode(str).length;
}

function at(input, idx) {
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
}

function isASCIIDigit(c) {
  return c &gt;= 0x30 &amp;&amp; c &lt;= 0x39;
}

function isASCIIAlpha(c) {
  return (c &gt;= 0x41 &amp;&amp; c &lt;= 0x5A) || (c &gt;= 0x61 &amp;&amp; c &lt;= 0x7A);
}

function isASCIIHex(c) {
  return isASCIIDigit(c) || (c &gt;= 0x41 &amp;&amp; c &lt;= 0x46) || (c &gt;= 0x61 &amp;&amp; c &lt;= 0x66);
}

function isSingleDot(buffer) {
  return buffer === &quot;.&quot; || buffer.toLowerCase() === &quot;%2e&quot;;
}

function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === &quot;..&quot; || buffer === &quot;%2e.&quot; || buffer === &quot;.%2e&quot; || buffer === &quot;%2e%2e&quot;;
}

function percentEncode(c) {
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = &quot;0&quot; + hex;
  }

  return &quot;%&quot; + hex;
}

const invalidCodePoint = String.fromCodePoint(65533);
function utf8PercentEncode(c) {
  const buf = new Buffer(c);
  if (buf.toString() === invalidCodePoint) {
    return &quot;&quot;;
  }

  let str = &quot;&quot;;

  for (let i = 0; i &lt; buf.length; ++i) {
    str += percentEncode(buf[i]);
  }

  return str;
}

function utf8PercentDecode(str) {
  const input = new Buffer(str);
  const output = [];
  for (let i = 0; i &lt; input.length; ++i) {
    if (input[i] !== p(&quot;%&quot;)) {
      output.push(input[i]);
    } else if (input[i] === p(&quot;%&quot;) &amp;&amp; isASCIIHex(input[i + 1]) &amp;&amp; isASCIIHex(input[i + 2])) {
      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
      i += 2;
    } else {
      output.push(input[i]);
    }
  }
  return new Buffer(output).toString();
}

function isSimpleEncode(c) {
  return c &lt;= 0x1F || c &gt; 0x7E;
}

const defaultEncodeSet = [p(&quot; &quot;), p(&quot;\&quot;&quot;), p(&quot;#&quot;), p(&quot;&lt;&quot;), p(&quot;&gt;&quot;), p(&quot;?&quot;), p(&quot;`&quot;), p(&quot;{&quot;), p(&quot;}&quot;)];
function isDefaultEncode(c) {
  return isSimpleEncode(c) || defaultEncodeSet.indexOf(c) !== -1;
}

const userInfoEncodeSet = [p(&quot;/&quot;), p(&quot;:&quot;), p(&quot;;&quot;), p(&quot;=&quot;), p(&quot;@&quot;), p(&quot;[&quot;), p(&quot;\\&quot;), p(&quot;]&quot;), p(&quot;^&quot;), p(&quot;|&quot;)];
function isUserInfoEncode(c) {
  return isDefaultEncode(c) || userInfoEncodeSet.indexOf(c) !== -1;
}

function encodeChar(c, checkCb) {
  const c_str = String.fromCodePoint(c);

  if (checkCb(c)) {
    return utf8PercentEncode(c_str);
  }

  return c_str;
}

function parseIPv4Number(input) {
  let R = 10;

  if (input.length &gt;= 2 &amp;&amp; input.charAt(0) === &quot;0&quot; &amp;&amp; input.charAt(1).toLowerCase() === &quot;x&quot;) {
    input = input.substring(2);
    R = 16;
  } else if (input.length &gt;= 2 &amp;&amp; input.charAt(0) === &quot;0&quot;) {
    input = input.substring(1);
    R = 8;
  }

  if (input === &quot;&quot;) {
    return 0;
  }

  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
  if (regex.test(input)) {
    return failure;
  }

  return parseInt(input, R);
}

function parseIPv4(input) {
  let parts = input.split(&quot;.&quot;);
  if (parts[parts.length - 1] === &quot;&quot;) {
    parts.pop();
  }

  if (parts.length &gt; 4) {
    return input;
  }

  let numbers = [];
  for (const part of parts) {
    const n = parseIPv4Number(part);
    if (n === failure) {
      return input;
    }

    numbers.push(n);
  }

  for (let i = 0; i &lt; numbers.length - 1; ++i) {
    if (numbers[i] &gt; 255) {
      return failure;
    }
  }
  if (numbers[numbers.length - 1] &gt;= Math.pow(256, 5 - numbers.length)) {
    return failure;
  }

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) {
    ipv4 += n * Math.pow(256, 3 - counter);
    ++counter;
  }

  return ipv4;
}

function serializeIPv4(address) {
  let output = &quot;&quot;;
  let n = address;

  for (let i = 0; i &lt; 4; ++i) {
    output = String(n % 256) + output;
    if (i !== 3) {
      output = &quot;.&quot; + output;
    }
    n = Math.floor(n / 256);
  }

  return output;
}

function parseIPv6(input) {
  const ip = [0, 0, 0, 0, 0, 0, 0, 0];
  let piecePtr = 0;
  let compressPtr = null;
  let pointer = 0;

  input = punycode.ucs2.decode(input);

  if (input[pointer] === p(&quot;:&quot;)) {
    if (input[pointer + 1] !== p(&quot;:&quot;)) {
      return failure;
    }

    pointer += 2;
    ++piecePtr;
    compressPtr = piecePtr;
  }

  let ipv4 = false;
  Main:
  while (pointer &lt; input.length) {
    if (piecePtr === 8) {
      return failure;
    }

    if (input[pointer] === p(&quot;:&quot;)) {
      if (compressPtr !== null) {
        return failure;
      }
      ++pointer;
      ++piecePtr;
      compressPtr = piecePtr;
      continue;
    }

    let value = 0;
    let length = 0;

    while (length &lt; 4 &amp;&amp; isASCIIHex(input[pointer])) {
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    }

    switch (at(input, pointer)) {
      case &quot;.&quot;:
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        ipv4 = true;
        break Main;
      case &quot;:&quot;:
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
        break;
      case undefined:
        break;
      default:
        return failure;
    }

    ip[piecePtr] = value;
    ++piecePtr;
  }

  if (ipv4 &amp;&amp; piecePtr &gt; 6) {
    return failure;
  } else if (input[pointer] !== undefined) {
    let dotsSeen = 0;

    while (input[pointer] !== undefined) {
      let value = null;
      if (!isASCIIDigit(input[pointer])) {
        return failure;
      }

      while (isASCIIDigit(input[pointer])) {
        const number = parseInt(at(input, pointer), 10);
        if (value === null) {
          value = number;
        } else if (value === 0) {
          return failure;
        } else {
          value = value * 10 + number;
        }
        ++pointer;
        if (value &gt; 255) {
          return failure;
        }
      }

      if (dotsSeen &lt; 3 &amp;&amp; input[pointer] !== p(&quot;.&quot;)) {
        return failure;
      }
      ip[piecePtr] = ip[piecePtr] * 0x100 + value;
      if (dotsSeen === 1 || dotsSeen === 3) {
        ++piecePtr;
      }

      if (input[pointer] !== undefined) {
        ++pointer;
      }

      if (dotsSeen === 3 &amp;&amp; input[pointer] !== undefined) {
        return failure;
      }
      ++dotsSeen;
    }
  }

  if (compressPtr !== null) {
    let swaps = piecePtr - compressPtr;
    piecePtr = 7;
    while (piecePtr !== 0 &amp;&amp; swaps &gt; 0) {
      const temp = ip[compressPtr + swaps - 1]; // piece
      ip[compressPtr + swaps - 1] = ip[piecePtr];
      ip[piecePtr] = temp;
      --piecePtr;
      --swaps;
    }
  } else if (piecePtr !== 8) {
    return failure;
  }

  return ip;
}

function serializeIPv6(address) {
  let output = &quot;&quot;;
  const seqResult = findLongestZeroSequence(address);
  const compressPtr = seqResult.idx;

  for (var i = 0; i &lt; address.length; ++i) {
    if (compressPtr === i) {
      if (i === 0) {
        output += &quot;::&quot;;
      } else {
        output += &quot;:&quot;;
      }

      i += seqResult.len - 1;
      continue;
    }

    output += address[i].toString(16);
    if (i !== address.length - 1) {
      output += &quot;:&quot;;
    }
  }

  return output;
}

function parseHost(input, isUnicode) {
  if (input[0] === &quot;[&quot;) {
    if (input[input.length - 1] !== &quot;]&quot;) {
      return failure;
    }

    return parseIPv6(input.substring(1, input.length - 1));
  }

  const domain = utf8PercentDecode(input);
  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.TRANSITIONAL, false);
  if (asciiDomain === null) {
    return failure;
  }

  if (asciiDomain.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1) {
    return failure;
  }

  let ipv4Host = parseIPv4(asciiDomain);
  if (typeof ipv4Host === &quot;number&quot; || ipv4Host === failure) {
    return ipv4Host;
  }

  return isUnicode ? tr46.toUnicode(asciiDomain, false).domain : asciiDomain;
}

function findLongestZeroSequence(arr) {
  let maxIdx = null;
  let maxLen = 1; // only find elements &gt; 1
  let currStart = null;
  let currLen = 0;

  for (var i = 0; i &lt; arr.length; ++i) {
    if (arr[i] !== 0) {
      if (currLen &gt; maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }

      currStart = null;
      currLen = 0;
    } else {
      if (currStart === null) {
        currStart = i;
      }
      ++currLen;
    }
  }

  return {
    idx: maxIdx,
    len: maxLen
  };
}

function serializeHost(host) {
  if (typeof host === &quot;number&quot;) {
    return serializeIPv4(host);
  }

  // IPv6 serializer
  if (host instanceof Array) {
    return &quot;[&quot; + serializeIPv6(host) + &quot;]&quot;;
  }

  return host;
}

function trimControlChars(url) {
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, &quot;&quot;);
}

function URLStateMachine(input, base, encoding_override, url, state_override) {
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encoding_override = encoding_override || &quot;utf-8&quot;;
  this.state_override = state_override;
  this.url = url;
  this.failure = false;
  this.parse_error = false;

  if (!this.url) {
    this.url = {
      scheme: &quot;&quot;,
      username: &quot;&quot;,
      password: null,
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,

      nonRelative: false
    };

    const res = trimControlChars(this.input);
    if (res !== this.input) {
      this.parse_error = true;
    }
    this.input = res;
  }

  this.state = state_override || STATES.SCHEME_START;

  this.buffer = &quot;&quot;;
  this.at_flag = false;
  this.arr_flag = false;

  this.input = punycode.ucs2.decode(this.input);

  for (; this.pointer &lt;= this.input.length; ++this.pointer) {
    const c = this.input[this.pointer];
    const c_str = isNaN(c) ? undefined : String.fromCodePoint(c);

    // exec state machine
    const ret = this[&quot;parse&quot; + this.state](c, c_str);
    if (ret === false) {
      break; // terminate algorithm
    } else if (ret === failure) {
      this.failure = true;
      break;
    }
  }
}

URLStateMachine.prototype[&quot;parse&quot; + STATES.SCHEME_START] =
    function parseSchemeStart(c, c_str) {
  if (isASCIIAlpha(c)) {
    this.buffer += c_str.toLowerCase();
    this.state = STATES.SCHEME;
  } else if (!this.state_override) {
    this.state = STATES.NO_SCHEME;
    --this.pointer;
  } else {
    this.parse_error = true;
    return false;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.SCHEME] =
    function parseScheme(c, c_str) {
  if (isASCIIAlpha(c) || c === p(&quot;+&quot;) || c === p(&quot;-&quot;) || c === p(&quot;.&quot;)) {
    this.buffer += c_str.toLowerCase();
  } else if (c === p(&quot;:&quot;)) {
    if (this.state_override) {
      // TODO: XOR
      if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; !specialSchemas[this.buffer]) {
        return false;
      } else if (specialSchemas[this.url.scheme] === undefined &amp;&amp; specialSchemas[this.buffer]) {
        return false;
      }
    }
    this.url.scheme = this.buffer;
    this.buffer = &quot;&quot;;
    if (this.state_override) {
      return false;
    }
    if (this.url.scheme === &quot;file&quot;) {
      if (this.input[this.pointer + 1] === p(&quot;/&quot;) &amp;&amp; this.input[this.pointer + 2] === p(&quot;/&quot;)) {
        this.parse_error = true;
      }
      this.state = STATES.FILE;
    } else if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; this.base !== null &amp;&amp;
               this.base.scheme === this.url.scheme) {
      this.state = STATES.SPECIAL_RELATIVE_OR_AUTHORITY;
    } else if (specialSchemas[this.url.scheme] !== undefined) {
      this.state = STATES.SPECIAL_AUTHORITY_SLASHES;
    } else if (this.input[this.pointer + 1] === p(&quot;/&quot;)) {
      this.state = STATES.PATH_OR_AUTHORITY;
      ++this.pointer;
    } else {
      this.url.nonRelative = true;
      this.url.path.push(&quot;&quot;);
      this.state = STATES.NON_RELATIVE_PATH;
    }
  } else if (!this.state_override) {
    this.buffer = &quot;&quot;;
    this.state = STATES.NO_SCHEME;
    this.pointer = -1;
  } else {
    this.parse_error = true;
    return false;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.NO_SCHEME] =
    function parseNoScheme(c, c_str) {
  //jshint unused:false
  if (this.base === null || (this.base.nonRelative &amp;&amp; c !== p(&quot;#&quot;))) {
    return failure;
  } else if (this.base.nonRelative &amp;&amp; c === p(&quot;#&quot;)) {
    this.url.scheme = this.base.scheme;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = &quot;&quot;;
    this.url.nonRelative = true;
    this.state = STATES.FRAGMENT;
  } else if (this.base.scheme === &quot;file&quot;) {
    this.state = STATES.FILE;
    --this.pointer;
  } else {
    this.state = STATES.RELATIVE;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.SPECIAL_RELATIVE_OR_AUTHORITY] =
    function parseSpecialRelativeOrAuthority(c, c_str) {
  if (c === p(&quot;/&quot;) &amp;&amp; this.input[this.pointer + 1] === p(&quot;/&quot;)) {
    this.state = STATES.SPECIAL_AUTHORITY_IGNORE_SLASHES;
    ++this.pointer;
  } else {
    this.parse_error = true;
    this.state = STATES.RELATIVE;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.PATH_OR_AUTHORITY] =
    function parsePathOrAuthority(c, c_str) {
  if (c === p(&quot;/&quot;)) {
    this.state = STATES.AUTHORITY;
  } else {
    this.state = STATES.PATH;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.RELATIVE] =
    function parseRelative(c, c_str) {
  this.url.scheme = this.base.scheme;
  if (isNaN(c)) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
  } else if (c === p(&quot;/&quot;)) {
    this.state = STATES.RELATIVE_SLASH;
  } else if (c === p(&quot;?&quot;)) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = &quot;&quot;;
    this.state = STATES.QUERY;
  } else if (c === p(&quot;#&quot;)) {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice();
    this.url.query = this.base.query;
    this.url.fragment = &quot;&quot;;
    this.state = STATES.FRAGMENT;
  } else if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;)) {
    this.parse_error = true;
    this.state = STATES.RELATIVE_SLASH;
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

    this.state = STATES.PATH;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.RELATIVE_SLASH] =
    function parseRelativeSlash(c, c_str) {
  if (c === p(&quot;/&quot;) || (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;))) {
    if (c === p(&quot;\\&quot;)) {
      this.parse_error = true;
    }
    this.state = STATES.SPECIAL_AUTHORITY_IGNORE_SLASHES;
  } else {
    this.url.username = this.base.username;
    this.url.password = this.base.password;
    this.url.host = this.base.host;
    this.url.port = this.base.port;
    this.state = STATES.PATH;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.SPECIAL_AUTHORITY_SLASHES] =
    function parseSpecialAuthoritySlashes(c, c_str) {
  if (c === p(&quot;/&quot;) &amp;&amp; this.input[this.pointer + 1] === p(&quot;/&quot;)) {
    this.state = STATES.SPECIAL_AUTHORITY_IGNORE_SLASHES;
    ++this.pointer;
  } else {
    this.parse_error = true;
    this.state = STATES.SPECIAL_AUTHORITY_IGNORE_SLASHES;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.SPECIAL_AUTHORITY_IGNORE_SLASHES] =
    function parseSpecialAuthorityIgnoreSlashes(c, c_str) {
  if (c !== p(&quot;/&quot;) &amp;&amp; c !== p(&quot;\\&quot;)) {
    this.state = STATES.AUTHORITY;
    --this.pointer;
  } else {
    this.parse_error = true;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.AUTHORITY] =
    function parseAuthority(c, c_str) {
  if (c === p(&quot;@&quot;)) {
    this.parse_error = true;
    if (this.at_flag) {
      this.buffer = &quot;%40&quot; + this.buffer;
    }
    this.at_flag = true;

    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
    const len = countSymbols(this.buffer);
    for (let pointer = 0; pointer &lt; len; ++pointer) {
      /* jshint -W004 */
      const c = this.buffer.codePointAt(pointer);
      /* jshint +W004 */

      if (c === 0x9 || c === 0xA || c === 0xD) {
        continue;
      }

      if (c === p(&quot;:&quot;) &amp;&amp; this.url.password === null) {
        this.url.password = &quot;&quot;;
        continue;
      }
      const encodedCodePoints = encodeChar(c, isUserInfoEncode);
      if (this.url.password !== null) {
        this.url.password += encodedCodePoints;
      } else {
        this.url.username += encodedCodePoints;
      }
    }
    this.buffer = &quot;&quot;;
  } else if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;) ||
             (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;))) {
    this.pointer -= countSymbols(this.buffer) + 1;
    this.buffer = &quot;&quot;;
    this.state = STATES.HOST;
  } else {
    this.buffer += c_str;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.HOST_NAME] =
URLStateMachine.prototype[&quot;parse&quot; + STATES.HOST] =
    function parseHostName(c, c_str) {
  if (c === p(&quot;:&quot;) &amp;&amp; !this.arr_flag) {
    if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; this.buffer === &quot;&quot;) {
      return failure;
    }

    let host = parseHost(this.buffer);
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = &quot;&quot;;
    this.state = STATES.PORT;
    if (this.state_override === STATES.HOST_NAME) {
      return false;
    }
  } else if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;) ||
             (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;))) {
    --this.pointer;
    if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; this.buffer === &quot;&quot;) {
      return failure;
    }

    let host = parseHost(this.buffer);
    if (host === failure) {
      return failure;
    }

    this.url.host = host;
    this.buffer = &quot;&quot;;
    this.state = STATES.PATH_START;
    if (this.state_override) {
      return false;
    }
  } else if (c === 0x9 || c === 0xA || c === 0xD) {
    this.parse_error = true;
  } else {
    if (c === p(&quot;[&quot;)) {
      this.arr_flag = true;
    } else if (c === p(&quot;]&quot;)) {
      this.arr_flag = false;
    }
    this.buffer += c_str;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.PORT] =
    function parsePort(c, c_str) {
  if (isASCIIDigit(c)) {
    this.buffer += c_str;
  } else if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;) ||
             (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;)) ||
             this.state_override) {
    if (this.buffer !== &quot;&quot;) {
      const port = parseInt(this.buffer, 10);
      if (port &gt; Math.pow(2, 16) - 1) {
        this.parse_error = true;
        return failure;
      }
      this.url.port = port === specialSchemas[this.url.scheme] ? null : port;
      this.buffer = &quot;&quot;;
    }
    if (this.state_override) {
      return false;
    }
    this.state = STATES.PATH_START;
    --this.pointer;
  } else if (c === 0x9 || c === 0xA || c === 0xD) {
    this.parse_error = true;
  } else {
    this.parse_error = true;
    return failure;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.FILE] =
    function parseFile(c, c_str) {
  this.url.scheme = &quot;file&quot;;
  if (isNaN(c)) {
    if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
    }
  } else if (c === p(&quot;/&quot;) || c === p(&quot;\\&quot;)) {
    if (c === p(&quot;\\&quot;)) {
      this.parse_error = true;
    }
    this.state = STATES.FILE_SLASH;
  } else if (c === p(&quot;?&quot;)) {
    if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = &quot;&quot;;
    }
    this.state = STATES.QUERY;
  } else if (c === p(&quot;#&quot;)) {
    if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      this.url.fragment = &quot;&quot;;
    }
    this.state = STATES.FRAGMENT;
  } else {
    if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
      if ((!isASCIIAlpha(c) || // windows drive letter
           (this.input[this.pointer + 1] !== p(&quot;:&quot;) &amp;&amp; this.input[this.pointer + 1] !== p(&quot;|&quot;))) ||
          this.input.length - this.pointer - 1 === 1 || // remaining consists of 1 code point
          [p(&quot;/&quot;), p(&quot;\\&quot;), p(&quot;?&quot;), p(&quot;#&quot;)].indexOf(this.input[this.pointer + 2]) === -1) {
        this.url.host = this.base.host;
        this.url.path = this.base.path.slice();
        this.url.path.pop();
      } else {
        this.parse_error = true;
      }
    }
    this.state = STATES.PATH;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.FILE_SLASH] =
    function parseFileSlash(c, c_str) {
  if (c === p(&quot;/&quot;) || c === p(&quot;\\&quot;)) {
    if (c === p(&quot;\\&quot;)) {
      this.parse_error = true;
    }
    this.state = STATES.FILE_HOST;
  } else {
    if (this.base !== null &amp;&amp; this.base.scheme === &quot;file&quot;) {
      if (this.base.path.length &amp;&amp; isASCIIAlpha(this.base.path[0][0].charCodeAt(0)) &amp;&amp; this.base.path[0][1] === &quot;:&quot;) {
        this.url.path.push(this.base.path[0]);
      }
    }
    this.state = STATES.PATH;
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.FILE_HOST] =
    function parseFileHost(c, c_str) {
  if (isNaN(c) || c === p(&quot;/&quot;) || c === p(&quot;\\&quot;) || c === p(&quot;?&quot;) || c === p(&quot;#&quot;)) {
    --this.pointer;
    // don&apos;t need to count symbols here since we check ASCII values
    if (this.buffer.length === 2 &amp;&amp;
      isASCIIAlpha(this.buffer.codePointAt(0)) &amp;&amp; (this.buffer[1] === &quot;:&quot; || this.buffer[1] === &quot;|&quot;)) {
      this.state = STATES.PATH;
    } else if (this.buffer === &quot;&quot;) {
      this.state = STATES.PATH_START;
    } else {
      let host = parseHost(this.buffer);
      if (host === failure) {
        return failure;
      }
      if (host !== &quot;localhost&quot;) {
        this.url.host = host;
      }

      this.buffer = &quot;&quot;;
      this.state = STATES.PATH_START;
    }
  } else if (c === 0x9 || c === 0xA || c === 0xD) {
    this.parse_error = true;
  } else {
    this.buffer += c_str;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.PATH_START] =
    function parsePathStart(c, c_str) {
  if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;)) {
    this.parse_error = true;
  }
  this.state = STATES.PATH;
  if (c !== p(&quot;/&quot;) &amp;&amp; !(specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;))) {
    --this.pointer;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.PATH] =
    function parsePath(c, c_str) {
  if (isNaN(c) || c === p(&quot;/&quot;) || (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;)) ||
      (!this.state_override &amp;&amp; (c === p(&quot;?&quot;) || c === p(&quot;#&quot;)))) {
    if (specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;)) {
      this.parse_error = true;
    }

    if (isDoubleDot(this.buffer)) {
      this.url.path.pop();
      if (c !== p(&quot;/&quot;) &amp;&amp; !(specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;))) {
        this.url.path.push(&quot;&quot;);
      }
    } else if (isSingleDot(this.buffer) &amp;&amp; c !== p(&quot;/&quot;) &amp;&amp;
               !(specialSchemas[this.url.scheme] !== undefined &amp;&amp; c === p(&quot;\\&quot;))) {
      this.url.path.push(&quot;&quot;);
    } else if (!isSingleDot(this.buffer)) {
      if (this.url.scheme === &quot;file&quot; &amp;&amp; this.url.path.length === 0 &amp;&amp;
        this.buffer.length === 2 &amp;&amp; isASCIIAlpha(this.buffer.codePointAt(0)) &amp;&amp;
        (this.buffer[1] === &quot;|&quot; || this.buffer[1] === &quot;:&quot;)) {
        if (this.url.host !== null) {
          this.parse_error = true;
        }
        this.url.host = null;
        this.buffer = this.buffer[0] + &quot;:&quot;;
      }
      this.url.path.push(this.buffer);
    }
    this.buffer = &quot;&quot;;
    if (c === p(&quot;?&quot;)) {
      this.url.query = &quot;&quot;;
      this.state = STATES.QUERY;
    }
    if (c === p(&quot;#&quot;)) {
      this.url.fragment = &quot;&quot;;
      this.state = STATES.FRAGMENT;
    }
  } else if (c === 0x9 || c === 0xA || c === 0xD) {
    this.parse_error = true;
  } else {
    //TODO:If c is not a URL code point and not &quot;%&quot;, parse error.
    if (c === p(&quot;%&quot;) &amp;&amp;
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parse_error = true;
    }

    this.buffer += encodeChar(c, isDefaultEncode);
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.NON_RELATIVE_PATH] =
    function parseNonRelativePath(c, c_str) {
  if (c === p(&quot;?&quot;)) {
    this.url.query = &quot;&quot;;
    this.state = STATES.QUERY;
  } else if (c === p(&quot;#&quot;)) {
    this.url.fragment = &quot;&quot;;
    this.state = STATES.FRAGMENT;
  } else {
    // TODO: Add: not a URL code point
    if (!isNaN(c) &amp;&amp; c !== p(&quot;%&quot;)) {
      this.parse_error = true;
    }

    if (c === p(&quot;%&quot;) &amp;&amp;
        (!isASCIIHex(this.input[this.pointer + 1]) ||
         !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parse_error = true;
    }

    if (!isNaN(c) &amp;&amp; c !== 0x9 &amp;&amp; c !== 0xA &amp;&amp; c !== 0xD) {
      this.url.path[0] = this.url.path[0] + encodeChar(c, isSimpleEncode);
    }
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.QUERY] =
    function parseQuery(c, c_str) {
  if (isNaN(c) || (!this.state_override &amp;&amp; c === p(&quot;#&quot;))) {
    if (specialSchemas[this.url.scheme] === undefined || this.url.scheme === &quot;ws&quot; || this.url.scheme === &quot;wss&quot;) {
      this.encoding_override = &quot;utf-8&quot;;
    }

    const buffer = new Buffer(this.buffer); //TODO: Use encoding override instead
    for (let i = 0; i &lt; buffer.length; ++i) {
      if (buffer[i] &lt; 0x21 || buffer[i] &gt; 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
          buffer[i] === 0x3C || buffer[i] === 0x3E) {
        this.url.query += percentEncode(buffer[i]);
      } else {
        this.url.query += String.fromCodePoint(buffer[i]);
      }
    }

    this.buffer = &quot;&quot;;
    if (c === p(&quot;#&quot;)) {
      this.url.fragment = &quot;&quot;;
      this.state = STATES.FRAGMENT;
    }
  } else if (c === 0x9 || c === 0xA || c === 0xD) {
    this.parse_error = true;
  } else {
    //TODO: If c is not a URL code point and not &quot;%&quot;, parse error.
    if (c === p(&quot;%&quot;) &amp;&amp;
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parse_error = true;
    }

    this.buffer += c_str;
  }
};

URLStateMachine.prototype[&quot;parse&quot; + STATES.FRAGMENT] =
    function parseFragment(c, c_str) {
  if (isNaN(c)) { // do nothing
  } else if (c === 0x0 || c === 0x9 || c === 0xA || c === 0xD) {
    this.parse_error = true;
  } else {
    //TODO: If c is not a URL code point and not &quot;%&quot;, parse error.
    if (c === p(&quot;%&quot;) &amp;&amp;
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parse_error = true;
    }

    this.url.fragment += c_str;
  }
};

function serializeURL(url, excludeFragment) {
  let output = url.scheme + &quot;:&quot;;
  if (url.host !== null) {
    output += &quot;//&quot; + url.username;
    if (url.password !== null) {
      output += &quot;:&quot; + url.password;
    }
    if (url.username !== &quot;&quot; || url.password !== null) {
      output += &quot;@&quot;;
    }
    output += serializeHost(url.host);
    if (url.port !== null) {
      output += &quot;:&quot; + url.port;
    }
  } else if (url.host === null &amp;&amp; url.scheme === &quot;file&quot;) {
    output += &quot;//&quot;;
  }

  if (url.nonRelative) {
    output += url.path[0];
  } else {
    output += &quot;/&quot; + url.path.join(&quot;/&quot;);
  }

  if (url.query !== null) {
    output += &quot;?&quot; + url.query;
  }

    if (!excludeFragment &amp;&amp; url.fragment !== null) {
	output += &quot;#&quot; + url.fragment;
    }

  return output;
}

function serializeOrigin(tuple) {
  if (tuple.scheme === undefined || tuple.host === undefined || tuple.port === undefined) {
    return &quot;null&quot;;
  }

  let result = tuple.scheme + &quot;://&quot;;
  result += tr46.toUnicode(tuple.host, false).domain;

  if (specialSchemas[tuple.scheme] &amp;&amp; tuple.port !== specialSchemas[tuple.scheme]) {
    result += &quot;:&quot; + tuple.port;
  }

  return result;
}

function mixin(src, target) {
  const props = Object.getOwnPropertyNames(src);

  for (let i = 0; i &lt; props.length; ++i) {
    const descriptor = Object.getOwnPropertyDescriptor(src, props[i]);
    Object.defineProperty(target, props[i], descriptor);
  }

  const symbols = Object.getOwnPropertySymbols(src);
  for (var i = 0; i &lt; symbols.length; ++i) {
    target[symbols[i]] = src[symbols[i]];
  }
}

const inputSymbol = Symbol(&quot;input&quot;);
const encodingSymbol = Symbol(&quot;queryEncoding&quot;);
const querySymbol = Symbol(&quot;queryObject&quot;);
const urlSymbol = Symbol(&quot;url&quot;);

const baseSymbol = Symbol(&quot;base&quot;);
const isURLSymbol = Symbol(&quot;isURL&quot;);
const updateStepsSymbol = Symbol(&quot;updateSteps&quot;);

function setTheInput(obj, input, url) {
  obj[inputSymbol] = input;
  obj[urlSymbol] = url ? url : null;

  if (input === null) {
    let parsed;
    if (typeof obj[baseSymbol] === &quot;function&quot;) {
      parsed = new URLStateMachine(input, new URLStateMachine(obj[baseSymbol]()).url);
    } else {
      parsed = new URLStateMachine(input, obj[baseSymbol]);
    }
    if (!parsed.failure) {
      obj[urlSymbol] = parsed;
    }
  }

  const query = obj[urlSymbol] !== null &amp;&amp; obj[urlSymbol].url.query !== null ? obj[urlSymbol].url.query : &quot;&quot;;
  // TODO: Update URLSearchParams
}

function resetTheInput(obj) {
  if (obj[isURLSymbol] || obj[inputSymbol] === null) {
    return;
  }

  setTheInput(obj, obj[inputSymbol], obj[urlSymbol]);
}

const URLUtils = {
  get href() {
    resetTheInput(this);
    if (this[inputSymbol] === null) {
      return &quot;&quot;;
    }
    if (this[urlSymbol] === null) {
      return this[inputSymbol];
    }

    return serializeURL(this[urlSymbol].url);
  },
  set href(val) {
    let input = String(val);

    if (this[isURLSymbol]) {
      // SPEC: says to use &quot;get the base&quot; algorithm,
      // but the base might&apos;ve already been provided by the constructor.
      // Clarify!
      // Can&apos;t set base symbol to function in URL constructor, so don&apos;t need to check this
      const parsedURL = new URLStateMachine(input, this[baseSymbol]);
      input = &quot;&quot;;
      setTheInput(this, &quot;&quot;, parsedURL);
    } else {
      setTheInput(this, input);
      preUpdateSteps(this, input);
    }
  },

  get origin() {
    resetTheInput(this);
    if (this[urlSymbol] === null) {
      return &quot;&quot;;
    }

    const url = this[urlSymbol].url;
    switch (url.scheme) {
      case &quot;blob&quot;:
        try {
          return module.exports.createURLConstructor()(url.scheme_data).origin;
        } catch (e) {
          // serializing an opaque identifier returns &quot;null&quot;
          return &quot;null&quot;;
        }
        break;
      case &quot;ftp&quot;:
      case &quot;gopher&quot;:
      case &quot;http&quot;:
      case &quot;https&quot;:
      case &quot;ws&quot;:
      case &quot;wss&quot;:
      case &quot;user&quot;:
      case &quot;ctxt&quot;:
      case &quot;acct&quot;:
      case &quot;user-uuid&quot;:
      case &quot;domain&quot;:
      case &quot;hyperty&quot;:
      case &quot;hyperty-catalogue&quot;:
      case &quot;hyperty-runtime&quot;:
      case &quot;hyperty-runtime-uuid&quot;:
      case &quot;hyperty-runtime-dev-os&quot;:
      case &quot;hyperty-runtime-imei&quot;:
      case &quot;hyperty-runtime-esn&quot;:
      case &quot;hyperty-runtime-meid&quot;:
      case &quot;comm&quot;:
        return serializeOrigin({
          scheme: url.scheme,
          host: serializeHost(url.host),
          port: url.port === null ? specialSchemas[url.scheme] : url.port
        });
      case &quot;file&quot;:
        // spec says &quot;exercise to the reader&quot;, chrome says &quot;file://&quot;
        return &quot;file://&quot;;
      default:
        // serializing an opaque identifier returns &quot;null&quot;
	// &lt;rethink&gt; Consider here the schemas defined in reThink
        return &quot;null&quot;;
    }
  },

  get protocol() {
    resetTheInput(this);
    if (this[urlSymbol] === null) {
      return &quot;:&quot;;
    }
    return this[urlSymbol].url.scheme + &quot;:&quot;;
  },
  set protocol(val) {
    if (this[urlSymbol] === null) {
      return;
    }
    this[urlSymbol] = new URLStateMachine(val + &quot;:&quot;, null, null, this[urlSymbol].url, STATES.SCHEME_START);
    preUpdateSteps(this);
  },

  get username() {
    resetTheInput(this);
    return this[urlSymbol] === null ? &quot;&quot; : this[urlSymbol].url.username;
  },
  set username(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.host === null || this[urlSymbol].url.nonRelative) {
      return;
    }

    this[urlSymbol].url.username = &quot;&quot;;
    const decoded = punycode.ucs2.decode(val);
    for (let i = 0; i &lt; decoded.length; ++i) {
      this[urlSymbol].url.username += encodeChar(decoded[i], isUserInfoEncode);
    }
    preUpdateSteps(this);
  },

  get password() {
    resetTheInput(this);
    return this[urlSymbol] === null || this[urlSymbol].url.password === null ? &quot;&quot; : this[urlSymbol].url.password;
  },
  set password(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.host === null || this[urlSymbol].url.nonRelative) {
      return;
    }

    this[urlSymbol].url.password = &quot;&quot;;
    const decoded = punycode.ucs2.decode(val);
    for (let i = 0; i &lt; decoded.length; ++i) {
      this[urlSymbol].url.password += encodeChar(decoded[i], isUserInfoEncode);
    }
    preUpdateSteps(this);
  },

  get host() {
    resetTheInput(this);
    if (this[urlSymbol] === null || this[urlSymbol].url.host === null) {
      return &quot;&quot;;
    }
    return serializeHost(this[urlSymbol].url.host) +
           (this[urlSymbol].url.port === null ? &quot;&quot; : &quot;:&quot; + this[urlSymbol].url.port);
  },
  set host(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.nonRelative) {
      return;
    }
    this[urlSymbol] = new URLStateMachine(val, null, null, this[urlSymbol].url, STATES.HOST);
    preUpdateSteps(this);
  },

  get hostname() {
    resetTheInput(this);
    if (this[urlSymbol] === null || this[urlSymbol].url.host === null) {
      return &quot;&quot;;
    }
    return serializeHost(this[urlSymbol].url.host);
  },
  set hostname(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.nonRelative) {
      return;
    }
    this[urlSymbol] = new URLStateMachine(val, null, null, this[urlSymbol].url, STATES.HOST_NAME);
    preUpdateSteps(this);
  },

  get port() {
    resetTheInput(this);
    if (this[urlSymbol] === null || this[urlSymbol].url.port === null) {
      return &quot;&quot;;
    }
    return this[urlSymbol].url.port.toString();
  },
  set port(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.nonRelative || this[urlSymbol].url.scheme === &quot;file&quot;) {
      return;
    }
    this[urlSymbol] = new URLStateMachine(val, null, null, this[urlSymbol].url, STATES.PORT);
    preUpdateSteps(this);
  },

  get pathname() {
    resetTheInput(this);
    if (this[urlSymbol] === null) {
      return &quot;&quot;;
    }
    if (this[urlSymbol].url.nonRelative) {
      return this[urlSymbol].url.path[0];
    }

    return &quot;/&quot; + this[urlSymbol].url.path.join(&quot;/&quot;);
  },
  set pathname(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.nonRelative) {
      return;
    }
    this[urlSymbol].url.path = [];
    this[urlSymbol] = new URLStateMachine(val, null, null, this[urlSymbol].url, STATES.PATH_START);
    preUpdateSteps(this);
  },

  get search() {
    resetTheInput(this);
    if (this[urlSymbol] === null || !this[urlSymbol].url.query) {
      return &quot;&quot;;
    }

    return &quot;?&quot; + this[urlSymbol].url.query;
  },
  set search(val) {
    if (this[urlSymbol] === null) {
      return;
    }
    if (val === &quot;&quot;) {
      this[urlSymbol].url.query = null;
      // TODO: empty query object
      preUpdateSteps(this);
      return;
    }

    const input = val[0] === &quot;?&quot; ? val.substr(1) : val;
    this[urlSymbol].url.query = &quot;&quot;;

    // TODO: Add query encoding
    this[urlSymbol] = new URLStateMachine(input, null, null, this[urlSymbol].url, STATES.QUERY);

    // TODO: Update query object
    // Since the query object isn&apos;t implemented, call updateSteps manually for now
    preUpdateSteps(this);
  },

  get hash() {
    if (this[urlSymbol] === null || !this[urlSymbol].url.fragment) {
      return &quot;&quot;;
    }

    return &quot;#&quot; + this[urlSymbol].url.fragment;
  },
  set hash(val) {
    if (this[urlSymbol] === null || this[urlSymbol].url.scheme === &quot;javascript&quot;) {
      return;
    }
    if (val === &quot;&quot;) {
      this[urlSymbol].url.fragment = null;
      preUpdateSteps(this);
      return;
    }

    const input = val[0] === &quot;#&quot; ? val.substr(1) : val;
    this[urlSymbol].url.fragment = &quot;&quot;;
    this[urlSymbol] = new URLStateMachine(input, null, null, this[urlSymbol].url, STATES.FRAGMENT);
    preUpdateSteps(this);
  },

  toString() {
    return this.href;
  }
};

function urlToASCII(domain) {
    try {
	const asciiDomain = parseHost(domain);
	
	if (typeof asciiDomain !== &quot;string&quot;) {
	    return &quot;&quot;;
	}
	
	return asciiDomain;
    } catch (e) {
	return &quot;&quot;;
    }
}

function urlToUnicode(domain) {
  try {
    const unicodeDomain = parseHost(domain, true);
    if (typeof unicodeDomain !== &quot;string&quot;) {
      return &quot;&quot;;
    }
    return unicodeDomain;
  } catch (e) {
    return &quot;&quot;;
  }
}

function init(url, base) {
  /*jshint validthis:true */
  if (this === undefined) {
    throw new TypeError(&quot;Failed to construct &apos;URL&apos;: Please use the &apos;new&apos; operator, &quot; +
      &quot;this DOM object constructor cannot be called as a function.&quot;);
  }
  if (arguments.length === 0) {
    throw new TypeError(&quot;Failed to construct &apos;URL&apos;: 1 argument required, but only 0 present.&quot;);
  }

  let parsedBase = null;
  if (base) {
    parsedBase = new URLStateMachine(base);
    if (parsedBase.failure) {
      throw new TypeError(&quot;Invalid base URL&quot;);
    }
    this[baseSymbol] = parsedBase.url;
  }

  const parsedURL = new URLStateMachine(url, parsedBase ? parsedBase.url : undefined);
  if (parsedURL.failure) {
    throw new TypeError(&quot;Invalid URL&quot;);
  }
  setTheInput(this, &quot;&quot;, parsedURL);
}

function preUpdateSteps(obj, value) {
  if (value === undefined) {
    value = serializeURL(obj[urlSymbol].url);
  }

  obj[updateStepsSymbol].call(obj, value);
}

module.exports.createURLConstructor = function () {
  function URL() {
    this[isURLSymbol] = true;
    this[updateStepsSymbol] = function () {};
    init.apply(this, arguments);
  }

  mixin(URLUtils, URL.prototype);
  URL.toASCII = urlToASCII;
  URL.toUnicode = urlToUnicode;

  return URL;
};

module.exports.mixinURLUtils = function (obj, base, updateSteps) {
  obj[isURLSymbol] = false;
  if (typeof base === &quot;function&quot;) {
    obj[baseSymbol] = base;
  } else {
    obj[baseSymbol] = new URLStateMachine(base).url;
  }
  obj[updateStepsSymbol] = updateSteps || function () {};

  mixin(URLUtils, obj);
};

module.exports.setTheInput = function (obj, input) {
  setTheInput(obj, input, null);
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
